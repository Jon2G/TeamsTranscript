{"version":3,"file":"background.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC/rjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClmBA;AACA;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;AEJA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://teams-transcript/./node_modules/betajs-scoped/dist/scoped.js","webpack://teams-transcript/./node_modules/betajs/dist/beta.js","webpack://teams-transcript/./node_modules/docker-polyfill/src/client.js","webpack://teams-transcript/./node_modules/docker-polyfill/src/files.js","webpack://teams-transcript/./node_modules/docker-polyfill/src/runner.js","webpack://teams-transcript/./node_modules/events/events.js","webpack://teams-transcript/./node_modules/js-ffmpeg/index.js","webpack://teams-transcript/./node_modules/js-ffmpeg/src/ffmpeg-faststart.js","webpack://teams-transcript/./node_modules/js-ffmpeg/src/ffmpeg-graceful.js","webpack://teams-transcript/./node_modules/js-ffmpeg/src/ffmpeg-helpers.js","webpack://teams-transcript/./node_modules/js-ffmpeg/src/ffmpeg-multi-pass.js","webpack://teams-transcript/./node_modules/js-ffmpeg/src/ffmpeg-playlist.js","webpack://teams-transcript/./node_modules/js-ffmpeg/src/ffmpeg-simple.js","webpack://teams-transcript/./node_modules/js-ffmpeg/src/ffmpeg-test.js","webpack://teams-transcript/./node_modules/js-ffmpeg/src/ffmpeg-volume-detect.js","webpack://teams-transcript/./node_modules/js-ffmpeg/src/ffmpeg.js","webpack://teams-transcript/./node_modules/js-ffmpeg/src/ffprobe-simple.js","webpack://teams-transcript/./node_modules/js-ffmpeg/src/ffprobe.js","webpack://teams-transcript/./node_modules/os-tmpdir/index.js","webpack://teams-transcript/./node_modules/tmp/lib/tmp.js","webpack://teams-transcript/./src/index.js","webpack://teams-transcript/./src/sw-omnibox.js","webpack://teams-transcript/./src/sw-tips.js","webpack://teams-transcript/webpack/bootstrap","webpack://teams-transcript/webpack/runtime/compat get default export","webpack://teams-transcript/webpack/runtime/define property getters","webpack://teams-transcript/webpack/runtime/global","webpack://teams-transcript/webpack/runtime/hasOwnProperty shorthand","webpack://teams-transcript/webpack/runtime/make namespace object","webpack://teams-transcript/webpack/runtime/node module decorator","webpack://teams-transcript/webpack/before-startup","webpack://teams-transcript/webpack/startup","webpack://teams-transcript/webpack/after-startup"],"sourcesContent":["/** @flow **//*!\nbetajs-scoped - v0.0.22 - 2019-10-23\nCopyright (c) Oliver Friedmann\nApache-2.0 Software License.\n*/\nvar Scoped = (function () {\nvar Globals = (function () {  \n/** \n * This helper module provides functions for reading and writing globally accessible namespaces, both in the browser and in NodeJS.\n * \n * @module Globals\n * @access private\n */\nreturn {\n\t\t\n\t/**\n\t * Returns the value of a global variable.\n\t * \n\t * @param {string} key identifier of a global variable\n\t * @return value of global variable or undefined if not existing\n\t */\n\tget : function(key/* : string */) {\n\t\tif (typeof window !== \"undefined\")\n\t\t\treturn key ? window[key] : window;\n\t\tif (typeof global !== \"undefined\")\n\t\t\treturn key ? global[key] : global;\n\t\tif (typeof self !== \"undefined\")\n\t\t\treturn key ? self[key] : self;\n\t\treturn undefined;\n\t},\n\n\t\n\t/**\n\t * Sets a global variable.\n\t * \n\t * @param {string} key identifier of a global variable\n\t * @param value value to be set\n\t * @return value that has been set\n\t */\n\tset : function(key/* : string */, value) {\n\t\tif (typeof window !== \"undefined\")\n\t\t\twindow[key] = value;\n\t\tif (typeof global !== \"undefined\")\n\t\t\tglobal[key] = value;\n\t\tif (typeof self !== \"undefined\")\n\t\t\tself[key] = value;\n\t\treturn value;\n\t},\n\t\n\t\n\t/**\n\t * Returns the value of a global variable under a namespaced path.\n\t * \n\t * @param {string} path namespaced path identifier of variable\n\t * @return value of global variable or undefined if not existing\n\t * \n\t * @example\n\t * // returns window.foo.bar / global.foo.bar \n\t * Globals.getPath(\"foo.bar\")\n\t */\n\tgetPath: function (path/* : string */) {\n\t\tif (!path)\n\t\t\treturn this.get();\n\t\tvar args = path.split(\".\");\n\t\tif (args.length == 1)\n\t\t\treturn this.get(path);\t\t\n\t\tvar current = this.get(args[0]);\n\t\tfor (var i = 1; i < args.length; ++i) {\n\t\t\tif (!current)\n\t\t\t\treturn current;\n\t\t\tcurrent = current[args[i]];\n\t\t}\n\t\treturn current;\n\t},\n\n\n\t/**\n\t * Sets a global variable under a namespaced path.\n\t * \n\t * @param {string} path namespaced path identifier of variable\n\t * @param value value to be set\n\t * @return value that has been set\n\t * \n\t * @example\n\t * // sets window.foo.bar / global.foo.bar \n\t * Globals.setPath(\"foo.bar\", 42);\n\t */\n\tsetPath: function (path/* : string */, value) {\n\t\tvar args = path.split(\".\");\n\t\tif (args.length == 1)\n\t\t\treturn this.set(path, value);\t\t\n\t\tvar current = this.get(args[0]) || this.set(args[0], {});\n\t\tfor (var i = 1; i < args.length - 1; ++i) {\n\t\t\tif (!(args[i] in current))\n\t\t\t\tcurrent[args[i]] = {};\n\t\t\tcurrent = current[args[i]];\n\t\t}\n\t\tcurrent[args[args.length - 1]] = value;\n\t\treturn value;\n\t}\n\t\n};}).call(this);\n/*::\ndeclare module Helper {\n\tdeclare function extend<A, B>(a: A, b: B): A & B;\n}\n*/\n\nvar Helper = (function () {  \n/** \n * This helper module provides auxiliary functions for the Scoped system.\n * \n * @module Helper\n * @access private\n */\nreturn { \n\t\t\n\t/**\n\t * Attached a context to a function.\n\t * \n\t * @param {object} obj context for the function\n\t * @param {function} func function\n\t * \n\t * @return function with attached context\n\t */\n\tmethod: function (obj, func) {\n\t\treturn function () {\n\t\t\treturn func.apply(obj, arguments);\n\t\t};\n\t},\n\n\t\n\t/**\n\t * Extend a base object with all attributes of a second object.\n\t * \n\t * @param {object} base base object\n\t * @param {object} overwrite second object\n\t * \n\t * @return {object} extended base object\n\t */\n\textend: function (base, overwrite) {\n\t\tbase = base || {};\n\t\toverwrite = overwrite || {};\n\t\tfor (var key in overwrite)\n\t\t\tbase[key] = overwrite[key];\n\t\treturn base;\n\t},\n\t\n\t\n\t/**\n\t * Returns the type of an object, particulary returning 'array' for arrays.\n\t * \n\t * @param obj object in question\n\t * \n\t * @return {string} type of object\n\t */\n\ttypeOf: function (obj) {\n\t\treturn Object.prototype.toString.call(obj) === '[object Array]' ? \"array\" : typeof obj;\n\t},\n\t\n\t\n\t/**\n\t * Returns whether an object is null, undefined, an empty array or an empty object.\n\t * \n\t * @param obj object in question\n\t * \n\t * @return true if object is empty\n\t */\n\tisEmpty: function (obj) {\n\t\tif (obj === null || typeof obj === \"undefined\")\n\t\t\treturn true;\n\t\tif (this.typeOf(obj) == \"array\")\n\t\t\treturn obj.length === 0;\n\t\tif (typeof obj !== \"object\")\n\t\t\treturn false;\n\t\tfor (var key in obj)\n\t\t\treturn false;\n\t\treturn true;\n\t},\n\t\n\t\n    /**\n     * Matches function arguments against some pattern.\n     * \n     * @param {array} args function arguments\n     * @param {object} pattern typed pattern\n     * \n     * @return {object} matched arguments as associative array \n     */\t\n\tmatchArgs: function (args, pattern) {\n\t\tvar i = 0;\n\t\tvar result = {};\n\t\tfor (var key in pattern) {\n\t\t\tif (pattern[key] === true || this.typeOf(args[i]) == pattern[key]) {\n\t\t\t\tresult[key] = args[i];\n\t\t\t\ti++;\n\t\t\t} else if (this.typeOf(args[i]) == \"undefined\")\n\t\t\t\ti++;\n\t\t}\n\t\treturn result;\n\t},\n\t\n\t\n\t/**\n\t * Stringifies a value as JSON and functions to string representations.\n\t * \n\t * @param value value to be stringified\n\t * \n\t * @return stringified value\n\t */\n\tstringify: function (value) {\n\t\tif (this.typeOf(value) == \"function\")\n\t\t\treturn \"\" + value;\n\t\treturn JSON.stringify(value);\n\t}\t\n\n\t\n};}).call(this);\nvar Attach = (function () {  \n/** \n * This module provides functionality to attach the Scoped system to the environment.\n * \n * @module Attach\n * @access private\n */\nreturn { \n\t\t\n\t__namespace: \"Scoped\",\n\t__revert: null,\n\t\n\t\n\t/**\n\t * Upgrades a pre-existing Scoped system to the newest version present. \n\t * \n\t * @param {string} namespace Optional namespace (default is 'Scoped')\n\t * @return {object} the attached Scoped system\n\t */\n\tupgrade: function (namespace/* : ?string */) {\n\t\tvar current = Globals.get(namespace || Attach.__namespace);\n\t\tif (current && Helper.typeOf(current) === \"object\" && current.guid === this.guid && Helper.typeOf(current.version) === \"string\") {\n\t\t\tif (this.upgradable === false || current.upgradable === false)\n\t\t\t\treturn current;\n\t\t\tvar my_version = this.version.split(\".\");\n\t\t\tvar current_version = current.version.split(\".\");\n\t\t\tvar newer = false;\n\t\t\tfor (var i = 0; i < Math.min(my_version.length, current_version.length); ++i) {\n\t\t\t\tnewer = parseInt(my_version[i], 10) > parseInt(current_version[i], 10);\n\t\t\t\tif (my_version[i] !== current_version[i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn newer ? this.attach(namespace) : current;\t\t\t\t\n\t\t} else\n\t\t\treturn this.attach(namespace);\t\t\n\t},\n\n\n\t/**\n\t * Attaches the Scoped system to the environment. \n\t * \n\t * @param {string} namespace Optional namespace (default is 'Scoped')\n\t * @return {object} the attached Scoped system\n\t */\n\tattach : function(namespace/* : ?string */) {\n\t\tif (namespace)\n\t\t\tAttach.__namespace = namespace;\n\t\tvar current = Globals.get(Attach.__namespace);\n\t\tif (current === this)\n\t\t\treturn this;\n\t\tAttach.__revert = current;\n\t\tif (current) {\n\t\t\ttry {\n\t\t\t\tvar exported = current.__exportScoped();\n\t\t\t\tthis.__exportBackup = this.__exportScoped();\n\t\t\t\tthis.__importScoped(exported);\n\t\t\t} catch (e) {\n\t\t\t\t// We cannot upgrade the old version.\n\t\t\t}\n\t\t}\n\t\tGlobals.set(Attach.__namespace, this);\n\t\treturn this;\n\t},\n\t\n\n\t/**\n\t * Detaches the Scoped system from the environment. \n\t * \n\t * @param {boolean} forceDetach Overwrite any attached scoped system by null.\n\t * @return {object} the detached Scoped system\n\t */\n\tdetach: function (forceDetach/* : ?boolean */) {\n\t\tif (forceDetach)\n\t\t\tGlobals.set(Attach.__namespace, null);\n\t\tif (typeof Attach.__revert != \"undefined\")\n\t\t\tGlobals.set(Attach.__namespace, Attach.__revert);\n\t\tdelete Attach.__revert;\n\t\tif (Attach.__exportBackup)\n\t\t\tthis.__importScoped(Attach.__exportBackup);\n\t\treturn this;\n\t},\n\t\n\n\t/**\n\t * Exports an object as a module if possible. \n\t * \n\t * @param {object} mod a module object (optional, default is 'module')\n\t * @param {object} object the object to be exported\n\t * @param {boolean} forceExport overwrite potentially pre-existing exports\n\t * @return {object} the Scoped system\n\t */\n\texports: function (mod, object, forceExport) {\n\t\tmod = mod || (typeof module != \"undefined\" ? module : null);\n\t\tif (typeof mod == \"object\" && mod && \"exports\" in mod && (forceExport || mod.exports === this || !mod.exports || Helper.isEmpty(mod.exports)))\n\t\t\tmod.exports = object || this;\n\t\treturn this;\n\t}\t\n\n};}).call(this);\n\nfunction newNamespace (opts/* : {tree ?: boolean, global ?: boolean, root ?: Object} */) {\n\n\tvar options/* : {\n\t\ttree: boolean,\n\t    global: boolean,\n\t    root: Object\n\t} */ = {\n\t\ttree: typeof opts.tree === \"boolean\" ? opts.tree : false,\n\t\tglobal: typeof opts.global === \"boolean\" ? opts.global : false,\n\t\troot: typeof opts.root === \"object\" ? opts.root : {}\n\t};\n\n\t/*::\n\ttype Node = {\n\t\troute: ?string,\n\t\tparent: ?Node,\n\t\tchildren: any,\n\t\twatchers: any,\n\t\tdata: any,\n\t\tready: boolean,\n\t\tlazy: any\n\t};\n\t*/\n\n\tfunction initNode(options)/* : Node */ {\n\t\treturn {\n\t\t\troute: typeof options.route === \"string\" ? options.route : null,\n\t\t\tparent: typeof options.parent === \"object\" ? options.parent : null,\n\t\t\tready: typeof options.ready === \"boolean\" ? options.ready : false,\n\t\t\tchildren: {},\n\t\t\twatchers: [],\n\t\t\tdata: {},\n\t\t\tlazy: []\n\t\t};\n\t}\n\t\n\tvar nsRoot = initNode({ready: true});\n\t\n\tif (options.tree) {\n\t\tif (options.global) {\n\t\t\ttry {\n\t\t\t\tif (window)\n\t\t\t\t\tnsRoot.data = window;\n\t\t\t} catch (e) { }\n\t\t\ttry {\n\t\t\t\tif (global)\n\t\t\t\t\tnsRoot.data = global;\n\t\t\t} catch (e) { }\n\t\t\ttry {\n\t\t\t\tif (self)\n\t\t\t\t\tnsRoot.data = self;\n\t\t\t} catch (e) { }\n\t\t} else\n\t\t\tnsRoot.data = options.root;\n\t}\n\t\n\tfunction nodeDigest(node/* : Node */) {\n\t\tif (node.ready)\n\t\t\treturn;\n\t\tif (node.parent && !node.parent.ready) {\n\t\t\tnodeDigest(node.parent);\n\t\t\treturn;\n\t\t}\n\t\tif (node.route && node.parent && (node.route in node.parent.data)) {\n\t\t\tnode.data = node.parent.data[node.route];\n\t\t\tnode.ready = true;\n\t\t\tfor (var i = 0; i < node.watchers.length; ++i)\n\t\t\t\tnode.watchers[i].callback.call(node.watchers[i].context || this, node.data);\n\t\t\tnode.watchers = [];\n\t\t\tfor (var key in node.children)\n\t\t\t\tnodeDigest(node.children[key]);\n\t\t}\n\t}\n\t\n\tfunction nodeEnforce(node/* : Node */) {\n\t\tif (node.ready)\n\t\t\treturn;\n\t\tif (node.parent && !node.parent.ready)\n\t\t\tnodeEnforce(node.parent);\n\t\tnode.ready = true;\n\t\tif (node.parent) {\n\t\t\tif (options.tree && typeof node.parent.data == \"object\")\n\t\t\t\tnode.parent.data[node.route] = node.data;\n\t\t}\n\t\tfor (var i = 0; i < node.watchers.length; ++i)\n\t\t\tnode.watchers[i].callback.call(node.watchers[i].context || this, node.data);\n\t\tnode.watchers = [];\n\t}\n\t\n\tfunction nodeSetData(node/* : Node */, value) {\n\t\tif (typeof value == \"object\" && node.ready) {\n\t\t\tfor (var key in value)\n\t\t\t\tnode.data[key] = value[key];\n\t\t} else\n\t\t\tnode.data = value;\n\t\tif (typeof value == \"object\") {\n\t\t\tfor (var ckey in value) {\n\t\t\t\tif (node.children[ckey])\n\t\t\t\t\tnode.children[ckey].data = value[ckey];\n\t\t\t}\n\t\t}\n\t\tnodeEnforce(node);\n\t\tfor (var k in node.children)\n\t\t\tnodeDigest(node.children[k]);\n\t}\n\t\n\tfunction nodeClearData(node/* : Node */) {\n\t\tif (node.ready && node.data) {\n\t\t\tfor (var key in node.data)\n\t\t\t\tdelete node.data[key];\n\t\t}\n\t}\n\t\n\tfunction nodeNavigate(path/* : ?String */) {\n\t\tif (!path)\n\t\t\treturn nsRoot;\n\t\tvar routes = path.split(\".\");\n\t\tvar current = nsRoot;\n\t\tfor (var i = 0; i < routes.length; ++i) {\n\t\t\tif (routes[i] in current.children)\n\t\t\t\tcurrent = current.children[routes[i]];\n\t\t\telse {\n\t\t\t\tcurrent.children[routes[i]] = initNode({\n\t\t\t\t\tparent: current,\n\t\t\t\t\troute: routes[i]\n\t\t\t\t});\n\t\t\t\tcurrent = current.children[routes[i]];\n\t\t\t\tnodeDigest(current);\n\t\t\t}\n\t\t}\n\t\treturn current;\n\t}\n\t\n\tfunction nodeAddWatcher(node/* : Node */, callback, context) {\n\t\tif (node.ready)\n\t\t\tcallback.call(context || this, node.data);\n\t\telse {\n\t\t\tnode.watchers.push({\n\t\t\t\tcallback: callback,\n\t\t\t\tcontext: context\n\t\t\t});\n\t\t\tif (node.lazy.length > 0) {\n\t\t\t\tvar f = function (node) {\n\t\t\t\t\tif (node.lazy.length > 0) {\n\t\t\t\t\t\tvar lazy = node.lazy.shift();\n\t\t\t\t\t\tlazy.callback.call(lazy.context || this, node.data);\n\t\t\t\t\t\tf(node);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tf(node);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction nodeUnresolvedWatchers(node/* : Node */, base, result) {\n\t\tnode = node || nsRoot;\n\t\tresult = result || [];\n\t\tif (!node.ready && node.lazy.length === 0 && node.watchers.length > 0)\n\t\t\tresult.push(base);\n\t\tfor (var k in node.children) {\n\t\t\tvar c = node.children[k];\n\t\t\tvar r = (base ? base + \".\" : \"\") + c.route;\n\t\t\tresult = nodeUnresolvedWatchers(c, r, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/** \n\t * The namespace module manages a namespace in the Scoped system.\n\t * \n\t * @module Namespace\n\t * @access public\n\t */\n\treturn {\n\t\t\n\t\t/**\n\t\t * Extend a node in the namespace by an object.\n\t\t * \n\t\t * @param {string} path path to the node in the namespace\n\t\t * @param {object} value object that should be used for extend the namespace node\n\t\t */\n\t\textend: function (path, value) {\n\t\t\tnodeSetData(nodeNavigate(path), value);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Set the object value of a node in the namespace.\n\t\t * \n\t\t * @param {string} path path to the node in the namespace\n\t\t * @param {object} value object that should be used as value for the namespace node\n\t\t */\n\t\tset: function (path, value) {\n\t\t\tvar node = nodeNavigate(path);\n\t\t\tif (node.data)\n\t\t\t\tnodeClearData(node);\n\t\t\tnodeSetData(node, value);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Read the object value of a node in the namespace.\n\t\t * \n\t\t * @param {string} path path to the node in the namespace\n\t\t * @return {object} object value of the node or null if undefined\n\t\t */\n\t\tget: function (path) {\n\t\t\tvar node = nodeNavigate(path);\n\t\t\treturn node.ready ? node.data : null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Lazily navigate to a node in the namespace.\n\t\t * Will asynchronously call the callback as soon as the node is being touched.\n\t\t *\n\t\t * @param {string} path path to the node in the namespace\n\t\t * @param {function} callback callback function accepting the node's object value\n\t\t * @param {context} context optional callback context\n\t\t */\n\t\tlazy: function (path, callback, context) {\n\t\t\tvar node = nodeNavigate(path);\n\t\t\tif (node.ready)\n\t\t\t\tcallback(context || this, node.data);\n\t\t\telse {\n\t\t\t\tnode.lazy.push({\n\t\t\t\t\tcallback: callback,\n\t\t\t\t\tcontext: context\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Digest a node path, checking whether it has been defined by an external system.\n\t\t * \n\t\t * @param {string} path path to the node in the namespace\n\t\t */\n\t\tdigest: function (path) {\n\t\t\tnodeDigest(nodeNavigate(path));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Asynchronously access a node in the namespace.\n\t\t * Will asynchronously call the callback as soon as the node is being defined.\n\t\t *\n\t\t * @param {string} path path to the node in the namespace\n\t\t * @param {function} callback callback function accepting the node's object value\n\t\t * @param {context} context optional callback context\n\t\t */\n\t\tobtain: function (path, callback, context) {\n\t\t\tnodeAddWatcher(nodeNavigate(path), callback, context);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all unresolved watchers under a certain path.\n\t\t * \n\t\t * @param {string} path path to the node in the namespace\n\t\t * @return {array} list of all unresolved watchers \n\t\t */\n\t\tunresolvedWatchers: function (path) {\n\t\t\treturn nodeUnresolvedWatchers(nodeNavigate(path), path);\n\t\t},\n\t\t\n\t\t__export: function () {\n\t\t\treturn {\n\t\t\t\toptions: options,\n\t\t\t\tnsRoot: nsRoot\n\t\t\t};\n\t\t},\n\t\t\n\t\t__import: function (data) {\n\t\t\toptions = data.options;\n\t\t\tnsRoot = data.nsRoot;\n\t\t}\n\t\t\n\t};\n\t\n}\nfunction newScope (parent, parentNS, rootNS, globalNS) {\n\t\n\tvar self = this;\n\tvar nextScope = null;\n\tvar childScopes = [];\n\tvar parentNamespace = parentNS;\n\tvar rootNamespace = rootNS;\n\tvar globalNamespace = globalNS;\n\tvar localNamespace = newNamespace({tree: true});\n\tvar privateNamespace = newNamespace({tree: false});\n\t\n\tvar bindings = {\n\t\t\"global\": {\n\t\t\tnamespace: globalNamespace\n\t\t}, \"root\": {\n\t\t\tnamespace: rootNamespace\n\t\t}, \"local\": {\n\t\t\tnamespace: localNamespace\n\t\t}, \"default\": {\n\t\t\tnamespace: privateNamespace\n\t\t}, \"parent\": {\n\t\t\tnamespace: parentNamespace\n\t\t}, \"scope\": {\n\t\t\tnamespace: localNamespace,\n\t\t\treadonly: false\n\t\t}\n\t};\n\t\n\tvar custom = function (argmts, name, callback) {\n\t\tvar args = Helper.matchArgs(argmts, {\n\t\t\toptions: \"object\",\n\t\t\tnamespaceLocator: true,\n\t\t\tdependencies: \"array\",\n\t\t\thiddenDependencies: \"array\",\n\t\t\tcallback: true,\n\t\t\tcontext: \"object\"\n\t\t});\n\t\t\n\t\tvar options = Helper.extend({\n\t\t\tlazy: this.options.lazy\n\t\t}, args.options || {});\n\t\t\n\t\tvar ns = this.resolve(args.namespaceLocator);\n\t\t\n\t\tvar execute = function () {\n\t\t\tthis.require(args.dependencies, args.hiddenDependencies, function () {\n                var _arguments = [];\n                for (var a = 0; a < arguments.length; ++a)\n                    _arguments.push(arguments[a]);\n                _arguments[_arguments.length - 1].ns = ns;\n\t\t\t\tif (this.options.compile) {\n\t\t\t\t\tvar params = [];\n\t\t\t\t\tfor (var i = 0; i < argmts.length; ++i)\n\t\t\t\t\t\tparams.push(Helper.stringify(argmts[i]));\n\t\t\t\t\tthis.compiled += this.options.ident + \".\" + name + \"(\" + params.join(\", \") + \");\\n\\n\";\n\t\t\t\t}\n\t\t\t\tif (this.options.dependencies) {\n\t\t\t\t\tthis.dependencies[ns.path] = this.dependencies[ns.path] || {};\n\t\t\t\t\tif (args.dependencies) {\n\t\t\t\t\t\targs.dependencies.forEach(function (dep) {\n\t\t\t\t\t\t\tthis.dependencies[ns.path][this.resolve(dep).path] = true;\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}\n\t\t\t\t\tif (args.hiddenDependencies) {\n\t\t\t\t\t\targs.hiddenDependencies.forEach(function (dep) {\n\t\t\t\t\t\t\tthis.dependencies[ns.path][this.resolve(dep).path] = true;\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar result = this.options.compile ? {} : args.callback.apply(args.context || this, _arguments);\n\t\t\t\tcallback.call(this, ns, result);\n\t\t\t}, this);\n\t\t};\n\t\t\n\t\tif (options.lazy)\n\t\t\tns.namespace.lazy(ns.path, execute, this);\n\t\telse\n\t\t\texecute.apply(this);\n\n\t\treturn this;\n\t};\n\t\n\t/** \n\t * This module provides all functionality in a scope.\n\t * \n\t * @module Scoped\n\t * @access public\n\t */\n\treturn {\n\t\t\n\t\tgetGlobal: Helper.method(Globals, Globals.getPath),\n\t\tsetGlobal: Helper.method(Globals, Globals.setPath),\n\t\t\n\t\toptions: {\n\t\t\tlazy: false,\n\t\t\tident: \"Scoped\",\n\t\t\tcompile: false,\n\t\t\tdependencies: false\n\t\t},\n\t\t\n\t\tcompiled: \"\",\n\t\t\n\t\tdependencies: {},\n\t\t\n\t\t\n\t\t/**\n\t\t * Returns a reference to the next scope that will be obtained by a subScope call.\n\t\t * \n\t\t * @return {object} next scope\n\t\t */\n\t\tnextScope: function () {\n\t\t\tif (!nextScope)\n\t\t\t\tnextScope = newScope(this, localNamespace, rootNamespace, globalNamespace);\n\t\t\treturn nextScope;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates a sub scope of the current scope and returns it.\n\t\t * \n\t\t * @return {object} sub scope\n\t\t */\n\t\tsubScope: function () {\n\t\t\tvar sub = this.nextScope();\n\t\t\tchildScopes.push(sub);\n\t\t\tnextScope = null;\n\t\t\treturn sub;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates a binding within in the scope. \n\t\t * \n\t\t * @param {string} alias identifier of the new binding\n\t\t * @param {string} namespaceLocator identifier of an existing namespace path\n\t\t * @param {object} options options for the binding\n\t\t * \n\t\t */\n\t\tbinding: function (alias, namespaceLocator, options) {\n\t\t\tif (!bindings[alias] || !bindings[alias].readonly) {\n\t\t\t\tvar ns;\n\t\t\t\tif (Helper.typeOf(namespaceLocator) != \"string\") {\n\t\t\t\t\tns = {\n\t\t\t\t\t\tnamespace: newNamespace({\n\t\t\t\t\t\t\ttree: true,\n\t\t\t\t\t\t\troot: namespaceLocator\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tpath: null\t\n\t\t\t\t\t};\n\t\t\t\t} else\n\t\t\t\t\tns = this.resolve(namespaceLocator);\n\t\t\t\tbindings[alias] = Helper.extend(options, ns);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t\n\t\t/**\n\t\t * Resolves a name space locator to a name space.\n\t\t * \n\t\t * @param {string} namespaceLocator name space locator\n\t\t * @return {object} resolved name space\n\t\t * \n\t\t */\n\t\tresolve: function (namespaceLocator) {\n\t\t\tvar parts = namespaceLocator.split(\":\");\n\t\t\tif (parts.length == 1) {\n                throw (\"The locator '\" + parts[0] + \"' requires a namespace.\");\n\t\t\t} else {\n\t\t\t\tvar binding = bindings[parts[0]];\n\t\t\t\tif (!binding)\n\t\t\t\t\tthrow (\"The namespace '\" + parts[0] + \"' has not been defined (yet).\");\n\t\t\t\treturn {\n\t\t\t\t\tnamespace: binding.namespace,\n\t\t\t\t\tpath : binding.path && parts[1] ? binding.path + \".\" + parts[1] : (binding.path || parts[1])\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\t\n\t\t/**\n\t\t * Defines a new name space once a list of name space locators is available.\n\t\t * \n\t\t * @param {string} namespaceLocator the name space that is to be defined\n\t\t * @param {array} dependencies a list of name space locator dependencies (optional)\n\t\t * @param {array} hiddenDependencies a list of hidden name space locators (optional)\n\t\t * @param {function} callback a callback function accepting all dependencies as arguments and returning the new definition\n\t\t * @param {object} context a callback context (optional)\n\t\t * \n\t\t */\n\t\tdefine: function () {\n\t\t\treturn custom.call(this, arguments, \"define\", function (ns, result) {\n\t\t\t\tif (ns.namespace.get(ns.path))\n\t\t\t\t\tthrow (\"Scoped namespace \" + ns.path + \" has already been defined. Use extend to extend an existing namespace instead\");\n\t\t\t\tns.namespace.set(ns.path, result);\n\t\t\t});\n\t\t},\n\t\t\n\t\t\n\t\t/**\n\t\t * Assume a specific version of a module and fail if it is not met.\n\t\t * \n\t\t * @param {string} assumption name space locator\n\t\t * @param {string} version assumed version\n\t\t * \n\t\t */\n\t\tassumeVersion: function () {\n\t\t\tvar args = Helper.matchArgs(arguments, {\n\t\t\t\tassumption: true,\n\t\t\t\tdependencies: \"array\",\n\t\t\t\tcallback: true,\n\t\t\t\tcontext: \"object\",\n\t\t\t\terror: \"string\"\n\t\t\t});\n\t\t\tvar dependencies = args.dependencies || [];\n\t\t\tdependencies.unshift(args.assumption);\n\t\t\tthis.require(dependencies, function () {\n\t\t\t\tvar argv = arguments;\n\t\t\t\tvar assumptionValue = argv[0].replace(/[^\\d\\.]/g, \"\");\n\t\t\t\targv[0] = assumptionValue.split(\".\");\n\t\t\t\tfor (var i = 0; i < argv[0].length; ++i)\n\t\t\t\t\targv[0][i] = parseInt(argv[0][i], 10);\n\t\t\t\tif (Helper.typeOf(args.callback) === \"function\") {\n\t\t\t\t\tif (!args.callback.apply(args.context || this, args))\n\t\t\t\t\t\tthrow (\"Scoped Assumption '\" + args.assumption + \"' failed, value is \" + assumptionValue + (args.error ? \", but assuming \" + args.error : \"\"));\n\t\t\t\t} else {\n\t\t\t\t\tvar version = (args.callback + \"\").replace(/[^\\d\\.]/g, \"\").split(\".\");\n\t\t\t\t\tfor (var j = 0; j < Math.min(argv[0].length, version.length); ++j)\n\t\t\t\t\t\tif (parseInt(version[j], 10) > argv[0][j])\n\t\t\t\t\t\t\tthrow (\"Scoped Version Assumption '\" + args.assumption + \"' failed, value is \" + assumptionValue + \", but assuming at least \" + args.callback);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t\n\t\t/**\n\t\t * Extends a potentially existing name space once a list of name space locators is available.\n\t\t * \n\t\t * @param {string} namespaceLocator the name space that is to be defined\n\t\t * @param {array} dependencies a list of name space locator dependencies (optional)\n\t\t * @param {array} hiddenDependencies a list of hidden name space locators (optional)\n\t\t * @param {function} callback a callback function accepting all dependencies as arguments and returning the new additional definitions.\n\t\t * @param {object} context a callback context (optional)\n\t\t * \n\t\t */\n\t\textend: function () {\n\t\t\treturn custom.call(this, arguments, \"extend\", function (ns, result) {\n\t\t\t\tns.namespace.extend(ns.path, result);\n\t\t\t});\n\t\t},\n\t\t\t\t\n\t\t\n\t\t/**\n\t\t * Requires a list of name space locators and calls a function once they are present.\n\t\t * \n\t\t * @param {array} dependencies a list of name space locator dependencies (optional)\n\t\t * @param {array} hiddenDependencies a list of hidden name space locators (optional)\n\t\t * @param {function} callback a callback function accepting all dependencies as arguments\n\t\t * @param {object} context a callback context (optional)\n\t\t * \n\t\t */\n\t\trequire: function () {\n\t\t\tvar args = Helper.matchArgs(arguments, {\n\t\t\t\tdependencies: \"array\",\n\t\t\t\thiddenDependencies: \"array\",\n\t\t\t\tcallback: \"function\",\n\t\t\t\tcontext: \"object\"\n\t\t\t});\n\t\t\targs.callback = args.callback || function () {};\n\t\t\tvar dependencies = args.dependencies || [];\n\t\t\tvar allDependencies = dependencies.concat(args.hiddenDependencies || []);\n\t\t\tvar count = allDependencies.length;\n\t\t\tvar deps = [];\n\t\t\tvar environment = {};\n\t\t\tif (count) {\n\t\t\t\tvar f = function (value) {\n\t\t\t\t\tif (this.i < deps.length)\n\t\t\t\t\t\tdeps[this.i] = value;\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\tdeps.push(environment);\n\t\t\t\t\t\targs.callback.apply(args.context || this.ctx, deps);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (var i = 0; i < allDependencies.length; ++i) {\n\t\t\t\t\tvar ns = this.resolve(allDependencies[i]);\n\t\t\t\t\tif (i < dependencies.length)\n\t\t\t\t\t\tdeps.push(null);\n\t\t\t\t\tns.namespace.obtain(ns.path, f, {\n\t\t\t\t\t\tctx: this,\n\t\t\t\t\t\ti: i\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdeps.push(environment);\n\t\t\t\targs.callback.apply(args.context || this, deps);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t\n\t\t/**\n\t\t * Digest a name space locator, checking whether it has been defined by an external system.\n\t\t * \n\t\t * @param {string} namespaceLocator name space locator\n\t\t */\n\t\tdigest: function (namespaceLocator) {\n\t\t\tvar ns = this.resolve(namespaceLocator);\n\t\t\tns.namespace.digest(ns.path);\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t\n\t\t/**\n\t\t * Returns all unresolved definitions under a namespace locator\n\t\t * \n\t\t * @param {string} namespaceLocator name space locator, e.g. \"global:\"\n\t\t * @return {array} list of all unresolved definitions \n\t\t */\n\t\tunresolved: function (namespaceLocator) {\n\t\t\tvar ns = this.resolve(namespaceLocator);\n\t\t\treturn ns.namespace.unresolvedWatchers(ns.path);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Exports the scope.\n\t\t * \n\t\t * @return {object} exported scope\n\t\t */\n\t\t__export: function () {\n\t\t\treturn {\n\t\t\t\tparentNamespace: parentNamespace.__export(),\n\t\t\t\trootNamespace: rootNamespace.__export(),\n\t\t\t\tglobalNamespace: globalNamespace.__export(),\n\t\t\t\tlocalNamespace: localNamespace.__export(),\n\t\t\t\tprivateNamespace: privateNamespace.__export()\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Imports a scope from an exported scope.\n\t\t * \n\t\t * @param {object} data exported scope to be imported\n\t\t * \n\t\t */\n\t\t__import: function (data) {\n\t\t\tparentNamespace.__import(data.parentNamespace);\n\t\t\trootNamespace.__import(data.rootNamespace);\n\t\t\tglobalNamespace.__import(data.globalNamespace);\n\t\t\tlocalNamespace.__import(data.localNamespace);\n\t\t\tprivateNamespace.__import(data.privateNamespace);\n\t\t}\n\t\t\n\t};\n\t\n}\nvar globalNamespace = newNamespace({tree: true, global: true});\nvar rootNamespace = newNamespace({tree: true});\nvar rootScope = newScope(null, rootNamespace, rootNamespace, globalNamespace);\n\nvar Public = Helper.extend(rootScope, (function () {  \n/** \n * This module includes all public functions of the Scoped system.\n * \n * It includes all methods of the root scope and the Attach module.\n * \n * @module Public\n * @access public\n */\nreturn {\n\t\t\n\tguid: \"4b6878ee-cb6a-46b3-94ac-27d91f58d666\",\n\tversion: '0.0.22',\n\n\tupgradable: true,\n\t\t\n\tupgrade: Attach.upgrade,\n\tattach: Attach.attach,\n\tdetach: Attach.detach,\n\texports: Attach.exports,\n\t\n\t/**\n\t * Exports all data contained in the Scoped system.\n\t * \n\t * @return data of the Scoped system.\n\t * @access private\n\t */\n\t__exportScoped: function () {\n\t\treturn {\n\t\t\tglobalNamespace: globalNamespace.__export(),\n\t\t\trootNamespace: rootNamespace.__export(),\n\t\t\trootScope: rootScope.__export()\n\t\t};\n\t},\n\t\n\t/**\n\t * Import data into the Scoped system.\n\t * \n\t * @param data of the Scoped system.\n\t * @access private\n\t */\n\t__importScoped: function (data) {\n\t\tglobalNamespace.__import(data.globalNamespace);\n\t\trootNamespace.__import(data.rootNamespace);\n\t\trootScope.__import(data.rootScope);\n\t}\n\t\n};\n\n}).call(this));\n\nPublic = Public.upgrade();\nPublic.exports();\n\treturn Public;\n}).call(this);","/*!\nbetajs - v1.0.245 - 2023-12-04\nCopyright (c) Oliver Friedmann,Victor Lingenthal\nApache-2.0 Software License.\n*/\n/** @flow **//*!\nbetajs-scoped - v0.0.22 - 2019-10-23\nCopyright (c) Oliver Friedmann\nApache-2.0 Software License.\n*/\nvar Scoped = (function () {\nvar Globals = (function () {  \n/** \n * This helper module provides functions for reading and writing globally accessible namespaces, both in the browser and in NodeJS.\n * \n * @module Globals\n * @access private\n */\nreturn {\n\t\t\n\t/**\n\t * Returns the value of a global variable.\n\t * \n\t * @param {string} key identifier of a global variable\n\t * @return value of global variable or undefined if not existing\n\t */\n\tget : function(key/* : string */) {\n\t\tif (typeof window !== \"undefined\")\n\t\t\treturn key ? window[key] : window;\n\t\tif (typeof global !== \"undefined\")\n\t\t\treturn key ? global[key] : global;\n\t\tif (typeof self !== \"undefined\")\n\t\t\treturn key ? self[key] : self;\n\t\treturn undefined;\n\t},\n\n\t\n\t/**\n\t * Sets a global variable.\n\t * \n\t * @param {string} key identifier of a global variable\n\t * @param value value to be set\n\t * @return value that has been set\n\t */\n\tset : function(key/* : string */, value) {\n\t\tif (typeof window !== \"undefined\")\n\t\t\twindow[key] = value;\n\t\tif (typeof global !== \"undefined\")\n\t\t\tglobal[key] = value;\n\t\tif (typeof self !== \"undefined\")\n\t\t\tself[key] = value;\n\t\treturn value;\n\t},\n\t\n\t\n\t/**\n\t * Returns the value of a global variable under a namespaced path.\n\t * \n\t * @param {string} path namespaced path identifier of variable\n\t * @return value of global variable or undefined if not existing\n\t * \n\t * @example\n\t * // returns window.foo.bar / global.foo.bar \n\t * Globals.getPath(\"foo.bar\")\n\t */\n\tgetPath: function (path/* : string */) {\n\t\tif (!path)\n\t\t\treturn this.get();\n\t\tvar args = path.split(\".\");\n\t\tif (args.length == 1)\n\t\t\treturn this.get(path);\t\t\n\t\tvar current = this.get(args[0]);\n\t\tfor (var i = 1; i < args.length; ++i) {\n\t\t\tif (!current)\n\t\t\t\treturn current;\n\t\t\tcurrent = current[args[i]];\n\t\t}\n\t\treturn current;\n\t},\n\n\n\t/**\n\t * Sets a global variable under a namespaced path.\n\t * \n\t * @param {string} path namespaced path identifier of variable\n\t * @param value value to be set\n\t * @return value that has been set\n\t * \n\t * @example\n\t * // sets window.foo.bar / global.foo.bar \n\t * Globals.setPath(\"foo.bar\", 42);\n\t */\n\tsetPath: function (path/* : string */, value) {\n\t\tvar args = path.split(\".\");\n\t\tif (args.length == 1)\n\t\t\treturn this.set(path, value);\t\t\n\t\tvar current = this.get(args[0]) || this.set(args[0], {});\n\t\tfor (var i = 1; i < args.length - 1; ++i) {\n\t\t\tif (!(args[i] in current))\n\t\t\t\tcurrent[args[i]] = {};\n\t\t\tcurrent = current[args[i]];\n\t\t}\n\t\tcurrent[args[args.length - 1]] = value;\n\t\treturn value;\n\t}\n\t\n};}).call(this);\n/*::\ndeclare module Helper {\n\tdeclare function extend<A, B>(a: A, b: B): A & B;\n}\n*/\n\nvar Helper = (function () {  \n/** \n * This helper module provides auxiliary functions for the Scoped system.\n * \n * @module Helper\n * @access private\n */\nreturn { \n\t\t\n\t/**\n\t * Attached a context to a function.\n\t * \n\t * @param {object} obj context for the function\n\t * @param {function} func function\n\t * \n\t * @return function with attached context\n\t */\n\tmethod: function (obj, func) {\n\t\treturn function () {\n\t\t\treturn func.apply(obj, arguments);\n\t\t};\n\t},\n\n\t\n\t/**\n\t * Extend a base object with all attributes of a second object.\n\t * \n\t * @param {object} base base object\n\t * @param {object} overwrite second object\n\t * \n\t * @return {object} extended base object\n\t */\n\textend: function (base, overwrite) {\n\t\tbase = base || {};\n\t\toverwrite = overwrite || {};\n\t\tfor (var key in overwrite)\n\t\t\tbase[key] = overwrite[key];\n\t\treturn base;\n\t},\n\t\n\t\n\t/**\n\t * Returns the type of an object, particulary returning 'array' for arrays.\n\t * \n\t * @param obj object in question\n\t * \n\t * @return {string} type of object\n\t */\n\ttypeOf: function (obj) {\n\t\treturn Object.prototype.toString.call(obj) === '[object Array]' ? \"array\" : typeof obj;\n\t},\n\t\n\t\n\t/**\n\t * Returns whether an object is null, undefined, an empty array or an empty object.\n\t * \n\t * @param obj object in question\n\t * \n\t * @return true if object is empty\n\t */\n\tisEmpty: function (obj) {\n\t\tif (obj === null || typeof obj === \"undefined\")\n\t\t\treturn true;\n\t\tif (this.typeOf(obj) == \"array\")\n\t\t\treturn obj.length === 0;\n\t\tif (typeof obj !== \"object\")\n\t\t\treturn false;\n\t\tfor (var key in obj)\n\t\t\treturn false;\n\t\treturn true;\n\t},\n\t\n\t\n    /**\n     * Matches function arguments against some pattern.\n     * \n     * @param {array} args function arguments\n     * @param {object} pattern typed pattern\n     * \n     * @return {object} matched arguments as associative array \n     */\t\n\tmatchArgs: function (args, pattern) {\n\t\tvar i = 0;\n\t\tvar result = {};\n\t\tfor (var key in pattern) {\n\t\t\tif (pattern[key] === true || this.typeOf(args[i]) == pattern[key]) {\n\t\t\t\tresult[key] = args[i];\n\t\t\t\ti++;\n\t\t\t} else if (this.typeOf(args[i]) == \"undefined\")\n\t\t\t\ti++;\n\t\t}\n\t\treturn result;\n\t},\n\t\n\t\n\t/**\n\t * Stringifies a value as JSON and functions to string representations.\n\t * \n\t * @param value value to be stringified\n\t * \n\t * @return stringified value\n\t */\n\tstringify: function (value) {\n\t\tif (this.typeOf(value) == \"function\")\n\t\t\treturn \"\" + value;\n\t\treturn JSON.stringify(value);\n\t}\t\n\n\t\n};}).call(this);\nvar Attach = (function () {  \n/** \n * This module provides functionality to attach the Scoped system to the environment.\n * \n * @module Attach\n * @access private\n */\nreturn { \n\t\t\n\t__namespace: \"Scoped\",\n\t__revert: null,\n\t\n\t\n\t/**\n\t * Upgrades a pre-existing Scoped system to the newest version present. \n\t * \n\t * @param {string} namespace Optional namespace (default is 'Scoped')\n\t * @return {object} the attached Scoped system\n\t */\n\tupgrade: function (namespace/* : ?string */) {\n\t\tvar current = Globals.get(namespace || Attach.__namespace);\n\t\tif (current && Helper.typeOf(current) === \"object\" && current.guid === this.guid && Helper.typeOf(current.version) === \"string\") {\n\t\t\tif (this.upgradable === false || current.upgradable === false)\n\t\t\t\treturn current;\n\t\t\tvar my_version = this.version.split(\".\");\n\t\t\tvar current_version = current.version.split(\".\");\n\t\t\tvar newer = false;\n\t\t\tfor (var i = 0; i < Math.min(my_version.length, current_version.length); ++i) {\n\t\t\t\tnewer = parseInt(my_version[i], 10) > parseInt(current_version[i], 10);\n\t\t\t\tif (my_version[i] !== current_version[i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn newer ? this.attach(namespace) : current;\t\t\t\t\n\t\t} else\n\t\t\treturn this.attach(namespace);\t\t\n\t},\n\n\n\t/**\n\t * Attaches the Scoped system to the environment. \n\t * \n\t * @param {string} namespace Optional namespace (default is 'Scoped')\n\t * @return {object} the attached Scoped system\n\t */\n\tattach : function(namespace/* : ?string */) {\n\t\tif (namespace)\n\t\t\tAttach.__namespace = namespace;\n\t\tvar current = Globals.get(Attach.__namespace);\n\t\tif (current === this)\n\t\t\treturn this;\n\t\tAttach.__revert = current;\n\t\tif (current) {\n\t\t\ttry {\n\t\t\t\tvar exported = current.__exportScoped();\n\t\t\t\tthis.__exportBackup = this.__exportScoped();\n\t\t\t\tthis.__importScoped(exported);\n\t\t\t} catch (e) {\n\t\t\t\t// We cannot upgrade the old version.\n\t\t\t}\n\t\t}\n\t\tGlobals.set(Attach.__namespace, this);\n\t\treturn this;\n\t},\n\t\n\n\t/**\n\t * Detaches the Scoped system from the environment. \n\t * \n\t * @param {boolean} forceDetach Overwrite any attached scoped system by null.\n\t * @return {object} the detached Scoped system\n\t */\n\tdetach: function (forceDetach/* : ?boolean */) {\n\t\tif (forceDetach)\n\t\t\tGlobals.set(Attach.__namespace, null);\n\t\tif (typeof Attach.__revert != \"undefined\")\n\t\t\tGlobals.set(Attach.__namespace, Attach.__revert);\n\t\tdelete Attach.__revert;\n\t\tif (Attach.__exportBackup)\n\t\t\tthis.__importScoped(Attach.__exportBackup);\n\t\treturn this;\n\t},\n\t\n\n\t/**\n\t * Exports an object as a module if possible. \n\t * \n\t * @param {object} mod a module object (optional, default is 'module')\n\t * @param {object} object the object to be exported\n\t * @param {boolean} forceExport overwrite potentially pre-existing exports\n\t * @return {object} the Scoped system\n\t */\n\texports: function (mod, object, forceExport) {\n\t\tmod = mod || (typeof module != \"undefined\" ? module : null);\n\t\tif (typeof mod == \"object\" && mod && \"exports\" in mod && (forceExport || mod.exports === this || !mod.exports || Helper.isEmpty(mod.exports)))\n\t\t\tmod.exports = object || this;\n\t\treturn this;\n\t}\t\n\n};}).call(this);\n\nfunction newNamespace (opts/* : {tree ?: boolean, global ?: boolean, root ?: Object} */) {\n\n\tvar options/* : {\n\t\ttree: boolean,\n\t    global: boolean,\n\t    root: Object\n\t} */ = {\n\t\ttree: typeof opts.tree === \"boolean\" ? opts.tree : false,\n\t\tglobal: typeof opts.global === \"boolean\" ? opts.global : false,\n\t\troot: typeof opts.root === \"object\" ? opts.root : {}\n\t};\n\n\t/*::\n\ttype Node = {\n\t\troute: ?string,\n\t\tparent: ?Node,\n\t\tchildren: any,\n\t\twatchers: any,\n\t\tdata: any,\n\t\tready: boolean,\n\t\tlazy: any\n\t};\n\t*/\n\n\tfunction initNode(options)/* : Node */ {\n\t\treturn {\n\t\t\troute: typeof options.route === \"string\" ? options.route : null,\n\t\t\tparent: typeof options.parent === \"object\" ? options.parent : null,\n\t\t\tready: typeof options.ready === \"boolean\" ? options.ready : false,\n\t\t\tchildren: {},\n\t\t\twatchers: [],\n\t\t\tdata: {},\n\t\t\tlazy: []\n\t\t};\n\t}\n\t\n\tvar nsRoot = initNode({ready: true});\n\t\n\tif (options.tree) {\n\t\tif (options.global) {\n\t\t\ttry {\n\t\t\t\tif (window)\n\t\t\t\t\tnsRoot.data = window;\n\t\t\t} catch (e) { }\n\t\t\ttry {\n\t\t\t\tif (global)\n\t\t\t\t\tnsRoot.data = global;\n\t\t\t} catch (e) { }\n\t\t\ttry {\n\t\t\t\tif (self)\n\t\t\t\t\tnsRoot.data = self;\n\t\t\t} catch (e) { }\n\t\t} else\n\t\t\tnsRoot.data = options.root;\n\t}\n\t\n\tfunction nodeDigest(node/* : Node */) {\n\t\tif (node.ready)\n\t\t\treturn;\n\t\tif (node.parent && !node.parent.ready) {\n\t\t\tnodeDigest(node.parent);\n\t\t\treturn;\n\t\t}\n\t\tif (node.route && node.parent && (node.route in node.parent.data)) {\n\t\t\tnode.data = node.parent.data[node.route];\n\t\t\tnode.ready = true;\n\t\t\tfor (var i = 0; i < node.watchers.length; ++i)\n\t\t\t\tnode.watchers[i].callback.call(node.watchers[i].context || this, node.data);\n\t\t\tnode.watchers = [];\n\t\t\tfor (var key in node.children)\n\t\t\t\tnodeDigest(node.children[key]);\n\t\t}\n\t}\n\t\n\tfunction nodeEnforce(node/* : Node */) {\n\t\tif (node.ready)\n\t\t\treturn;\n\t\tif (node.parent && !node.parent.ready)\n\t\t\tnodeEnforce(node.parent);\n\t\tnode.ready = true;\n\t\tif (node.parent) {\n\t\t\tif (options.tree && typeof node.parent.data == \"object\")\n\t\t\t\tnode.parent.data[node.route] = node.data;\n\t\t}\n\t\tfor (var i = 0; i < node.watchers.length; ++i)\n\t\t\tnode.watchers[i].callback.call(node.watchers[i].context || this, node.data);\n\t\tnode.watchers = [];\n\t}\n\t\n\tfunction nodeSetData(node/* : Node */, value) {\n\t\tif (typeof value == \"object\" && node.ready) {\n\t\t\tfor (var key in value)\n\t\t\t\tnode.data[key] = value[key];\n\t\t} else\n\t\t\tnode.data = value;\n\t\tif (typeof value == \"object\") {\n\t\t\tfor (var ckey in value) {\n\t\t\t\tif (node.children[ckey])\n\t\t\t\t\tnode.children[ckey].data = value[ckey];\n\t\t\t}\n\t\t}\n\t\tnodeEnforce(node);\n\t\tfor (var k in node.children)\n\t\t\tnodeDigest(node.children[k]);\n\t}\n\t\n\tfunction nodeClearData(node/* : Node */) {\n\t\tif (node.ready && node.data) {\n\t\t\tfor (var key in node.data)\n\t\t\t\tdelete node.data[key];\n\t\t}\n\t}\n\t\n\tfunction nodeNavigate(path/* : ?String */) {\n\t\tif (!path)\n\t\t\treturn nsRoot;\n\t\tvar routes = path.split(\".\");\n\t\tvar current = nsRoot;\n\t\tfor (var i = 0; i < routes.length; ++i) {\n\t\t\tif (routes[i] in current.children)\n\t\t\t\tcurrent = current.children[routes[i]];\n\t\t\telse {\n\t\t\t\tcurrent.children[routes[i]] = initNode({\n\t\t\t\t\tparent: current,\n\t\t\t\t\troute: routes[i]\n\t\t\t\t});\n\t\t\t\tcurrent = current.children[routes[i]];\n\t\t\t\tnodeDigest(current);\n\t\t\t}\n\t\t}\n\t\treturn current;\n\t}\n\t\n\tfunction nodeAddWatcher(node/* : Node */, callback, context) {\n\t\tif (node.ready)\n\t\t\tcallback.call(context || this, node.data);\n\t\telse {\n\t\t\tnode.watchers.push({\n\t\t\t\tcallback: callback,\n\t\t\t\tcontext: context\n\t\t\t});\n\t\t\tif (node.lazy.length > 0) {\n\t\t\t\tvar f = function (node) {\n\t\t\t\t\tif (node.lazy.length > 0) {\n\t\t\t\t\t\tvar lazy = node.lazy.shift();\n\t\t\t\t\t\tlazy.callback.call(lazy.context || this, node.data);\n\t\t\t\t\t\tf(node);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tf(node);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction nodeUnresolvedWatchers(node/* : Node */, base, result) {\n\t\tnode = node || nsRoot;\n\t\tresult = result || [];\n\t\tif (!node.ready && node.lazy.length === 0 && node.watchers.length > 0)\n\t\t\tresult.push(base);\n\t\tfor (var k in node.children) {\n\t\t\tvar c = node.children[k];\n\t\t\tvar r = (base ? base + \".\" : \"\") + c.route;\n\t\t\tresult = nodeUnresolvedWatchers(c, r, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/** \n\t * The namespace module manages a namespace in the Scoped system.\n\t * \n\t * @module Namespace\n\t * @access public\n\t */\n\treturn {\n\t\t\n\t\t/**\n\t\t * Extend a node in the namespace by an object.\n\t\t * \n\t\t * @param {string} path path to the node in the namespace\n\t\t * @param {object} value object that should be used for extend the namespace node\n\t\t */\n\t\textend: function (path, value) {\n\t\t\tnodeSetData(nodeNavigate(path), value);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Set the object value of a node in the namespace.\n\t\t * \n\t\t * @param {string} path path to the node in the namespace\n\t\t * @param {object} value object that should be used as value for the namespace node\n\t\t */\n\t\tset: function (path, value) {\n\t\t\tvar node = nodeNavigate(path);\n\t\t\tif (node.data)\n\t\t\t\tnodeClearData(node);\n\t\t\tnodeSetData(node, value);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Read the object value of a node in the namespace.\n\t\t * \n\t\t * @param {string} path path to the node in the namespace\n\t\t * @return {object} object value of the node or null if undefined\n\t\t */\n\t\tget: function (path) {\n\t\t\tvar node = nodeNavigate(path);\n\t\t\treturn node.ready ? node.data : null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Lazily navigate to a node in the namespace.\n\t\t * Will asynchronously call the callback as soon as the node is being touched.\n\t\t *\n\t\t * @param {string} path path to the node in the namespace\n\t\t * @param {function} callback callback function accepting the node's object value\n\t\t * @param {context} context optional callback context\n\t\t */\n\t\tlazy: function (path, callback, context) {\n\t\t\tvar node = nodeNavigate(path);\n\t\t\tif (node.ready)\n\t\t\t\tcallback(context || this, node.data);\n\t\t\telse {\n\t\t\t\tnode.lazy.push({\n\t\t\t\t\tcallback: callback,\n\t\t\t\t\tcontext: context\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Digest a node path, checking whether it has been defined by an external system.\n\t\t * \n\t\t * @param {string} path path to the node in the namespace\n\t\t */\n\t\tdigest: function (path) {\n\t\t\tnodeDigest(nodeNavigate(path));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Asynchronously access a node in the namespace.\n\t\t * Will asynchronously call the callback as soon as the node is being defined.\n\t\t *\n\t\t * @param {string} path path to the node in the namespace\n\t\t * @param {function} callback callback function accepting the node's object value\n\t\t * @param {context} context optional callback context\n\t\t */\n\t\tobtain: function (path, callback, context) {\n\t\t\tnodeAddWatcher(nodeNavigate(path), callback, context);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all unresolved watchers under a certain path.\n\t\t * \n\t\t * @param {string} path path to the node in the namespace\n\t\t * @return {array} list of all unresolved watchers \n\t\t */\n\t\tunresolvedWatchers: function (path) {\n\t\t\treturn nodeUnresolvedWatchers(nodeNavigate(path), path);\n\t\t},\n\t\t\n\t\t__export: function () {\n\t\t\treturn {\n\t\t\t\toptions: options,\n\t\t\t\tnsRoot: nsRoot\n\t\t\t};\n\t\t},\n\t\t\n\t\t__import: function (data) {\n\t\t\toptions = data.options;\n\t\t\tnsRoot = data.nsRoot;\n\t\t}\n\t\t\n\t};\n\t\n}\nfunction newScope (parent, parentNS, rootNS, globalNS) {\n\t\n\tvar self = this;\n\tvar nextScope = null;\n\tvar childScopes = [];\n\tvar parentNamespace = parentNS;\n\tvar rootNamespace = rootNS;\n\tvar globalNamespace = globalNS;\n\tvar localNamespace = newNamespace({tree: true});\n\tvar privateNamespace = newNamespace({tree: false});\n\t\n\tvar bindings = {\n\t\t\"global\": {\n\t\t\tnamespace: globalNamespace\n\t\t}, \"root\": {\n\t\t\tnamespace: rootNamespace\n\t\t}, \"local\": {\n\t\t\tnamespace: localNamespace\n\t\t}, \"default\": {\n\t\t\tnamespace: privateNamespace\n\t\t}, \"parent\": {\n\t\t\tnamespace: parentNamespace\n\t\t}, \"scope\": {\n\t\t\tnamespace: localNamespace,\n\t\t\treadonly: false\n\t\t}\n\t};\n\t\n\tvar custom = function (argmts, name, callback) {\n\t\tvar args = Helper.matchArgs(argmts, {\n\t\t\toptions: \"object\",\n\t\t\tnamespaceLocator: true,\n\t\t\tdependencies: \"array\",\n\t\t\thiddenDependencies: \"array\",\n\t\t\tcallback: true,\n\t\t\tcontext: \"object\"\n\t\t});\n\t\t\n\t\tvar options = Helper.extend({\n\t\t\tlazy: this.options.lazy\n\t\t}, args.options || {});\n\t\t\n\t\tvar ns = this.resolve(args.namespaceLocator);\n\t\t\n\t\tvar execute = function () {\n\t\t\tthis.require(args.dependencies, args.hiddenDependencies, function () {\n                var _arguments = [];\n                for (var a = 0; a < arguments.length; ++a)\n                    _arguments.push(arguments[a]);\n                _arguments[_arguments.length - 1].ns = ns;\n\t\t\t\tif (this.options.compile) {\n\t\t\t\t\tvar params = [];\n\t\t\t\t\tfor (var i = 0; i < argmts.length; ++i)\n\t\t\t\t\t\tparams.push(Helper.stringify(argmts[i]));\n\t\t\t\t\tthis.compiled += this.options.ident + \".\" + name + \"(\" + params.join(\", \") + \");\\n\\n\";\n\t\t\t\t}\n\t\t\t\tif (this.options.dependencies) {\n\t\t\t\t\tthis.dependencies[ns.path] = this.dependencies[ns.path] || {};\n\t\t\t\t\tif (args.dependencies) {\n\t\t\t\t\t\targs.dependencies.forEach(function (dep) {\n\t\t\t\t\t\t\tthis.dependencies[ns.path][this.resolve(dep).path] = true;\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}\n\t\t\t\t\tif (args.hiddenDependencies) {\n\t\t\t\t\t\targs.hiddenDependencies.forEach(function (dep) {\n\t\t\t\t\t\t\tthis.dependencies[ns.path][this.resolve(dep).path] = true;\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar result = this.options.compile ? {} : args.callback.apply(args.context || this, _arguments);\n\t\t\t\tcallback.call(this, ns, result);\n\t\t\t}, this);\n\t\t};\n\t\t\n\t\tif (options.lazy)\n\t\t\tns.namespace.lazy(ns.path, execute, this);\n\t\telse\n\t\t\texecute.apply(this);\n\n\t\treturn this;\n\t};\n\t\n\t/** \n\t * This module provides all functionality in a scope.\n\t * \n\t * @module Scoped\n\t * @access public\n\t */\n\treturn {\n\t\t\n\t\tgetGlobal: Helper.method(Globals, Globals.getPath),\n\t\tsetGlobal: Helper.method(Globals, Globals.setPath),\n\t\t\n\t\toptions: {\n\t\t\tlazy: false,\n\t\t\tident: \"Scoped\",\n\t\t\tcompile: false,\n\t\t\tdependencies: false\n\t\t},\n\t\t\n\t\tcompiled: \"\",\n\t\t\n\t\tdependencies: {},\n\t\t\n\t\t\n\t\t/**\n\t\t * Returns a reference to the next scope that will be obtained by a subScope call.\n\t\t * \n\t\t * @return {object} next scope\n\t\t */\n\t\tnextScope: function () {\n\t\t\tif (!nextScope)\n\t\t\t\tnextScope = newScope(this, localNamespace, rootNamespace, globalNamespace);\n\t\t\treturn nextScope;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates a sub scope of the current scope and returns it.\n\t\t * \n\t\t * @return {object} sub scope\n\t\t */\n\t\tsubScope: function () {\n\t\t\tvar sub = this.nextScope();\n\t\t\tchildScopes.push(sub);\n\t\t\tnextScope = null;\n\t\t\treturn sub;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates a binding within in the scope. \n\t\t * \n\t\t * @param {string} alias identifier of the new binding\n\t\t * @param {string} namespaceLocator identifier of an existing namespace path\n\t\t * @param {object} options options for the binding\n\t\t * \n\t\t */\n\t\tbinding: function (alias, namespaceLocator, options) {\n\t\t\tif (!bindings[alias] || !bindings[alias].readonly) {\n\t\t\t\tvar ns;\n\t\t\t\tif (Helper.typeOf(namespaceLocator) != \"string\") {\n\t\t\t\t\tns = {\n\t\t\t\t\t\tnamespace: newNamespace({\n\t\t\t\t\t\t\ttree: true,\n\t\t\t\t\t\t\troot: namespaceLocator\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tpath: null\t\n\t\t\t\t\t};\n\t\t\t\t} else\n\t\t\t\t\tns = this.resolve(namespaceLocator);\n\t\t\t\tbindings[alias] = Helper.extend(options, ns);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t\n\t\t/**\n\t\t * Resolves a name space locator to a name space.\n\t\t * \n\t\t * @param {string} namespaceLocator name space locator\n\t\t * @return {object} resolved name space\n\t\t * \n\t\t */\n\t\tresolve: function (namespaceLocator) {\n\t\t\tvar parts = namespaceLocator.split(\":\");\n\t\t\tif (parts.length == 1) {\n                throw (\"The locator '\" + parts[0] + \"' requires a namespace.\");\n\t\t\t} else {\n\t\t\t\tvar binding = bindings[parts[0]];\n\t\t\t\tif (!binding)\n\t\t\t\t\tthrow (\"The namespace '\" + parts[0] + \"' has not been defined (yet).\");\n\t\t\t\treturn {\n\t\t\t\t\tnamespace: binding.namespace,\n\t\t\t\t\tpath : binding.path && parts[1] ? binding.path + \".\" + parts[1] : (binding.path || parts[1])\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\t\n\t\t/**\n\t\t * Defines a new name space once a list of name space locators is available.\n\t\t * \n\t\t * @param {string} namespaceLocator the name space that is to be defined\n\t\t * @param {array} dependencies a list of name space locator dependencies (optional)\n\t\t * @param {array} hiddenDependencies a list of hidden name space locators (optional)\n\t\t * @param {function} callback a callback function accepting all dependencies as arguments and returning the new definition\n\t\t * @param {object} context a callback context (optional)\n\t\t * \n\t\t */\n\t\tdefine: function () {\n\t\t\treturn custom.call(this, arguments, \"define\", function (ns, result) {\n\t\t\t\tif (ns.namespace.get(ns.path))\n\t\t\t\t\tthrow (\"Scoped namespace \" + ns.path + \" has already been defined. Use extend to extend an existing namespace instead\");\n\t\t\t\tns.namespace.set(ns.path, result);\n\t\t\t});\n\t\t},\n\t\t\n\t\t\n\t\t/**\n\t\t * Assume a specific version of a module and fail if it is not met.\n\t\t * \n\t\t * @param {string} assumption name space locator\n\t\t * @param {string} version assumed version\n\t\t * \n\t\t */\n\t\tassumeVersion: function () {\n\t\t\tvar args = Helper.matchArgs(arguments, {\n\t\t\t\tassumption: true,\n\t\t\t\tdependencies: \"array\",\n\t\t\t\tcallback: true,\n\t\t\t\tcontext: \"object\",\n\t\t\t\terror: \"string\"\n\t\t\t});\n\t\t\tvar dependencies = args.dependencies || [];\n\t\t\tdependencies.unshift(args.assumption);\n\t\t\tthis.require(dependencies, function () {\n\t\t\t\tvar argv = arguments;\n\t\t\t\tvar assumptionValue = argv[0].replace(/[^\\d\\.]/g, \"\");\n\t\t\t\targv[0] = assumptionValue.split(\".\");\n\t\t\t\tfor (var i = 0; i < argv[0].length; ++i)\n\t\t\t\t\targv[0][i] = parseInt(argv[0][i], 10);\n\t\t\t\tif (Helper.typeOf(args.callback) === \"function\") {\n\t\t\t\t\tif (!args.callback.apply(args.context || this, args))\n\t\t\t\t\t\tthrow (\"Scoped Assumption '\" + args.assumption + \"' failed, value is \" + assumptionValue + (args.error ? \", but assuming \" + args.error : \"\"));\n\t\t\t\t} else {\n\t\t\t\t\tvar version = (args.callback + \"\").replace(/[^\\d\\.]/g, \"\").split(\".\");\n\t\t\t\t\tfor (var j = 0; j < Math.min(argv[0].length, version.length); ++j)\n\t\t\t\t\t\tif (parseInt(version[j], 10) > argv[0][j])\n\t\t\t\t\t\t\tthrow (\"Scoped Version Assumption '\" + args.assumption + \"' failed, value is \" + assumptionValue + \", but assuming at least \" + args.callback);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t\n\t\t/**\n\t\t * Extends a potentially existing name space once a list of name space locators is available.\n\t\t * \n\t\t * @param {string} namespaceLocator the name space that is to be defined\n\t\t * @param {array} dependencies a list of name space locator dependencies (optional)\n\t\t * @param {array} hiddenDependencies a list of hidden name space locators (optional)\n\t\t * @param {function} callback a callback function accepting all dependencies as arguments and returning the new additional definitions.\n\t\t * @param {object} context a callback context (optional)\n\t\t * \n\t\t */\n\t\textend: function () {\n\t\t\treturn custom.call(this, arguments, \"extend\", function (ns, result) {\n\t\t\t\tns.namespace.extend(ns.path, result);\n\t\t\t});\n\t\t},\n\t\t\t\t\n\t\t\n\t\t/**\n\t\t * Requires a list of name space locators and calls a function once they are present.\n\t\t * \n\t\t * @param {array} dependencies a list of name space locator dependencies (optional)\n\t\t * @param {array} hiddenDependencies a list of hidden name space locators (optional)\n\t\t * @param {function} callback a callback function accepting all dependencies as arguments\n\t\t * @param {object} context a callback context (optional)\n\t\t * \n\t\t */\n\t\trequire: function () {\n\t\t\tvar args = Helper.matchArgs(arguments, {\n\t\t\t\tdependencies: \"array\",\n\t\t\t\thiddenDependencies: \"array\",\n\t\t\t\tcallback: \"function\",\n\t\t\t\tcontext: \"object\"\n\t\t\t});\n\t\t\targs.callback = args.callback || function () {};\n\t\t\tvar dependencies = args.dependencies || [];\n\t\t\tvar allDependencies = dependencies.concat(args.hiddenDependencies || []);\n\t\t\tvar count = allDependencies.length;\n\t\t\tvar deps = [];\n\t\t\tvar environment = {};\n\t\t\tif (count) {\n\t\t\t\tvar f = function (value) {\n\t\t\t\t\tif (this.i < deps.length)\n\t\t\t\t\t\tdeps[this.i] = value;\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\tdeps.push(environment);\n\t\t\t\t\t\targs.callback.apply(args.context || this.ctx, deps);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (var i = 0; i < allDependencies.length; ++i) {\n\t\t\t\t\tvar ns = this.resolve(allDependencies[i]);\n\t\t\t\t\tif (i < dependencies.length)\n\t\t\t\t\t\tdeps.push(null);\n\t\t\t\t\tns.namespace.obtain(ns.path, f, {\n\t\t\t\t\t\tctx: this,\n\t\t\t\t\t\ti: i\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdeps.push(environment);\n\t\t\t\targs.callback.apply(args.context || this, deps);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t\n\t\t/**\n\t\t * Digest a name space locator, checking whether it has been defined by an external system.\n\t\t * \n\t\t * @param {string} namespaceLocator name space locator\n\t\t */\n\t\tdigest: function (namespaceLocator) {\n\t\t\tvar ns = this.resolve(namespaceLocator);\n\t\t\tns.namespace.digest(ns.path);\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t\n\t\t/**\n\t\t * Returns all unresolved definitions under a namespace locator\n\t\t * \n\t\t * @param {string} namespaceLocator name space locator, e.g. \"global:\"\n\t\t * @return {array} list of all unresolved definitions \n\t\t */\n\t\tunresolved: function (namespaceLocator) {\n\t\t\tvar ns = this.resolve(namespaceLocator);\n\t\t\treturn ns.namespace.unresolvedWatchers(ns.path);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Exports the scope.\n\t\t * \n\t\t * @return {object} exported scope\n\t\t */\n\t\t__export: function () {\n\t\t\treturn {\n\t\t\t\tparentNamespace: parentNamespace.__export(),\n\t\t\t\trootNamespace: rootNamespace.__export(),\n\t\t\t\tglobalNamespace: globalNamespace.__export(),\n\t\t\t\tlocalNamespace: localNamespace.__export(),\n\t\t\t\tprivateNamespace: privateNamespace.__export()\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Imports a scope from an exported scope.\n\t\t * \n\t\t * @param {object} data exported scope to be imported\n\t\t * \n\t\t */\n\t\t__import: function (data) {\n\t\t\tparentNamespace.__import(data.parentNamespace);\n\t\t\trootNamespace.__import(data.rootNamespace);\n\t\t\tglobalNamespace.__import(data.globalNamespace);\n\t\t\tlocalNamespace.__import(data.localNamespace);\n\t\t\tprivateNamespace.__import(data.privateNamespace);\n\t\t}\n\t\t\n\t};\n\t\n}\nvar globalNamespace = newNamespace({tree: true, global: true});\nvar rootNamespace = newNamespace({tree: true});\nvar rootScope = newScope(null, rootNamespace, rootNamespace, globalNamespace);\n\nvar Public = Helper.extend(rootScope, (function () {  \n/** \n * This module includes all public functions of the Scoped system.\n * \n * It includes all methods of the root scope and the Attach module.\n * \n * @module Public\n * @access public\n */\nreturn {\n\t\t\n\tguid: \"4b6878ee-cb6a-46b3-94ac-27d91f58d666\",\n\tversion: '0.0.22',\n\n\tupgradable: true,\n\t\t\n\tupgrade: Attach.upgrade,\n\tattach: Attach.attach,\n\tdetach: Attach.detach,\n\texports: Attach.exports,\n\t\n\t/**\n\t * Exports all data contained in the Scoped system.\n\t * \n\t * @return data of the Scoped system.\n\t * @access private\n\t */\n\t__exportScoped: function () {\n\t\treturn {\n\t\t\tglobalNamespace: globalNamespace.__export(),\n\t\t\trootNamespace: rootNamespace.__export(),\n\t\t\trootScope: rootScope.__export()\n\t\t};\n\t},\n\t\n\t/**\n\t * Import data into the Scoped system.\n\t * \n\t * @param data of the Scoped system.\n\t * @access private\n\t */\n\t__importScoped: function (data) {\n\t\tglobalNamespace.__import(data.globalNamespace);\n\t\trootNamespace.__import(data.rootNamespace);\n\t\trootScope.__import(data.rootScope);\n\t}\n\t\n};\n\n}).call(this));\n\nPublic = Public.upgrade();\nPublic.exports();\n\treturn Public;\n}).call(this);\n/*!\nbetajs - v1.0.245 - 2023-12-04\nCopyright (c) Oliver Friedmann,Victor Lingenthal\nApache-2.0 Software License.\n*/\n\n(function () {\nvar Scoped = this.subScope();\nScoped.binding('module', 'global:BetaJS');\nScoped.define(\"module:\", function () {\n\treturn {\n    \"guid\": \"71366f7a-7da3-4e55-9a0b-ea0e4e2a9e79\",\n    \"version\": \"1.0.245\",\n    \"datetime\": 1701687200263\n};\n});\nScoped.require(['module:'], function (mod) {\n\tthis.exports(typeof module != 'undefined' ? module : null, mod);\n}, this);\nScoped.define(\"module:Ajax.Support\", [\n    \"module:Ajax.NoCandidateAjaxException\",\n    \"module:Ajax.ReturnDataParseException\",\n    \"module:Ajax.RequestException\",\n    \"module:Ajax.TimeoutException\",\n    \"module:Promise\",\n    \"module:Objs\",\n    \"module:Types\",\n    \"module:Net.Uri\",\n    \"module:Net.HttpHeader\",\n    \"module:Async\",\n    \"module:Time\"\n], function(NoCandidateAjaxException, ReturnDataParseException, RequestException, TimeoutException, Promise, Objs, Types, Uri, HttpHeader, Async, Time) {\n\n    /**\n     * Ajax Support Module\n     * \n     * @module BetaJS.Ajax.Support\n     */\n    return {\n\n        __registry: [],\n\n        /**\n         * Registers an ajax execution system \n         * \n         * @param {object} descriptor Descriptor object containing a supports and an execute function\n         * @param {int} priority Priority of this execution system to be used if applicable\n         */\n        register: function(descriptor, priority) {\n            this.__registry.push({\n                descriptor: descriptor,\n                priority: priority\n            });\n        },\n\n        /**\n         * Unwrap the status from return data\n         * \n         * @param {object} json Status-encoded return object\n         * @param {string} errorDecodeType Decode type for data in case it is an error\n         * \n         * @return Unwrapped data in case of a success status\n         */\n        unwrapStatus: function(json, errorDecodeType) {\n            /*\n             * Should be:\n             * {\n             * \tstatus: XXX,\n             *  statusText: XXX, (or empty)\n             *  responseText: XXX (or empty)\n             * }\n             */\n            var status = json.status || HttpHeader.HTTP_STATUS_INTERNAL_SERVER_ERROR;\n            if (!HttpHeader.isSuccessStatus(status)) {\n                var status_text = json.statusText || HttpHeader.format(status);\n                var resp = json.responseText;\n                try {\n                    resp = this.parseReturnData(json.responseText, errorDecodeType);\n                } catch (e) {}\n                throw new RequestException(status, status_text, resp);\n            } else\n                return json.responseText;\n        },\n\n        /**\n         * Parse return data given a decode type.\n         * \n         * @param data Return data to be parsed\n         * @param {string} decodeType Decode type, e.g. \"json\"\n         * \n         * @return Parsed return data\n         */\n        parseReturnData: function(data, decodeType) {\n            if (decodeType === \"json\" && Types.is_string(data))\n                return JSON.parse(data);\n            return data;\n        },\n\n        /**\n         * Process the return data and forward the result to a promise object.\n         * \n         * @param {object} promise Promise object\n         * @param {object} options Options for processing the return data\n         * @param data Return data\n         * @param {string} decodeType Decode type, e.g. \"json\"\n         * \n         */\n        promiseReturnData: function(promise, options, data, decodeType) {\n            if (options.wrapStatus) {\n                try {\n                    data = this.parseReturnData(data, \"json\");\n                } catch (e) {\n                    promise.asyncError(new ReturnDataParseException(data, decodeType));\n                    return;\n                }\n                try {\n                    data = this.unwrapStatus(data, decodeType);\n                } catch (e) {\n                    promise.asyncError(e);\n                    return;\n                }\n            }\n            try {\n                promise.asyncSuccess(this.parseReturnData(data, decodeType));\n            } catch (e) {\n                promise.asyncError(new ReturnDataParseException(data, decodeType));\n            }\n        },\n\n        /**\n         * Process the return data and forward the result as an error to a promise object.\n         * \n         * @param {object} promise Promise object\n         * @param {int} status Error status\n         * @param {string} status_text Optional status text\n         * @param data Return data\n         * @param {string} decodeType Decode type, e.g. \"json\"\n         * \n         */\n        promiseRequestException: function(promise, status, status_text, data, decodeType) {\n            status_text = status_text || HttpHeader.format(status);\n            try {\n                promise.asyncError(new RequestException(status, status_text, this.parseReturnData(data, decodeType)));\n            } catch (e) {\n                promise.asyncError(new RequestException(status, status_text, data));\n            }\n        },\n\n        /**\n         * Return error to a promise object.\n         *\n         * @param {object} promise Promise object\n         *\n         */\n        promiseTimeoutException: function(promise) {\n            promise.asyncError(new TimeoutException(status, status_text, data));\n        },\n\n        /**\n         * Preprocess Ajax Options object.\n         * \n         * @param {object} options Options object\n         * \n         * @return {object} Preprocessed options object\n         */\n        preprocess: function(options) {\n            options = Objs.extend({\n                method: \"GET\",\n                mapMethodsKey: \"_method\",\n                wrapStatus: false,\n                wrapStatusParam: null,\n                context: this,\n                query: {},\n                jsonp: undefined,\n                noCache: undefined,\n                noCacheParam: null,\n                signingFunction: null,\n                signUrl: false,\n                postmessage: undefined,\n                contentType: \"urlencoded\", // json\n                resilience: 1,\n                resilience_filter: null,\n                resilience_delay: 1000,\n                resilience_min_status: null,\n                cors: false,\n                sendContentType: true,\n                corscreds: false,\n                forceJsonp: false,\n                forcePostmessage: false\n                /*,\n                \t\t\t\tdecodeType: \"json\"*/\n            }, options);\n            if (options.params) {\n                options.query = Objs.extend(options.query, options.params);\n                delete options.params;\n            }\n            if (!Types.is_empty(options.query)) {\n                options.query = Objs.filter(options.query, function(value) {\n                    return value !== null && value !== undefined;\n                });\n            }\n            options.method = options.method.toUpperCase();\n            options.methodSupportsPayload = options.method === \"POST\" || options.method === \"PATCH\" || options.method === \"PUT\";\n            if (options.baseUri)\n                options.uri = options.uri ? options.baseUri + options.uri : options.baseUri;\n            delete options.baseUri;\n            if (options.mapMethods && options.method in options.mapMethods) {\n                options.uri = Uri.appendUriParams(options.uri, Objs.objectBy(options.mapMethodsKey, options.method));\n                options.method = options.mapMethods[options.method];\n            }\n            if (options.wrapStatus && options.wrapStatusParam)\n                options.uri = Uri.appendUriParams(options.uri, Objs.objectBy(options.wrapStatusParam, \"true\"));\n            if (options.noCache && options.noCacheParam)\n                options.uri = Uri.appendUriParams(options.uri, Objs.objectBy(options.noCacheParam, Time.now()));\n            delete options.mapMethods;\n            delete options.mapMethodsKey;\n            if (options.contentType === \"urlencoded\" && !Types.is_empty(options.data)) {\n                options.data = Objs.filter(options.data, function(value) {\n                    return value !== null && value !== undefined;\n                });\n            }\n            options.isCorsRequest = typeof document !== \"undefined\" && Uri.isCrossDomainUri(document.location.href, options.uri);\n            return options;\n        },\n\n        /**\n         * Finalizes a uri via signing if activated\n         *\n         * @param {object} options Options for the Ajax command\n         * @param {string} uri Pre-Final uri\n         *\n         * @return {string} Final uri\n         */\n        finalizeUri: function(options, uri) {\n            return options.signUrl && options.signingFunction ? options.signingFunction(options, uri) : uri;\n        },\n\n        /**\n         * Create request object that can be executed with execute command\n         *\n         * @param {object} options Options or the Ajax command\n         * @returns {object} Request object\n         */\n        create: function(options) {\n            options = options || {};\n            var current = null;\n            this.__registry.forEach(function(candidate) {\n                if ((!current || current.priority < candidate.priority) && candidate.descriptor.supports.call(candidate.descriptor.context || candidate.descriptor, options))\n                    current = candidate;\n            }, this);\n            if (!current)\n                return Promise.error(new NoCandidateAjaxException());\n            return current.descriptor.create(options);\n        },\n\n        /**\n         * Execute an Ajax command.\n         * \n         * @param {object} options Options for the Ajax command\n         * @param {function} progress Optional progress function\n         * @param {object} progressCtx Optional progress context\n         * @param {object} request Optional request object\n         * \n         * @return {object} Execution promise\n         */\n        execute: function(options, progress, progressCtx, request) {\n            options = this.preprocess(options);\n            var current = null;\n            this.__registry.forEach(function(candidate) {\n                if ((!current || current.priority < candidate.priority) && candidate.descriptor.supports.call(candidate.descriptor.context || candidate.descriptor, options))\n                    current = candidate;\n            }, this);\n            if (!current)\n                return Promise.error(new NoCandidateAjaxException(options));\n            var helper = function(resilience) {\n                var promise = current.descriptor.execute.call(current.descriptor.context || current.descriptor, options, progress, progressCtx, request);\n                if (!resilience || resilience <= 1)\n                    return promise;\n                var returnPromise = Promise.create();\n                promise.forwardSuccess(returnPromise).error(function(err) {\n                    if (RequestException.is_class_instance(err)) {\n                        if (options.resilience_filter && options.resilience_filter(err)) {\n                            returnPromise.asyncError(err);\n                            return;\n                        }\n                        if (options.resilience_min_status && err.status_code() < options.resilience_min_status) {\n                            returnPromise.asyncError(err);\n                            return;\n                        }\n                    }\n                    Async.eventually(function() {\n                        helper(resilience - 1).forwardCallback(returnPromise);\n                    }, options.resilience_delay);\n                });\n                return returnPromise;\n            };\n            return helper(options.resilience);\n        }\n\n    };\n});\n\n\nScoped.define(\"module:Ajax.AbstractAjaxWrapper\", [\n    \"module:Class\",\n    \"module:Objs\"\n], function(Class, Objs, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Abstract Ajax Wrapper Class\n         * \n         * @class BetaJS.Ajax.AbstractAjaxWrapper\n         */\n        return {\n\n            /**\n             * Creates an instance.\n             * \n             * @param {object} options common options for ajax calls\n             */\n            constructor: function(options) {\n                inherited.constructor.call(this);\n                this.options = options;\n            },\n\n            /**\n             * Execute an ajax call.\n             * \n             * @param {object} options options for ajax call\n             * @param {function} progress Optional progress function\n             * @param {object} progressCtx Optional progress context\n             * @param {object} request Optional request object\n             * @return {object} promise for the ajax call\n             */\n            execute: function(options, progress, progressCtx, request) {\n                return this._execute(Objs.extend(Objs.clone(this.options, 1), options), progress, progressCtx, request);\n            },\n\n            _execute: function(options, progress, progressCtx, request) {\n                throw \"Not implemented\";\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Ajax.HookedAjaxWrapper\", [\n    \"module:Ajax.AbstractAjaxWrapper\",\n    \"module:Promise\"\n], function(AbstractAjaxWrapper, Promise, scoped) {\n    return AbstractAjaxWrapper.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Hooked Ajax Wrapper Class\n         *\n         * @class BetaJS.Ajax.HookedAjaxWrapper\n         */\n        return {\n\n            /**\n             * Creates an instance.\n             *\n             * @param {object} ajaxWrapper Ajax Wrapper Class\n             * @param {function} hookCallback hook callback function\n             * @param {object} hookCallbackCtx hook callback ctx\n             * @param {object} options common options for ajax calls\n             */\n            constructor: function(ajaxWrapper, hookCallback, hookCallbackCtx, options, promiseHook) {\n                inherited.constructor.call(this, options);\n                this.ajaxWrapper = ajaxWrapper;\n                this.hookCallback = hookCallback;\n                this.hookCallbackCtx = hookCallbackCtx;\n                this.promiseHook = promiseHook;\n                this.online = true;\n            },\n\n            _execute: function(options, progress, progressCtx, request) {\n                if (!this.online)\n                    return Promise.error(\"offline\");\n                var promise = this.ajaxWrapper.execute(this.hookCallback.call(this.hookCallbackCtx || this, options), progress, progressCtx, request);\n                if (this.promiseHook)\n                    promise = this.promiseHook.call(this.hookCallbackCtx || this, promise);\n                return promise;\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Ajax.AjaxWrapper\", [\n    \"module:Ajax.AbstractAjaxWrapper\",\n    \"module:Ajax.Support\"\n], function(AbstractAjaxWrapper, Support, scoped) {\n    /**\n     * Ajax Wrapper Class\n     *\n     * @class BetaJS.Ajax.AjaxWrapper\n     */\n    return AbstractAjaxWrapper.extend({\n        scoped: scoped\n    }, {\n        _execute: function(options, progress, progressCtx, request) {\n            return Support.execute(options, progress, progressCtx, request);\n        }\n    });\n});\nScoped.define(\"module:Ajax.AjaxException\", [\n    \"module:Exceptions.Exception\"\n], function(Exception, scoped) {\n    return Exception.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Abstract Ajax Exception Class\n         * \n         * @class BetaJS.Ajax.AjaxException\n         */\n        return {\n\n            /**\n             * Returns the status code associated with the exception\n             * \n             * @return {int} status code\n             */\n            status_code: function() {\n                return 500;\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Ajax.NoCandidateAjaxException\", [\n    \"module:Ajax.AjaxException\"\n], function(Exception, scoped) {\n    return Exception.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * No Candidate Ajax Exception Class\n         * \n         * @class BetaJS.Ajax.NoCandidateAjaxException\n         */\n        return {\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Ajax.TimeoutException\", [\n    \"module:Ajax.AjaxException\"\n], function(Exception, scoped) {\n    return Exception.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Timeout Exception Class\n         *\n         * @class BetaJS.Ajax.Timeout\n         */\n        return {\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Ajax.ReturnDataParseException\", [\n    \"module:Ajax.AjaxException\"\n], function(Exception, scoped) {\n    return Exception.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Return Data Parse Exception Class\n         * \n         * @class BetaJS.Ajax.ReturnDataParseException \n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param data return data\n             * @param {string} decodeType decode type for return data \n             */\n            constructor: function(data, decodeType) {\n                inherited.constructor.call(this, \"Could not decode data with type \" + decodeType);\n                this.__decodeType = decodeType;\n                this.__data = data;\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Ajax.RequestException\", [\n    \"module:Ajax.AjaxException\",\n    \"module:Objs\"\n], function(Exception, Objs, scoped) {\n    return Exception.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Request Exception Class\n         * \n         * @class BetaJS.Ajax.RequestException\n         */\n        return {\n\n            /**\n             * Instantiates a Ajax Request Exception\n             * \n             * @param status_code Status Code\n             * @param {string} status_text Status Text\n             * @param data Custom Exception Data\n             */\n            constructor: function(status_code, status_text, data) {\n                inherited.constructor.call(this, status_code + \": \" + status_text);\n                this.__status_code = status_code;\n                this.__status_text = status_text;\n                this.__data = data;\n            },\n\n            /**\n             * Returns the status code associated with the exception\n             * \n             * @return {int} status code\n             */\n            status_code: function() {\n                return this.__status_code;\n            },\n\n            /**\n             * Returns the status text associated with the exception\n             * \n             * @return {string} status text\n             */\n            status_text: function() {\n                return this.__status_text;\n            },\n\n            /**\n             * Returns the custom data associated with the exception \n             * \n             * @return custom data\n             */\n            data: function() {\n                return this.__data;\n            },\n\n            /**\n             * Returns a JSON representation of the exception\n             * \n             * @return {object} Exception JSON representation\n             */\n            json: function() {\n                return Objs.extend({\n                    data: this.data(),\n                    status_code: this.status_code(),\n                    status_text: this.status_text()\n                }, inherited.json.call(this));\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Class\", [\"module:Types\", \"module:Objs\", \"module:Functions\", \"module:Ids\"], function(Types, Objs, Functions, Ids) {\n    var Class = function() {};\n\n    /** @suppress {checkTypes} */\n    Class.extend = function(options, objects, statics, class_statics) {\n        objects = objects || [];\n        if (!Types.is_array(objects))\n            objects = [objects];\n        statics = statics || [];\n        if (!Types.is_array(statics))\n            statics = [statics];\n        class_statics = class_statics || [];\n        if (!Types.is_array(class_statics))\n            class_statics = [class_statics];\n\n        var parent = this;\n\n        objects = Objs.map(objects, function(obj) {\n            if (Types.is_function(obj))\n                obj = obj(parent.prototype);\n            return obj;\n        });\n\n        var result;\n\n        // Setup JavaScript Constructor\n        Objs.iter(objects, function(obj) {\n            if (obj.hasOwnProperty(\"constructor\"))\n                result = obj.constructor;\n        });\n        var has_constructor = Types.is_defined(result);\n        if (!has_constructor) {\n            result = function() {\n                parent.prototype.constructor.apply(this, arguments);\n            };\n        }\n\n        // Add Parent Statics\n        Objs.extend(result, parent);\n\n        // Add External Statics\n        Objs.iter(statics, function(stat) {\n            stat = Types.is_function(stat) ? stat(parent) : stat;\n            var extender = result._extender;\n            Objs.extend(result, stat);\n            if (stat._extender)\n                result._extender = Objs.extend(Objs.clone(extender, 1), stat._extender);\n        });\n\n\n        // Add Class Statics\n        var class_statics_keys = {};\n        if (parent.__class_statics_keys) {\n            for (var key in parent.__class_statics_keys)\n                result[key] = Objs.clone(parent[key], 1);\n        }\n        Objs.iter(class_statics, function(stat) {\n            Objs.extend(result, stat);\n            Objs.extend(class_statics_keys, Objs.keys(stat, true));\n        });\n        if (parent.__class_statics_keys)\n            Objs.extend(class_statics_keys, parent.__class_statics_keys);\n        result.__class_statics_keys = class_statics_keys;\n\n        // Parent & Children Hierarchy\n        result.parent = parent;\n        result.children = [];\n        result.extend = this.extend;\n        if (!parent.children)\n            parent.children = [];\n        parent.children.push(result);\n\n        // Setup Prototype\n        var ctor = function() {};\n        ctor.prototype = parent.prototype;\n        result.prototype = new ctor();\n\n        result.prototype.cls = result;\n\n\n        options = Objs.extend({}, Types.is_string(options) ? {\n            classname: options,\n            register: true\n        } : options);\n\n        var classname = options.classname;\n        if (options.scoped)\n            classname = options.scoped.ns.path;\n\n        result.classname = classname;\n        if (classname && options.register)\n            Scoped.setGlobal(classname, result);\n\n        // Setup Prototype\n        result.__notifications = {};\n        result.__implements = {};\n\n        if (parent.__notifications)\n            Objs.extend(result.__notifications, parent.__notifications, 1);\n        if (parent.__implements)\n            Objs.extend(result.__implements, parent.__implements, 1);\n\n        Objs.iter(objects, function(object) {\n            for (var objkey in object)\n                result.prototype[objkey] = result._extender && objkey in result._extender ? result._extender[objkey](result.prototype[objkey], object[objkey]) : object[objkey];\n            //Objs.extend(result.prototype, object);\n\n            // Note: Required for Internet Explorer\n            if (\"constructor\" in object)\n                result.prototype.constructor = object.constructor;\n\n            if (object._notifications) {\n                for (var key in object._notifications) {\n                    if (!result.__notifications[key])\n                        result.__notifications[key] = [];\n                    result.__notifications[key].push(object._notifications[key]);\n                }\n            }\n            if (object._implements) {\n                Objs.iter(Types.is_string(object._implements) ? [object._implements] : object._implements, function(impl) {\n                    result.__implements[impl] = true;\n                });\n            }\n        });\n        delete result.prototype._notifications;\n        delete result.prototype._implements;\n\n        if (!has_constructor) {\n            result.prototype.constructor = function() {\n                parent.prototype.constructor.apply(this, arguments);\n            };\n        }\n\n        return result;\n    };\n\n\n    /*\n     * \n     * Extending the Class\n     * \n     */\n\n    Objs.extend(Class, {\n\n        classname: \"Class\",\n\n        __class_guid: \"0f5499f9-f0d1-4c6c-a561-ef026a1eee05\",\n\n        __notifications: {},\n\n        /**\n         * Determines whether this cls is an ancestor of another class.\n         * \n         * @param {object} cls in question\n         * \n         * @return {boolean} true if ancestor\n         */\n        ancestor_of: function(cls) {\n            return (this == cls) || (this != Class && this.parent.ancestor_of(cls));\n        },\n\n        /**\n         * Determines whether something is of type class.\n         * \n         * @param cls class in question\n         * \n         * @return {boolean} true if class\n         */\n        is_class: function(cls) {\n            return cls && Types.is_object(cls) && (\"__class_guid\" in cls) && cls.__class_guid == this.__class_guid;\n        },\n\n        /**\n         * Determines whether something is of type class instance.\n         * \n         * @param obj instance in question\n         * \n         * @return {boolean} true if class instance\n         */\n        is_class_instance: function(obj) {\n            return obj && Types.is_object(obj) && (\"__class_instance_guid\" in obj) && obj.__class_instance_guid == this.prototype.__class_instance_guid;\n        },\n\n        /**\n         * Determines whether something is pure json and not a class instance.\n         * \n         * @param obj json in question\n         * \n         * @return {boolean} true if pure json\n         */\n        is_pure_json: function(obj) {\n            return obj && Types.is_object(obj) && !this.is_class_instance(obj) && Types.is_pure_object(obj);\n        },\n\n        /**\n         * Determines whether an object is an instance of this class.\n         * \n         * @param {object} obj object in question\n         * \n         * @return {boolean} true if instance of class\n         */\n        is_instance_of: function(obj) {\n            return obj && this.is_class_instance(obj) && obj.instance_of(this);\n        },\n\n        /**\n         * Adhoc defines a new class.\n         * \n         * @param parent scoped string of parent class or parent class\n         * @param current scoped string of new class\n         */\n        define: function(parent, current) {\n            var args = Functions.getArguments(arguments, 2);\n            if (Types.is_object(parent)) {\n                return Scoped.define(current, [], function(scoped) {\n                    args.unshift({\n                        scoped: scoped\n                    });\n                    return parent.extend.apply(parent, args);\n                });\n            } else {\n                return Scoped.define(current, [parent], function(parent, scoped) {\n                    args.unshift({\n                        scoped: scoped\n                    });\n                    return parent.extend.apply(parent, args);\n                });\n            }\n        },\n\n        /**\n         * Placeholder for an abstract function that should never be called.\n         */\n        abstractFunction: function() {\n            throw \"AbstractFunction\";\n        },\n\n        /**\n         * @deprecated\n         */\n        _inherited: function(cls, func) {\n            return cls.parent[func].apply(this, Array.prototype.slice.apply(arguments, [2]));\n        }\n\n    });\n\n\n\n\n\n\n    /*\n     * \n     * Extending the Object\n     * \n     */\n\n    Class.prototype.__class_instance_guid = \"e6b0ed30-80ee-4b28-af02-7d52430ba45f\";\n\n    //Class.prototype.supportsGc = false;\n\n    /**\n     * Creates a new instance.\n     */\n    Class.prototype.constructor = function() {\n        this._notify(\"construct\");\n    };\n\n    /**\n     * Destroys this instance.\n     */\n    Class.prototype.destroy = function() {\n        this._notify(\"destroy\");\n        if (this.__auto_destroy_list) {\n            this.__auto_destroy_list.forEach(function(obj) {\n                if (\"destroy\" in obj)\n                    obj.weakDestroy();\n            }, this);\n        }\n        if (this.__auto_decrease_ref_list) {\n            this.__auto_decrease_ref_list.forEach(function(obj) {\n                if (\"decreaseRef\" in obj)\n                    obj.decreaseRef(this);\n            }, this);\n        }\n        var cid = this.cid();\n        for (var key in this)\n            delete this[key];\n        Ids.objectId(this, cid);\n        this.destroy = this.__destroyedDestroy;\n    };\n\n    /**\n     * Determines whether this instance has already been destroyed.\n     * \n     * @return {boolean} true if this instance has been destroyed\n     */\n    Class.prototype.destroyed = function() {\n        return this.destroy === this.__destroyedDestroy;\n    };\n\n    /**\n     * Weakly destroy this instance, only destroying it if it hasn't been destroyed already.\n     */\n    Class.prototype.weakDestroy = function() {\n        if (!this.destroyed()) {\n            if (this.__gc) {\n                this.__gc.queue(this);\n                return;\n            }\n            this.destroy();\n        }\n    };\n\n    Class.prototype.__destroyedDestroy = function() {\n        throw (\"Trying to destroy destroyed object \" + this.cid() + \": \" + this.cls.classname + \".\");\n    };\n\n    /**\n     * Protects a function from being called recursively.\n     *\n     * @param ident string identifier of function\n     * @param func function to be called\n     */\n    Class.prototype.recursionProtection = function(ident, func) {\n        this.__recursionProtection = this.__recursionProtection || {};\n        if (this.__recursionProtection[ident])\n            return undefined;\n        this.__recursionProtection[ident] = true;\n        try {\n            var result = func.apply(this);\n            if (this && this.__recursionProtection)\n                delete this.__recursionProtection[ident];\n            return result;\n        } catch (e) {\n            if (this && this.__recursionProtection)\n                delete this.__recursionProtection[ident];\n            throw e;\n        }\n    };\n\n    /**\n     * Enable garbage collection for this instance.\n     */\n    Class.prototype.enableGc = function(gc) {\n        if (this.supportsGc)\n            this.__gc = gc;\n        return this;\n    };\n\n    /**\n     * Destroy another instance depending on this one.\n     * \n     * @param {object} other other object that should be destroyed\n     */\n    Class.prototype.dependDestroy = function(other) {\n        if (other.destroyed())\n            return;\n        if (this.__gc)\n            other.enableGc();\n        other.weakDestroy();\n        return this;\n    };\n\n    /**\n     * Returns the unique id of the object.\n     * \n     * @return {string} unique id\n     */\n    Class.prototype.cid = function() {\n        return Ids.objectId(this);\n    };\n\n    Class.prototype.cls = Class;\n\n    /**\n     * Generates a context-free function of a method.\n     * \n     * @param {string} s name of method\n     * \n     * @return {function} context-free function\n     */\n    Class.prototype.as_method = function(s) {\n        return Functions.as_method(this[s], this);\n    };\n\n    /**\n     * Automatically destroys an object when this object is being destroyed.\n     * \n     * @param {object} obj\n     * @param {boolean} returnSource return source object instead of obj\n     */\n    Class.prototype.auto_destroy = function(obj, returnSource) {\n        if (obj) {\n            if (!this.__auto_destroy_list)\n                this.__auto_destroy_list = [];\n            var target = obj;\n            if (!Types.is_array(target))\n                target = [target];\n            for (var i = 0; i < target.length; ++i)\n                this.__auto_destroy_list.push(target[i]);\n        }\n        return returnSource ? this : obj;\n    };\n\n    /**\n     * Automatically decreases an object reference when this object is being destroyed.\n     *\n     * @param {object} obj\n     * @param {boolean} returnSource return source object instead of obj\n     */\n    Class.prototype.auto_decrease_ref = function(obj, returnSource) {\n        if (obj) {\n            if (!this.__auto_decrease_ref_list)\n                this.__auto_decrease_ref_list = [];\n            var target = obj;\n            if (!Types.is_array(target))\n                target = [target];\n            for (var i = 0; i < target.length; ++i)\n                this.__auto_decrease_ref_list.push(target[i]);\n        }\n        return returnSource ? this : obj;\n    };\n\n    /**\n     * Notify all notifications listeners of an internal notification event.\n     * \n     * @param {string} name notification name\n     * \n     * @protected\n     */\n    Class.prototype._notify = function(name) {\n        if (!this.cls.__notifications)\n            return;\n        var rest = Array.prototype.slice.call(arguments, 1);\n        Objs.iter(this.cls.__notifications[name], function(entry) {\n            var method = Types.is_function(entry) ? entry : this[entry];\n            if (!method)\n                throw this.cls.classname + \": Could not find \" + name + \" notification handler \" + entry;\n            method.apply(this, rest);\n        }, this);\n    };\n\n    /**\n     * Checks whether this instance implements a certain mixin.\n     *\n     * @param identifier mixin identifier\n     * \n     * @return {boolean} true if it implements the mixin\n     */\n    Class.prototype.impl = function(identifier) {\n        return !!(this.cls.__implements && this.cls.__implements[Types.is_string(identifier) ? identifier : identifier._implements]);\n    };\n\n    /**\n     * Determines whether this instance is an instance of a certain class.\n     * \n     * @param {object} cls class in question\n     * \n     * @return {boolean} true if instance is instance of class\n     */\n    Class.prototype.instance_of = function(cls) {\n        return this.cls.ancestor_of(cls);\n    };\n\n    /**\n     * Increases the reference counter of this instance.\n     * \n     * @param {object} reference optional reference object\n     * @param {boolean} autoDecreaseRef automatically decrease reference upon destruction\n     */\n    Class.prototype.increaseRef = function(reference, autoDecreaseRef) {\n        this.__referenceCount = this.__referenceCount || 0;\n        this.__referenceCount++;\n        this.__referenceObjects = this.__referenceObjects || {};\n        if (reference) {\n            if (!this.__referenceObjects[reference.cid()])\n                this.__referenceObjects[reference.cid()] = reference;\n            else\n                this.__referenceCount--;\n            if (autoDecreaseRef)\n                reference.auto_decrease_ref(this);\n        }\n        return this;\n    };\n\n    /**\n     * Decreases the reference counter of this instance.\n     * \n     * @param {object} reference optional reference object\n     */\n    Class.prototype.decreaseRef = function(reference) {\n        this.__referenceCount = this.__referenceCount || 0;\n        this.__referenceCount--;\n        this.__referenceObjects = this.__referenceObjects || {};\n        if (reference) {\n            if (this.__referenceObjects[reference.cid()])\n                delete this.__referenceObjects[reference.cid()];\n            else\n                this.__referenceCount++;\n        }\n        if (this.__referenceCount <= 0 && Types.is_empty(this.__referenceObjects))\n            this.weakDestroy();\n        return this;\n    };\n\n    /**\n     * Inspects the instance for debugging purposes.\n     * \n     * @return {object} json object describing the instance\n     */\n    Class.prototype.inspect = function() {\n        return {\n            header: {\n                cid: this.cid(),\n                classname: this.cls.classname,\n                destroyed: this.destroyed()\n            },\n            attributes: {\n                attributes_public: Objs.filter(this, function(value, key) {\n                    return !Types.is_function(value) && key.indexOf(\"_\") !== 0;\n                }, this),\n                attributes_protected: Objs.filter(this, function(value, key) {\n                    return !Types.is_function(value) && key.indexOf(\"_\") === 0 && key.indexOf(\"__\") !== 0;\n                }, this),\n                attributes_private: Objs.filter(this, function(value, key) {\n                    return !Types.is_function(value) && key.indexOf(\"__\") === 0;\n                }, this)\n            },\n            methods: {\n                methods_public: Objs.filter(this, function(value, key) {\n                    return Types.is_function(value) && key.indexOf(\"_\") !== 0;\n                }, this),\n                methods_protected: Objs.filter(this, function(value, key) {\n                    return Types.is_function(value) && key.indexOf(\"_\") === 0 && key.indexOf(\"__\") !== 0;\n                }, this),\n                method_private: Objs.filter(this, function(value, key) {\n                    return Types.is_function(value) && key.indexOf(\"__\") === 0;\n                }, this)\n            }\n        };\n    };\n\n\n\n    /**\n     * @deprecated\n     */\n    Class.prototype._auto_destroy = function(obj) {\n        return this.auto_destroy(obj);\n    };\n\n    /**\n     * @deprecated\n     */\n    Class.prototype._inherited = function(cls, func) {\n        return cls.parent.prototype[func].apply(this, Array.prototype.slice.apply(arguments, [2]));\n    };\n\n    return Class;\n\n});\nScoped.define(\"module:Classes.InvokerMixin\", [\n    \"module:Objs\", \"module:Types\", \"module:Functions\"\n], function(Objs, Types, Functions) {\n\n    /**\n     * Invoker Mixin, delegating method calls to an invocation function.\n     * \n     * @mixin BetaJS.Classes.InvokerMixin\n     */\n    return {\n\n        /**\n         * Delegate member functio names to an invoker function.\n         * \n         * @param {function} invoker invoker delegation function\n         * @param {array} members array of member function names\n         */\n        invoke_delegate: function(invoker, members) {\n            if (!Types.is_array(members))\n                members = [members];\n            invoker = this[invoker];\n            var self = this;\n            Objs.iter(members, function(member) {\n                this[member] = function(member) {\n                    return function() {\n                        var args = Functions.getArguments(arguments);\n                        args.unshift(member);\n                        return invoker.apply(self, args);\n                    };\n                }.call(self, member);\n            }, this);\n        }\n    };\n});\n\n\n\n\nScoped.define(\"module:Classes.HelperClassMixin\", [\n    \"module:Objs\", \"module:Types\", \"module:Functions\", \"module:Promise\"\n], function(Objs, Types, Functions, Promise) {\n\n    /**\n     * HelperClass Mixin\n     * \n     * @mixin BetaJS.Classes.HelperClassMixin\n     */\n    return {\n\n        /**\n         * Add Helper Class\n         * \n         * @param {class} helper_class helper class to add\n         * @param {objects} options optional options\n         * \n         * @return {object} added helper instance\n         */\n        addHelper: function(helper_class, options) {\n            var helper = new helper_class(this, options);\n            this.__helpers = this.__helpers || [];\n            this.__helpers.push(this._auto_destroy(helper));\n            return helper;\n        },\n\n        /**\n         * Notify all helpers of a method call.\n         * \n         * @param {objects} options method call options\n         * @return accumlated return value\n         */\n        _helper: function(options) {\n            this.__helpers = this.__helpers || [];\n            if (Types.is_string(options)) {\n                options = {\n                    method: options\n                };\n            }\n            options = Objs.extend({\n                fold_start: null,\n                fold: function(acc, result) {\n                    return acc || result;\n                }\n            }, options);\n            var args = Functions.getArguments(arguments, 1);\n            var acc = options.async ? Promise.create(options.fold_start) : options.fold_start;\n            for (var i = 0; i < this.__helpers.length; ++i) {\n                var helper = this.__helpers[i];\n                if (options.method in helper) {\n                    if (options.async)\n                        acc = Promise.func(options.fold, acc, Promise.methodArgs(helper, helper[options.method], args));\n                    else\n                        acc = options.fold(acc, helper[options.method].apply(helper, args));\n                }\n            }\n            return acc;\n        }\n\n    };\n});\n\n\n\nScoped.define(\"module:Classes.PathResolver\", [\n    \"module:Class\", \"module:Objs\"\n], function(Class, Objs, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Path Resolver Class\n         * \n         * @class BetaJS.Classes.PathResolver\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {object} bindings path resolution bindings\n             */\n            constructor: function(bindings) {\n                inherited.constructor.call(this);\n                this._bindings = bindings || {};\n            },\n\n            /**\n             * Extend instance by more bindings.\n             * \n             * @param {object} bindings bindings to extend\n             * @param {string} namespace optional namespace\n             * \n             */\n            extend: function(bindings, namespace) {\n                if (namespace) {\n                    for (var key in bindings) {\n                        var value = bindings[key];\n                        var regExp = /\\{([^}]+)\\}/;\n                        while (true) {\n                            var matches = regExp.exec(value);\n                            if (!matches)\n                                break;\n                            value = value.replace(regExp, namespace + \".\" + matches[1]);\n                        }\n                        this._bindings[namespace + \".\" + key] = value;\n                    }\n                } else\n                    this._bindings = Objs.extend(this._bindings, bindings);\n            },\n\n            /**\n             * Map an array of path expressions to their resolutions.\n             * \n             * @param {array} arr list of path expression\n             * \n             * @return {array} resolved expressions\n             */\n            map: function(arr) {\n                var result = [];\n                for (var i = 0; i < arr.length; ++i) {\n                    if (arr[i])\n                        result.push(this.resolve(arr[i]));\n                }\n                return result;\n            },\n\n            /**\n             * Resolve a path rexpression.\n             * \n             * @param {string} path path expression to resolve\n             * \n             * @return {string} resolved path expression\n             */\n            resolve: function(path) {\n                var regExp = /\\{([^}]+)\\}/;\n                while (true) {\n                    var matches = regExp.exec(path);\n                    if (!matches)\n                        break;\n                    path = path.replace(regExp, this._bindings[matches[1]]);\n                }\n                return this.simplify(path);\n            },\n\n            /**\n             * Simplify a path expression.\n             * \n             * @param {string} path path expression to simplify\n             * \n             * @return {string} simplified path expression\n             */\n            simplify: function(path) {\n                return path.replace(/[^\\/]+\\/\\.\\.\\//, \"\").replace(/\\/[^\\/]+\\/\\.\\./, \"\");\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Classes.MultiDelegatable\", [\n    \"module:Class\", \"module:Objs\"\n], function(Class, Objs, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Multi Delegatable Class\n         * \n         * @class BetaJS.Classes.MultiDelegatable\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {array} objects list of objects\n             * @param {array} methods list of methods\n             */\n            constructor: function(objects, methods) {\n                inherited.constructor.call(this);\n                Objs.iter(methods, function(method) {\n                    this[method] = function() {\n                        var args = arguments;\n                        Objs.iter(objects, function(object) {\n                            object[method].apply(object, args);\n                        }, this);\n                        return this;\n                    };\n                }, this);\n            }\n\n        };\n    });\n});\n\n\n\nScoped.define(\"module:Classes.ObjectIdScopeMixin\", function() {\n\n    /**\n     * Object Id Scope Mixin\n     * \n     * @mixin BetaJS.Classes.ObjectIdScopeMixin\n     */\n    return {\n\n        __objects: {},\n\n        /**\n         * Return object for specific id\n         * \n         * @param {string} id id of object\n         * \n         * @return {object} object in question\n         */\n        get: function(id) {\n            return this.__objects[id];\n        }\n\n    };\n});\n\n\nScoped.define(\"module:Classes.ObjectIdScope\", [\n    \"module:Class\", \"module:Classes.ObjectIdScopeMixin\"\n], function(Class, Mixin, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, Mixin, function(inherited) {\n\n        /**\n         * Object Id Scope Class\n         * \n         * @class BetaJS.Classes.ObjectIdScope\n         */\n        return {\n\n            /**\n             * Create or return singleton instance of this class.\n             * \n             * @return {object} singleton instance\n             */\n            singleton: function() {\n                if (!this.__singleton)\n                    this.__singleton = new this();\n                return this.__singleton;\n            }\n        };\n    });\n});\n\n\nScoped.define(\"module:Classes.SingletonMixin\", [], function() {\n    /**\n     * SingletonMixin\n     *\n     * @mixin BetaJS.Classes.SingletonMixin\n     */\n    return {\n\n        _notifications: {\n            construct: \"__singleton_create\",\n            destroy: \"__singleton_destroy\"\n        },\n\n        __singleton_create: function() {\n            if (this.cls.__singleton)\n                throw (\"Can only create a single instance of \" + this.cls.classname);\n            this.cls.__singleton = this;\n        },\n\n        __singleton_destroy: function() {\n            this.cls.__singleton = null;\n        }\n\n    };\n});\n\n\nScoped.define(\"module:Classes.SingletonClassMixin\", [], function() {\n    /**\n     * SingletonMixinClass\n     *\n     * @mixin BetaJS.Classes.SingletonMixinClass\n     */\n    return {\n\n        singleton: function() {\n            this.__singleton = this.__singleton || new this();\n            return this.__singleton;\n        }\n\n    };\n});\n\n\nScoped.define(\"module:Classes.ObjectIdMixin\", [\n    \"module:Classes.ObjectIdScope\"\n], function(ObjectIdScope) {\n\n    /**\n     * Object Id Mixin\n     * \n     * @mixin BetaJS.Classes.ObjectIdMixin\n     */\n    return {\n\n        _notifications: {\n            construct: \"__register_object_id\",\n            destroy: \"__unregister_object_id\"\n        },\n\n        __object_id_scope: function() {\n            if (!this.object_id_scope)\n                this.object_id_scope = ObjectIdScope.singleton();\n            return this.object_id_scope;\n        },\n\n        __register_object_id: function() {\n            var scope = this.__object_id_scope();\n            scope.__objects[this.cid()] = this;\n        },\n\n        __unregister_object_id: function() {\n            var scope = this.__object_id_scope();\n            delete scope.__objects[this.cid()];\n        }\n\n    };\n});\n\n\nScoped.define(\"module:Classes.SharedObjectFactory\", [\n    \"module:Class\"\n], function(Class, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Shared Object Factory Class\n         *\n         * @class BetaJS.Classes.SharedObjectFactory\n         */\n        return {\n\n            /**\n             * Creates a new factory.\n             *\n             * @param {function} createCallback callback function for creating an instance\n             * @param {object} createContext optional callback context\n             */\n            constructor: function(createCallback, createContext, createArgs) {\n                inherited.constructor.call(this);\n                this.__createCallback = createCallback;\n                this.__createContext = createContext;\n                this.__createArgs = createArgs || [];\n                this.__object = null;\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                if (this.__object && !this.__object.destroyed())\n                    this.__object.destroy();\n                inherited.destroy.call(this);\n            },\n\n            /**\n             * Return object instance.\n             *\n             * @returns {object} shared object instance\n             */\n            value: function() {\n                return this.__object && !this.__object.destroyed() ? this.__object : null;\n            },\n\n            /**\n             * Return true if acquired.\n             *\n             * @returns {boolean} true if acquired\n             */\n            isAcquired: function() {\n                return !!this.value();\n            },\n\n            /**\n             * Acquire object instance.\n             *\n             * @param {object} reference optional reference\n             * @param {boolean} autoDecreaseRef automatically decrease reference upon destruction\n             *\n             * @returns {object} shared object instance\n             */\n            acquire: function(reference, autoDecreaseRef) {\n                if (!this.__object || this.__object.destroyed())\n                    this.__object = this.__createCallback.apply(this.__createContext || this, this.__createArgs);\n                this.__object.increaseRef(reference, autoDecreaseRef);\n                return this.__object;\n            },\n\n            /**\n             * Release object instance.\n             *\n             * @param {object} obj object instance\n             * @param {object} reference optional reference\n             */\n            release: function(obj, reference) {\n                if (obj && obj === this.__object && !obj.destroyed())\n                    obj.decreaseRef(obj);\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Classes.SharedObjectFactoryPool\", [\n    \"module:Class\",\n    \"module:Objs\",\n    \"module:Functions\"\n], function(Class, Objs, Functions, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Shared Object Factory Pool Class\n         *\n         * @class BetaJS.Classes.SharedObjectFactoryPool\n         */\n        return {\n\n            /**\n             * Creates a new factory pool.\n             *\n             * @param {function} createCallback callback function for creating a shared object factory instance\n             * @param {object} createContext optional callback context\n             */\n            constructor: function(createCallback, createContext) {\n                inherited.constructor.call(this);\n                this.__createCallback = createCallback;\n                this.__createContext = createContext;\n                this.__cache = {};\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                Objs.iter(this.__cache, function(instance) {\n                    instance.weakDestroy();\n                }, this);\n                inherited.destroy.call(this);\n            },\n\n            acquire: function() {\n                var args = Functions.getArguments(arguments);\n                var serialized = JSON.stringify(args);\n                if (!this.__cache[serialized] || this.__cache[serialized].destroyed())\n                    this.__cache[serialized] = this.__createCallback.apply(this.__createContext || this, args);\n                return this.__cache[serialized];\n            }\n\n        };\n    });\n});\n\n\n\nScoped.define(\"module:Classes.CriticalSectionMixin\", [\n    \"module:Promise\"\n], function(Promise) {\n\n    return {\n\n        criticalSection: function(name, cb) {\n            this.__criticalSections = this.__criticalSections || {};\n            this.__criticalSections[name] = this.__criticalSections[name] || [];\n            var promise = Promise.create();\n            this.__criticalSections[name].push(promise);\n            if (this.__criticalSections[name].length === 1)\n                promise.asyncSuccess(true);\n            return promise.mapSuccess(function() {\n                return Promise.box(cb, this).callback(function() {\n                    this.__criticalSections[name].shift();\n                    if (this.__criticalSections[name].length > 0)\n                        this.__criticalSections[name][0].asyncSuccess(true);\n                }, this);\n            }, this);\n        }\n\n    };\n});\n\n\n\nScoped.define(\"module:Classes.CacheHash\", [\n    \"module:Class\"\n], function(Class, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n        return {\n\n            constructor: function(prefix) {\n                inherited.constructor.call(this);\n                this.__prefix = prefix || \"\";\n                this.__counter = 0;\n                this.__cache = {};\n                this.__hash = {};\n            },\n\n            hashKey: function(key) {\n                if (key in this.__hash)\n                    return this.__hash[key];\n                var c = this.__prefix + this.__counter++;\n                this.__hash[key] = c;\n                this.__cache[c] = key;\n                return c;\n            },\n\n            hash: function() {\n                return this.__hash;\n            },\n\n            cache: function() {\n                return this.__cache;\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Comparators\", [\"module:Types\", \"module:Properties.Properties\"], function(Types, Properties) {\n\n    /**\n     * Comparator Functions\n     * \n     * @module BetaJS.Comparators\n     */\n    return {\n\n\n\n        compound: function(comparators) {\n            return function(x, y) {\n                for (var i = 0; i < comparators.length; ++i) {\n                    var c = comparators[i](x, y);\n                    if (c != 0)\n                        return c;\n                }\n                return 0;\n            };\n        },\n\n\n        /**\n         * Creates a function that compares two json object w.r.t. a json object, mapping keys to a comparison order,\n         * e.g. {'last_name': 1, 'first_name': -1, 'age': -1 }  \n         * \n         * @param {json} object comparison object\n         * @return {function} function for comparing two objects w.r.t. the comparison object\n         */\n        byObject: function(object) {\n            var self = this;\n            return function(left, right) {\n                for (var key in object) {\n                    var c = 0;\n                    if (Properties.is_class_instance(left) && Properties.is_class_instance(right))\n                        c = self.byValue(left.get(key) || null, right.get(key) || null);\n                    else\n                        c = self.byValue(left[key] || null, right[key] || null);\n                    if (c !== 0)\n                        return c * object[key];\n                }\n                return 0;\n            };\n        },\n\n\n        /**\n         * Compares to variables by the natural order in JS.\n         * \n         * @param a value A\n         * @param b value B\n         * @return {int} 1 if a > b, -1 if a < b and 0 otherwise\n         */\n        byValue: function(a, b) {\n            if (Types.is_string(a))\n                return a.localeCompare(b);\n            if (a < b)\n                return -1;\n            if (a > b)\n                return 1;\n            return 0;\n        },\n\n\n        /**\n         * Compares two values a and b recursively.\n         * \n         * @param a value A\n         * @param b value B\n         * @param {int} depth depth limit for the recursion, leave blank for infinite recursion\n         * @return {bool} true if both values are equal\n         */\n        deepEqual: function(a, b, depth) {\n            if (depth === 0)\n                return true;\n            if (depth === 1)\n                return a === b;\n            if (Types.is_array(a) && Types.is_array(b)) {\n                if (a.length !== b.length)\n                    return false;\n                for (var i = 0; i < a.length; ++i)\n                    if (!this.deepEqual(a[i], b[i], depth - 1))\n                        return false;\n                return true;\n            } else if (Types.is_object(a) && Types.is_object(b)) {\n                if (!a || !b)\n                    return a === b;\n                for (var key in a)\n                    if (!this.deepEqual(a[key], b[key], depth - 1))\n                        return false;\n                for (key in b)\n                    if (!(key in a))\n                        return false;\n                return true;\n            } else\n                return a === b;\n        },\n\n\n        /**\n         * Determines whether two lists are equal. Two lists are considered equal if their elements are equal.\n         * \n         * @param a list A\n         * @param b list B\n         * @return {bool} true if both lists are equal\n         */\n        listEqual: function(a, b) {\n            return this.deepEqual(a, b, 2);\n        }\n\n    };\n});\nScoped.define(\"module:Compress\", function() {\n\n    /**\n     * Compress Module\n     * \n     * Contains simple and reasonably fast LZW Like Encode / Decode Functions\n     * \n     * Differs from standard LZW in the following sense:\n     *\n     *   - If input contains characters not included in the initial dictionary, output stream sends:\n     *       (1) dictionary.size + 1 (2) the input character\n     *       \n     *   - If dictionary size exceeds 2 bytes, the dictionary is reset\n     * \n     * @module BetaJS.Compress\n     */\n    return {\n\n        /**\n         * LZW Like Encode Function\n         * \n         * @param {string} input input string\n         * @param {int} dict initial dictionary size, default is 1 byte\n         * \n         * @param {string} UTF-8 encoded compressed string\n         */\n        lzw_like_encode: function(input, dict) {\n            if (dict === undefined)\n                dict = 256;\n            var dictionary = new Map();\n            var output = [];\n            for (var i = 0; i < dict; ++i)\n                dictionary.set(String.fromCharCode(i), i);\n            var acc = \"\";\n            for (var j = 0; j < input.length; ++j) {\n                var c = input.charAt(j);\n                if (!dictionary.has(c)) {\n                    if (acc)\n                        output.push(dictionary.get(acc));\n                    dictionary.set(c, dictionary.size);\n                    output.push(dictionary.size + 1);\n                    output.push(input.charCodeAt(j));\n                    acc = \"\";\n                } else if (dictionary.has(acc + c)) {\n                    acc += c;\n                } else {\n                    output.push(dictionary.get(acc));\n                    dictionary.set(acc + c, dictionary.size);\n                    acc = c;\n                    if (dictionary.size >= 256 * 256 - 1) {\n                        dictionary = new Map();\n                        for (i = 0; i < dict; ++i)\n                            dictionary.set(String.fromCharCode(i), i);\n                        acc = \"\";\n                        j--;\n                    }\n                }\n            }\n            if (acc)\n                output.push(dictionary.get(acc));\n            return output.map(function(i) {\n                return String.fromCharCode(i);\n            }).join(\"\");\n        },\n\n        /**\n         * LZW Like Decode Function\n         * \n         * @param {string} input UTF-8 encoded compressed input string\n         * @param {int} dict initial dictionary size, default is 1 byte\n         * \n         * @param {string} decompressed string\n         */\n        lzw_like_decode: function(input, dict) {\n            if (dict === undefined)\n                dict = 256;\n            var dictionary = [];\n            var output = [];\n            for (var i = 0; i < dict; ++i)\n                dictionary.push(String.fromCharCode(i));\n            var last = \"\";\n            for (var j = 0; j < input.length; ++j) {\n                var code = input.charCodeAt(j);\n                if (code > dictionary.length) {\n                    j++;\n                    code = input.charCodeAt(j);\n                    output.push(String.fromCharCode(code));\n                    dictionary.push(String.fromCharCode(code));\n                    last = \"\";\n                } else {\n                    var cur = code < dictionary.length ? dictionary[code] : (last + last.charAt(0));\n                    output.push(cur);\n                    if (last)\n                        dictionary.push(last + cur.charAt(0));\n                    last = cur;\n                    if (dictionary.length >= 256 * 256 - 2) {\n                        dictionary = [];\n                        for (i = 0; i < dict; ++i)\n                            dictionary.push(String.fromCharCode(i));\n                        last = \"\";\n                    }\n                }\n            }\n            return output.join(\"\");\n        }\n\n    };\n});\nScoped.define(\"module:Events.EventsMixin\", [\n    \"module:Timers.Timer\",\n    \"module:Async\",\n    \"module:Lists.LinkedList\",\n    \"module:Functions\",\n    \"module:Types\",\n    \"module:Objs\"\n], function(Timer, Async, LinkedList, Functions, Types, Objs) {\n\n    /**\n     * Events Mixin\n     * \n     * @mixin BetaJS.Events.EventsMixin\n     */\n    return {\n\n        _implements: \"3d63b44f-c9f0-4aa7-b39e-7cbf195122b4\",\n\n        _notifications: {\n            \"construct\": function() {\n                this.__suspendedEvents = 0;\n                this.__suspendedEventsQueue = [];\n            },\n            \"destroy\": function() {\n                this.off(null, null, null);\n            }\n        },\n\n        EVENT_SPLITTER: /\\s+/,\n\n        __create_event_object: function(callback, context, options) {\n            options = options || {};\n            var obj = {\n                callback: callback,\n                context: context\n            };\n            if (options.eventually)\n                obj.eventually = options.eventually;\n            if (options.off_on_destroyed)\n                obj.off_on_destroyed = options.off_on_destroyed;\n            if (options.min_delay) {\n                obj.min_delay = new Timer({\n                    delay: options.min_delay,\n                    once: true,\n                    start: false,\n                    context: this,\n                    fire: function() {\n                        if (obj.max_delay)\n                            obj.max_delay.stop();\n                        this.__invokeCallback(obj);\n                    }\n                });\n            }\n            if (options.max_delay) {\n                obj.max_delay = new Timer({\n                    delay: options.max_delay,\n                    once: true,\n                    start: false,\n                    context: this,\n                    fire: function() {\n                        if (obj.min_delay)\n                            obj.min_delay.stop();\n                        this.__invokeCallback(obj);\n                    }\n                });\n            }\n            if (options.norecursion)\n                obj.no_recursion = true;\n            return obj;\n        },\n\n        __destroy_event_object: function(object) {\n            if (object.min_delay)\n                object.min_delay.destroy();\n            if (object.max_delay)\n                object.max_delay.destroy();\n        },\n\n        __invokeCallback: function(obj, params) {\n            if (obj.off_on_destroyed && obj.context && obj.context.destroyed()) {\n                this.off(null, null, obj);\n                return;\n            }\n            if (obj.no_recursion && obj.in_recursion)\n                return;\n            obj.in_recursion = true;\n            try {\n                this._invokeCallback(obj.callback, obj.context || this, params || obj.params);\n            } finally {\n                obj.in_recursion = false;\n            }\n        },\n\n        /**\n         * @protected\n         *\n         * Invoke event callback\n         *\n         * @param {function} callback event callback function\n         * @param {object} context callback context\n         * @param {array} params parameters\n         */\n        _invokeCallback: function(callback, context, params) {\n            callback.apply(context, params);\n        },\n\n        __call_event_object: function(object, params) {\n            if (object.min_delay)\n                object.min_delay.restart();\n            if (object.max_delay)\n                object.max_delay.start();\n            if (!object.min_delay && !object.max_delay) {\n                if (object.eventually) {\n                    Async.eventually(function() {\n                        this.__invokeCallback(object, params);\n                    }, this, object.eventually === true ? 0 : object.eventually);\n                } else\n                    this.__invokeCallback(object, params);\n            } else\n                object.params = params;\n        },\n\n        /**\n         * Listen to an event(s).\n         * \n         * @param {string} events event(s) to listen to\n         * @param {function} callback event callback function\n         * @param {object} context optional callback context\n         * @param {object} options optional options\n         */\n        on: function(events, callback, context, options) {\n            this.__events_mixin_events = this.__events_mixin_events || {};\n            events = events.split(this.EVENT_SPLITTER);\n            var event;\n            while (true) {\n                event = events.shift();\n                if (!event)\n                    break;\n                if (!this.__events_mixin_events[event])\n                    this._notify(\"register_event\", event);\n                this.__events_mixin_events[event] = this.__events_mixin_events[event] || new LinkedList();\n                var event_object = this.__create_event_object(callback, context, options);\n                this.__events_mixin_events[event].add(event_object);\n                if (this.__events_mixin_persistent_events && this.__events_mixin_persistent_events[event]) {\n                    var argss = this.__events_mixin_persistent_events[event];\n                    for (var i = 0; i < argss.length; ++i)\n                        this.__call_event_object(event_object, argss[i]);\n                }\n                if (options && options.initcall)\n                    this.__call_event_object(event_object, []);\n            }\n            return this;\n        },\n\n        /**\n         * Stop listening to an event(s).\n         * \n         * @param {string} events event(s) to listen to\n         * @param {function} callback event callback function\n         * @param {object} context optional callback context\n         */\n        off: function(events, callback, context) {\n            this.__events_mixin_events = this.__events_mixin_events || {};\n            if (events) {\n                events = events.split(this.EVENT_SPLITTER);\n                Objs.iter(events, function(event) {\n                    if (this.__events_mixin_events[event]) {\n                        this.__events_mixin_events[event].remove_by_filter(function(object) {\n                            var result = (!callback || object.callback == callback) && (!context || object.context == context);\n                            if (result && this.__destroy_event_object)\n                                this.__destroy_event_object(object);\n                            return result;\n                        });\n                        if (this.__events_mixin_events[event].count() === 0) {\n                            this.__events_mixin_events[event].destroy();\n                            delete this.__events_mixin_events[event];\n                            this._notify(\"unregister_event\", event);\n                        }\n                    }\n                }, this);\n            } else {\n                Objs.iter(this.__events_mixin_events, function(evntobj, evnt) {\n                    evntobj.remove_by_filter(function(object) {\n                        var result = (!callback || object.callback == callback) && (!context || object.context == context);\n                        if (result && this.__destroy_event_object)\n                            this.__destroy_event_object(object);\n                        return result;\n                    });\n                    if (evntobj.count() === 0) {\n                        evntobj.destroy();\n                        delete this.__events_mixin_events[evnt];\n                        this._notify(\"unregister_event\", evnt);\n                    }\n                }, this);\n            }\n            return this;\n        },\n\n        /**\n         * Listen to an event(s) once.\n         * \n         * @param {string} events event(s) to listen to\n         * @param {function} callback event callback function\n         * @param {object} context optional callback context\n         * @param {object} options optional options\n         */\n        once: function(events, callback, context, options) {\n            var self = this;\n            var once = Functions.once(function() {\n                self.off(events, once);\n                callback.apply(this, arguments);\n            });\n            once._callback = callback;\n            return this.on(events, once, context, options);\n        },\n\n        /**\n         * Trigger an event(s) asynchronously.\n         * \n         * @param {string} events events to be triggered\n         */\n        trigger: function(events) {\n            if (this.__suspendedEvents > 0) {\n                this.__suspendedEventsQueue.push(arguments);\n                return this;\n            }\n            var self = this;\n            events = events.split(this.EVENT_SPLITTER);\n            var rest = Functions.getArguments(arguments, 1);\n            var event;\n            if (!this.__events_mixin_events)\n                return this;\n            Objs.iter(events, function(event) {\n                if (this.__events_mixin_events[event])\n                    this.__events_mixin_events[event].iterate(function(object) {\n                        self.__call_event_object(object, rest);\n                    });\n                if (this.__events_mixin_events && \"all\" in this.__events_mixin_events)\n                    this.__events_mixin_events.all.iterate(function(object) {\n                        self.__call_event_object(object, [event].concat(rest));\n                    });\n            }, this);\n            return this;\n        },\n\n        /**\n         * Trigger an event(s) asynchronously.\n         * \n         * @param {string} events events to be triggered\n         */\n        triggerAsync: function() {\n            var self = this;\n            var args = Functions.getArguments(arguments);\n            var timeout = setTimeout(function() {\n                clearTimeout(timeout);\n                self.trigger.apply(self, args);\n            }, 0);\n            return this;\n        },\n\n        /**\n         * Persistenly trigger an event(s).\n         * \n         * @param {string} events events to be triggered\n         */\n        persistentTrigger: function(events) {\n            var rest = Functions.getArguments(arguments, 1);\n            this.__events_mixin_persistent_events = this.__events_mixin_persistent_events || [];\n            Objs.iter(events.split(this.EVENT_SPLITTER), function(event) {\n                this.__events_mixin_persistent_events[event] = this.__events_mixin_persistent_events[event] || [];\n                this.__events_mixin_persistent_events[event].push(rest);\n            }, this);\n            this.trigger.apply(this, arguments);\n            return this;\n        },\n\n        /**\n         * Delegate certain events to this event object.\n         * \n         * @param {string} events events to be delegated\n         * @param {object} source source event object\n         * @param {string} prefix optional event prefix for delegation\n         * @param {array} params optional additional event params\n         */\n        delegateEvents: function(events, source, prefix, params) {\n            params = params || [];\n            prefix = prefix ? prefix + \":\" : \"\";\n            if (events === null) {\n                source.on(\"all\", function(event) {\n                    var rest = Functions.getArguments(arguments, 1);\n                    this.trigger.apply(this, [prefix + event].concat(params).concat(rest));\n                }, this);\n            } else {\n                if (!Types.is_array(events))\n                    events = [events];\n                Objs.iter(events, function(event) {\n                    source.on(event, function() {\n                        var rest = Functions.getArguments(arguments);\n                        this.trigger.apply(this, [prefix + event].concat(params).concat(rest));\n                    }, this);\n                }, this);\n            }\n            return this;\n        },\n\n        /**\n         * Returns the parent event object in the chain.\n         * \n         * @return {object} parent event object\n         * \n         * @protected\n         * @abstract\n         */\n        _eventChain: function() {},\n\n        /**\n         * Trigger an event locally and up the chain.\n         * \n         * @param {string} eventName name of event\n         * @param data event data\n         */\n        chainedTrigger: function(eventName, data) {\n            data = Objs.extend({\n                source: this,\n                bubbles: true\n            }, data);\n            this.trigger(eventName, data);\n            if (data.bubbles) {\n                var chain = this._eventChain();\n                if (chain && chain.chainedTrigger)\n                    chain.chainedTrigger(eventName, data);\n            }\n            return this;\n        },\n\n        /**\n         * Suspend all events until resumed.\n         */\n        suspendEvents: function() {\n            this.__suspendedEvents++;\n            return this;\n        },\n\n        /**\n         * Resume all events.\n         */\n        resumeEvents: function() {\n            this.__suspendedEvents--;\n            if (this.__suspendedEvents !== 0)\n                return this;\n            Objs.iter(this.__suspendedEventsQueue, function(ev) {\n                this.trigger.apply(this, ev);\n            }, this);\n            this.__suspendedEventsQueue = [];\n            return this;\n        }\n\n    };\n});\n\n\nScoped.define(\"module:Events.Events\", [\"module:Class\", \"module:Events.EventsMixin\"], function(Class, Mixin, scoped) {\n    /**\n     * Events Class\n     * \n     * @class BetaJS.Events.Events\n     * @implements BetaJS.Events.EventsMixin\n     */\n    return Class.extend({\n        scoped: scoped\n    }, Mixin);\n});\n\n\nScoped.define(\"module:Events.ListenMixin\", [\n    \"module:Ids\",\n    \"module:Objs\",\n    \"module:Types\"\n], function(Ids, Objs, Types) {\n    /**\n     * Listen Mixin, automatically de-registering all listeners on destruction.\n     * \n     * @mixin BetaJS.Events.ListenMixin\n     */\n    return {\n\n        _notifications: {\n            \"destroy\": \"listenOff\"\n        },\n\n        /**\n         * Listen to an event.\n         * \n         * @param {object} targets target(s) event emitter\n         * @param {string} events event(s) to listen to\n         * @param {function} callback event callback function\n         * @param {object} options optional listener options\n         */\n        listenOn: function(targets, events, callback, options) {\n            if (!this.__listen_mixin_listen)\n                this.__listen_mixin_listen = {};\n            if (!Types.is_array(targets))\n                targets = [targets];\n            targets.forEach(function(target) {\n                this.__listen_mixin_listen[Ids.objectId(target)] = target;\n                target.on(events, callback, this, options);\n            }, this);\n            return this;\n        },\n\n        /**\n         * Listen to an event once.\n         *\n         * @param {object} targets target(s) event emitter\n         * @param {string} events event(s) to listen to\n         * @param {function} callback event callback function\n         * @param {object} options optional listener options\n         */\n        listenOnce: function(targets, events, callback, options) {\n            if (!this.__listen_mixin_listen)\n                this.__listen_mixin_listen = {};\n            if (!Types.is_array(targets))\n                targets = [targets];\n            targets.forEach(function(target) {\n                this.__listen_mixin_listen[Ids.objectId(target)] = target;\n                target.once(events, callback, this, options);\n            }, this);\n            return this;\n        },\n\n        /**\n         * Stop Listenning to an event.\n         *\n         * @param {object} targets target(s) event emitter\n         * @param {string} events event(s) to listen to\n         * @param {function} callback event callback function\n         */\n        listenOff: function(targets, events, callback) {\n            if (!this.__listen_mixin_listen)\n                return this;\n            if (!Types.is_array(targets))\n                targets = [targets];\n            targets.forEach(function(target) {\n                if (target && !target.destroyed()) {\n                    target.off(events, callback, this);\n                    if (!events && !callback)\n                        delete this.__listen_mixin_listen[Ids.objectId(target)];\n                } else {\n                    Objs.iter(this.__listen_mixin_listen, function(obj) {\n                        if (obj && \"off\" in obj && !obj.destroyed())\n                            obj.off(events, callback, this);\n                        if (!events && !callback)\n                            delete this.__listen_mixin_listen[Ids.objectId(obj)];\n                    }, this);\n                }\n            }, this);\n            return this;\n        }\n\n    };\n});\n\n\nScoped.define(\"module:Events.Listen\", [\"module:Class\", \"module:Events.ListenMixin\"], function(Class, Mixin, scoped) {\n    /**\n     * Listen Class\n     * \n     * @class BetaJS.Events.Listen\n     * @implements BetaJS.Events.ListenMixin\n     */\n    return Class.extend({\n        scoped: scoped\n    }, Mixin);\n});\nScoped.define(\"module:Functions\", [\n    \"module:Time\",\n    \"module:Types\"\n], function(Time, Types) {\n\n    /**\n     * Function and Function Argument Support\n     * \n     * @module BetaJS.Functions\n     */\n    return {\n\n        /**\n         * Returns the current stack trace.\n         * \n         * @param {int} index optional stack trace start index\n         * \n         * @return {array} stack trace array\n         */\n        getStackTrace: function(index) {\n            var stack = (new Error()).stack.split(\"\\n\");\n            while (stack.length > 0 && stack[0].trim().toLowerCase() === \"error\")\n                stack.shift();\n            return index ? stack.slice(index) : stack;\n        },\n\n        /**\n         * Takes a function and an instance and returns the method call as a function\n         * \n         * @param {function} func function\n         * @param {object} instance instance\n         * @return method call \n         */\n        as_method: function(func, instance) {\n            return function() {\n                return func.apply(instance, arguments);\n            };\n        },\n\n        /**\n         * Takes a function name and returns the method call on the global object as a function\n         *\n         * @param {function} func function\n         * @return method call\n         */\n        global_method: function(func) {\n            var f = Scoped.getGlobal(func);\n            return f ? this.as_method(f, Scoped.getGlobal()) : f;\n        },\n\n\n        /**\n         * Takes a function and returns a function that calls the original function on the first call and returns the return value on all subsequent call. In other words a lazy function cache.\n         * \n         * @param {function} func function\n         * @return cached function \n         */\n        once: function(func) {\n            var result = false;\n            var executed = false;\n            return function() {\n                if (executed)\n                    return result;\n                executed = true;\n                result = func.apply(this, arguments);\n                func = null;\n                return result;\n            };\n        },\n\n\n        /**\n         * Converts some other function's arguments to an array\n         * \n         * @param args function arguments\n         * @param {integer} slice number of arguments to be omitted (default: 0)\n         * @return {array} arguments as array \n         */\n        getArguments: function(args, slice) {\n            return Array.prototype.slice.call(args, slice || 0);\n        },\n\n\n        /**\n         * Matches functions arguments against some pattern\n         * \n         * @param args function arguments\n         * @param {integer} skip number of arguments to be omitted (default: 0) \n         * @param {object} pattern typed pattern\n         * @return {object} matched arguments as associative array \n         */\n        matchArgs: function(args, skip, pattern) {\n            if (arguments.length < 3) {\n                pattern = skip;\n                skip = 0;\n            }\n            var i = skip;\n            var result = {};\n            for (var key in pattern) {\n                var config = pattern[key];\n                if (config === true)\n                    config = {\n                        required: true\n                    };\n                else if (typeof config == \"string\")\n                    config = {\n                        type: config\n                    };\n                if (config.required || (config.type && Types.type_of(args[i]) == config.type)) {\n                    result[key] = args[i];\n                    i++;\n                } else if (config.def) {\n                    result[key] = Types.is_function(config.def) ? config.def(result) : config.def;\n                }\n            }\n            return result;\n        },\n\n\n        /**\n         * Creates a function for creating new instances of a class.\n         *  \n         * @param {object} cls Class\n         * @return {function} class instantiation function \n         * @suppress {checkTypes}\n         */\n        newClassFunc: function(cls) {\n            return function() {\n                var args = arguments;\n\n                function F() {\n                    return cls.apply(this, args);\n                }\n                F.prototype = cls.prototype;\n                return new F();\n            };\n        },\n\n\n        /**\n         * Creates a new class instance with arguments.\n         *  \n         * @param {object} cls Class\n         * @return {function} class instance \n         */\n        newClass: function(cls) {\n            return this.newClassFunc(cls).apply(this, this.getArguments(arguments, 1));\n        },\n\n\n        /**\n         * Call an object method.\n         *  \n         * @param {object} context object instance\n         * @param method function or string of method\n         * @return result of function call \n         */\n        callWithin: function(context, method) {\n            if (Types.is_string(method))\n                method = context[method];\n            return method.apply(context, this.getArguments(arguments, 2));\n        },\n\n        /**\n         * Takes an argument function and returns a new function. The returned function will trigger the argument function at most once every 'wait' ms, no matter how many times it's called.\n         *\n         * @param {function} func - the argument function\n         * @param {number} wait - delay (in ms) between each call to argument function\n         * @return {function} the returned function\n         */\n        throttle: function(func, wait) {\n            var args, context, previous = 0;\n\n            var throttled = function() {\n                var now = Time.now();\n                var nextCall = previous + wait - now;\n                context = this;\n                args = arguments;\n                if (nextCall <= 0) {\n                    previous = now;\n                    return func.apply(context, args);\n                }\n            };\n\n            return throttled;\n        },\n\n        /**\n         * Takes an argument function and returns a new function. If the returned function is called multiple times in sequence, the argument function will only be triggered once.\n         *\n         * @param {function} func - argument function\n         * @param {number} wait - time delay (in ms) that defines the end of a sequence\n         * @param {boolean} immediate - should trigger argument function immediately instead of waiting until the end of the sequence\n         * @return {function} returned function\n         */\n        debounce: function(func, wait, immediate) {\n            var args, context, timeout;\n\n            var later = function() {\n                var delay = Time.now() - lastCall;\n                if (delay < wait) {\n                    timeout = setTimeout(later, wait - delay);\n                    return;\n                }\n                timeout = null;\n                if (!immediate) func.apply(context, args);\n            };\n\n            var debounced = function() {\n                context = this;\n                args = arguments;\n                lastCall = Time.now();\n                if (!timeout) {\n                    timeout = setTimeout(later, wait);\n                    if (immediate) func.apply(this, arguments);\n                }\n            };\n\n            return debounced;\n        }\n\n    };\n});\nScoped.define(\"module:Events.HooksMixin\", [\n    \"module:Promise\",\n    \"module:Functions\"\n], function(Promise, Functions) {\n\n    var sequential = function(promise, funcs) {\n        if (funcs.length > 0) {\n            return promise.mapSuccess(function(result) {\n                var func = funcs.shift();\n                return sequential(Promise.value(func(result)), funcs);\n            });\n        } else\n            return promise;\n    };\n\n    /**\n     * Hooks Mixin\n     * \n     * @mixin BetaJS.Events.HooksMixin\n     */\n    return {\n\n        _implements: \"e07d77f0-d9d5-41dc-ae4d-20fb8af0a334\",\n\n        _notifications: {\n            \"construct\": function() {\n                this.__methodHooks = {};\n            }\n        },\n\n        registerHook: function(method, func, ctx) {\n            this.__methodHooks[method] = this.__methodHooks[method] || [];\n            this.__methodHooks[method].push(Functions.as_method(func, ctx || this));\n        },\n\n        invokeHook: function(method, result) {\n            return sequential(Promise.value(result), this.__methodHooks[method] || []);\n        }\n\n    };\n});\nScoped.define(\"module:Ids\", [\n    \"module:Types\",\n    \"module:Objs\"\n], function(Types, Objs) {\n\n    /**\n     * Id Generation\n     * \n     * @module BetaJS.Ids\n     */\n    return {\n\n        __uniqueId: 0,\n\n\n        /**\n         * Returns a unique identifier\n         * \n         * @param {string} prefix a prefix string for the identifier (optional)\n         * @return {string} unique identifier\n         */\n        uniqueId: function(prefix) {\n            return (prefix || \"\") + (this.__uniqueId++);\n        },\n\n\n        /**\n         * Returns the object's unique identifier or sets it\n         * \n         * @param {object} object the object\n         * @param {string} id (optional)\n         * @return {string} object's unique identifier\n         */\n        objectId: function(object, id) {\n            if (!object)\n                return undefined;\n            if (id !== undefined)\n                object.__cid = id;\n            else if (!object.__cid)\n                object.__cid = this.uniqueId(\"cid_\");\n            return object.__cid;\n        },\n\n        /**\n         * Returns a unique key for any given value of any type.\n         * This is not a hash value.\n         * \n         * @param value a value to generate a unique key\n         * @param {int} depth optional depth for exploring by value instead of by reference\n         * @return unique key\n         */\n        uniqueKey: function(value, depth) {\n            if (depth && depth > 0 && (Types.is_object(value) || Types.is_array(value))) {\n                return JSON.stringify(Objs.map(value, function(x) {\n                    return this.uniqueKey(x, depth - 1);\n                }, this));\n            }\n            if ((value !== null && Types.is_object(value)) || Types.is_array(value) || Types.is_function(value))\n                return this.objectId(value);\n            return value;\n        }\n\n    };\n});\n\n\nScoped.define(\"module:IdGenerators.IdGenerator\", [\"module:Class\"], function(Class, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, {\n\n        generate: function(ctx) {},\n\n        valid: function(id, ctx) {\n            return false;\n        }\n\n    });\n});\n\n\nScoped.define(\"module:IdGenerators.PrefixedIdGenerator\", [\"module:IdGenerators.IdGenerator\"], function(IdGenerator, scoped) {\n    return IdGenerator.extend({\n        scoped: scoped\n    }, function(inherited) {\n        return {\n\n            constructor: function(prefix, generator) {\n                inherited.constructor.call(this);\n                this.__prefix = prefix;\n                this.__generator = generator;\n            },\n\n            generate: function(ctx) {\n                return this.__prefix + this.__generator.generate(ctx);\n            },\n\n            valid: function(id, ctx) {\n                return id.indexOf(this.__prefix) === 0 && this.__generator.valid(id.substring(this.__prefix.length), ctx);\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:IdGenerators.RandomIdGenerator\", [\"module:IdGenerators.IdGenerator\", \"module:Tokens\"], function(IdGenerator, Tokens, scoped) {\n    return IdGenerator.extend({\n        scoped: scoped\n    }, function(inherited) {\n        return {\n\n            constructor: function(length) {\n                inherited.constructor.call(this);\n                this.__length = length || 16;\n            },\n\n            generate: function(ctx) {\n                return Tokens.generate_token(this.__length);\n            },\n\n            valid: function(id, ctx) {\n                return id.length === this.__length;\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:IdGenerators.ConsecutiveIdGenerator\", [\"module:IdGenerators.IdGenerator\"], function(IdGenerator, scoped) {\n    return IdGenerator.extend({\n        scoped: scoped\n    }, function(inherited) {\n        return {\n\n            constructor: function(initial) {\n                inherited.constructor.call(this);\n                this.__current = initial || 0;\n            },\n\n            generate: function(ctx) {\n                this.__current++;\n                return this.__current;\n            },\n\n            valid: function(id, ctx) {\n                return !isNaN(id);\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:IdGenerators.TimedIdGenerator\", [\"module:IdGenerators.IdGenerator\", \"module:Time\"], function(IdGenerator, Time, scoped) {\n    return IdGenerator.extend({\n        scoped: scoped\n    }, function(inherited) {\n        return {\n\n            constructor: function() {\n                inherited.constructor.call(this);\n                this.__current = Time.now() - 1;\n            },\n\n            generate: function(ctx) {\n                var now = Time.now();\n                this.__current = now > this.__current ? now : (this.__current + 1);\n                return this.__current;\n            },\n\n            valid: function(id, ctx) {\n                return !isNaN(id);\n            }\n\n        };\n    });\n});\nScoped.define(\"module:KeyValue.KeyValueStore\", [\n    \"module:Class\",\n    \"module:Events.EventsMixin\"\n], function(Class, EventsMixin, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [EventsMixin, function(inherited) {\n\n        /**\n         * Abstract Key Value Store\n         * \n         * @class BetaJS.KeyValue.KeyValueStore\n         */\n        return {\n\n            /**\n             * Determines whether a key exists in the store.\n             * \n             * @param {string} key key to check\n             * \n             * @return {boolean} true if key exists\n             */\n            mem: function(key) {\n                return this._mem(key);\n            },\n\n            /**\n             * Returns the value for a key in the store.\n             * \n             * @param {string} key key to get the value for\n             * \n             * @return value of key\n             */\n            get: function(key) {\n                return this._get(key);\n            },\n\n            /**\n             * Sets the value of a key in the store.\n             * \n             * @param {string} key key to set the value for\n             * @param value new value for key\n             * @fires BetaJS.KeyValue.KeyValueStore#change\n             */\n            set: function(key, value) {\n                this._set(key, value);\n                /**\n                 * @event BetaJS.KeyValue.KeyValueStore#change\n                 */\n                this.trigger(\"change:\" + key, value);\n            },\n\n            /**\n             * Removes a key from the store\n             * \n             * @param {string} key key to be removed\n             */\n            remove: function(key) {\n                this._remove(key);\n            }\n\n        };\n    }]);\n});\n\n\nScoped.define(\"module:KeyValue.PrefixKeyValueStore\", [\n    \"module:KeyValue.KeyValueStore\"\n], function(KeyValueStore, scoped) {\n    return KeyValueStore.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * A delegated Key-Value-Store by automatically prefixing keys.\n         * \n         * @class BetaJS.KeyValue.PrefixKeyValueStore\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {object} kv Underlying Key-Value store\n             * @param {string} prefix prefix string to be used for all keys\n             */\n            constructor: function(kv, prefix) {\n                inherited.constructor.call(this);\n                this.__kv = kv;\n                this.__prefix = prefix;\n            },\n\n            /**\n             * @override\n             */\n            _mem: function(key) {\n                return this.__kv.mem(this.__prefix + key);\n            },\n\n            /**\n             * @override\n             */\n            _get: function(key) {\n                return this.__kv.get(this.__prefix + key);\n            },\n\n            /**\n             * @override\n             */\n            _set: function(key, value) {\n                this.__kv.set(this.__prefix + key, value);\n            },\n\n            /**\n             * @override\n             */\n            _remove: function(key) {\n                this.__kv.remove(this.__prefix + key);\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:KeyValue.MemoryKeyValueStore\", [\n    \"module:KeyValue.KeyValueStore\",\n    \"module:Objs\"\n], function(KeyValueStore, Objs, scoped) {\n    return KeyValueStore.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * A Memory-based Key-Value-Store.\n         * \n         * @class BetaJS.KeyValue.MemoryKeyValueStore\n         */\n        return {\n\n            /**\n             * Creates a new Memory KV-Store\n             * \n             * @param {object} data Initial data object\n             * @param {boolean} clone Should the initial data object be cloned or used directly (default: false)\n             */\n            constructor: function(data, clone) {\n                inherited.constructor.call(this);\n                this.__data = Objs.clone(data, clone ? 1 : 0);\n            },\n\n            /**\n             * @override\n             */\n            _mem: function(key) {\n                return key in this.__data;\n            },\n\n            /**\n             * @override\n             */\n            _get: function(key) {\n                return this.__data[key];\n            },\n\n            /**\n             * @override\n             */\n            _set: function(key, value) {\n                this.__data[key] = value;\n            },\n\n            /**\n             * @override\n             */\n            _remove: function(key) {\n                delete this.__data[key];\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:KeyValue.DefaultKeyValueStore\", [\n    \"module:KeyValue.KeyValueStore\"\n], function(KeyValueStore, scoped) {\n    return KeyValueStore.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * A delegated KV-Store falling back to a default KV-Store if a key is not defined.\n         * \n         * @class BetaJS.KeyValue.DefaultKeyValueStore\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {object} kv The main underlying key value store\n             * @param {object} def The default key value store that we fallback to if a key is not defined in the main key value store\n             */\n            constructor: function(kv, def) {\n                inherited.constructor.call(this);\n                this.__kv = kv;\n                this.__def = def;\n            },\n\n            /**\n             * @override\n             */\n            _mem: function(key) {\n                return this.__kv.mem(key) || this.__def.mem(key);\n            },\n\n            /**\n             * @override\n             */\n            _get: function(key) {\n                return this.__kv.mem(key) ? this.__kv.get(key) : this.__def.get(key);\n            },\n\n            /**\n             * @override\n             */\n            _set: function(key, value) {\n                this.__kv.set(key, value);\n            },\n\n            /**\n             * @override\n             */\n            _remove: function(key) {\n                this.__kv.remove(key);\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Lists.AbstractList\", [\n    \"module:Class\",\n    \"module:Objs\",\n    \"module:Types\",\n    \"module:Iterators.ArrayIterator\"\n], function(Class, Objs, Types, ArrayIterator, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Abstract List Class\n         * \n         * @class BetaJS.Lists.AbstractList\n         */\n        return {\n\n            /**\n             * Add an object to the list.\n             * \n             * @param {object} object Object to be added\n             * @return {string} ident of object\n             */\n            _add: function(object) {},\n\n            /**\n             * Remove an object from the list.\n             * \n             * @param {string} ident Ident of object to be removed.\n             * @return {object} removed object\n             */\n            _remove: function(ident) {},\n\n            /**\n             * Get an object by ident.\n             * \n             * @param {string} ident Ident of object\n             * @return {object} object matching the ident\n             */\n            _get: function(ident) {},\n\n            /**\n             * Iterate over all objects in the list.\n             * \n             * @param {function} callback callback function for iteration\n             * @param {object} context optional context for callback function\n             */\n            _iterate: function(callback, context) {},\n\n            /**\n             * Given an object, return the ident of the object.\n             * \n             * @param {object} object object in question\n             * @return {string} ident of object\n             */\n            get_ident: function(object) {\n                var ident = null;\n                this._iterate(function(obj, id) {\n                    if (obj == object) {\n                        ident = id;\n                        return false;\n                    }\n                    return true;\n                });\n                return ident;\n            },\n\n            /**\n             * Determines whether an object exists in the list.\n             * \n             * @param {object} object object in question\n             * @return {boolean} true if object is contained in list\n             */\n            exists: function(object) {\n                return object && this.get_ident(object) !== null;\n            },\n\n            /**\n             * Notification when an object obtains a new ident.\n             * \n             * @param {object} object object in question\n             * @param {string} new_ident new identifier of object\n             */\n            _ident_changed: function(object, new_ident) {},\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {array} objects optional array of initial objects to be added to the list\n             */\n            constructor: function(objects) {\n                inherited.constructor.call(this);\n                this.__count = 0;\n                if (objects) {\n                    Objs.iter(objects, function(object) {\n                        this.add(object);\n                    }, this);\n                }\n            },\n\n            /**\n             * Add an object to the list.\n             * \n             * @param {object} object Object to be added\n             * @return {string} ident of object\n             */\n            add: function(object) {\n                var ident = this._add(object);\n                if (Types.is_defined(ident))\n                    this.__count++;\n                return ident;\n            },\n\n            /**\n             * Returns the number of objects contained in the list.\n             * \n             * @return {int} number of objects\n             */\n            count: function() {\n                return this.__count;\n            },\n\n            /**\n             * Removes all objects from the list.\n             * \n             */\n            clear: function() {\n                this._iterate(function(object, ident) {\n                    this.remove_by_ident(ident);\n                    return true;\n                }, this);\n            },\n\n            /**\n             * Remove an object from the list by identifier.\n             * \n             * @param {string} ident Ident of object to be removed.\n             * @return {object} removed object\n             */\n            remove_by_ident: function(ident) {\n                var ret = this._remove(ident);\n                if (Types.is_defined(ret))\n                    this.__count--;\n                return ret;\n            },\n\n            /**\n             * Remove an object from the list.\n             * \n             * @param {object} object object in question\n             * @return {object} removed object\n             */\n            remove: function(object) {\n                return this.remove_by_ident(this.get_ident(object));\n            },\n\n            /**\n             * Remove objects from the list that match a filter function.\n             * \n             * @param {function} filter filter function for object\n             */\n            remove_by_filter: function(filter) {\n                this._iterate(function(object, ident) {\n                    if (filter(object))\n                        this.remove_by_ident(ident);\n                    return true;\n                }, this);\n            },\n\n            /**\n             * Get an object by ident.\n             * \n             * @param {string} ident Ident of object\n             * @return {object} object matching the ident\n             */\n            get: function(ident) {\n                return this._get(ident);\n            },\n\n            /**\n             * Iterate over all objects in the list.\n             * \n             * @param {function} callback callback function for iteration\n             * @param {object} context optional context for callback function\n             */\n            iterate: function(cb, context) {\n                this._iterate(function(object, ident) {\n                    var ret = cb.call(this, object, ident);\n                    return Types.is_defined(ret) ? ret : true;\n                }, context);\n            },\n\n            /**\n             * Creates an iterator for the list.\n             * \n             * @return {object} iterator for list\n             */\n            iterator: function() {\n                return ArrayIterator.byIterate(this.iterate, this);\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Lists.LinkedList\", [\n    \"module:Lists.AbstractList\"\n], function(AbstractList, scoped) {\n    return AbstractList.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Linked List Implementation of List\n         * \n         * @class BetaJS.Lists.LinkedList\n         */\n        return {\n\n            __first: null,\n            __last: null,\n\n            /**\n             * @override\n             */\n            _add: function(obj) {\n                this.__last = {\n                    obj: obj,\n                    prev: this.__last,\n                    next: null\n                };\n                if (this.__first)\n                    this.__last.prev.next = this.__last;\n                else\n                    this.__first = this.__last;\n                return this.__last;\n            },\n\n            /**\n             * @override\n             */\n            _remove: function(container) {\n                if (container.next)\n                    container.next.prev = container.prev;\n                else\n                    this.__last = container.prev;\n                if (container.prev)\n                    container.prev.next = container.next;\n                else\n                    this.__first = container.next;\n                return container.obj;\n            },\n\n            /**\n             * @override\n             */\n            _get: function(container) {\n                return container.obj;\n            },\n\n            /**\n             * @override\n             */\n            _iterate: function(cb, context) {\n                var current = this.__first;\n                while (current) {\n                    var prev = current;\n                    current = current.next;\n                    if (!cb.apply(context || this, [prev.obj, prev]))\n                        return;\n                }\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Lists.ObjectIdList\", [\n    \"module:Lists.AbstractList\",\n    \"module:Ids\"\n], function(AbstractList, Ids, scoped) {\n    return AbstractList.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Object Id List Class\n         * \n         * @class BetaJS.Lists.ObjectIdList\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {array} objects optional initial set of objects\n             * @param {function} id_generator optional id generating function\n             */\n            constructor: function(objects, id_generator) {\n                this.__map = {};\n                this.__id_generator = id_generator;\n                inherited.constructor.call(this, objects);\n            },\n\n            /**\n             * @override\n             */\n            _add: function(object) {\n                var id = object.__cid;\n                if (!id) {\n                    while (true) {\n                        id = this.__id_generator ? Ids.objectId(object, this.__id_generator()) : Ids.objectId(object);\n                        if (!this.__map[id] || !this.__id_generator)\n                            break;\n                    }\n                }\n                this.__map[id] = object;\n                return id;\n            },\n\n            /**\n             * @override\n             */\n            _remove: function(ident) {\n                var obj = this.__map[ident];\n                delete this.__map[ident];\n                return obj;\n            },\n\n            /**\n             * @override\n             */\n            _get: function(ident) {\n                return this.__map[ident];\n            },\n\n            /**\n             * @override\n             */\n            _iterate: function(callback, context) {\n                for (var key in this.__map)\n                    callback.apply(context || this, [this.__map[key], key]);\n            },\n\n            /**\n             * @override\n             */\n            get_ident: function(object) {\n                var ident = Ids.objectId(object);\n                return this.__map[ident] ? ident : null;\n            }\n\n        };\n    });\n});\n\n\n\nScoped.define(\"module:Lists.ArrayList\", [\"module:Lists.AbstractList\", \"module:Ids\", \"module:Objs\"], function(AbstractList, Ids, Objs, scoped) {\n    return AbstractList.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Array List Class\n         * \n         * @class BetaJS.Lists.ArrayList\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {array} objects optional initial set of objects\n             * @param {options} options optional options parameter\n             */\n            constructor: function(objects, options) {\n                this.__idToIndex = {};\n                this.__items = [];\n                options = options || {};\n                if (\"compare\" in options)\n                    this._compare = options.compare;\n                if (\"get_ident\" in options)\n                    this._get_ident = options.get_ident;\n                inherited.constructor.call(this, objects);\n            },\n\n            /**\n             * Set current compare function.\n             * \n             * @param {function} compare compare function\n             */\n            set_compare: function(compare) {\n                this._compare = compare;\n                if (compare)\n                    this.sort();\n            },\n\n            /**\n             * Get current compare function.\n             * \n             * @return {function} current compare function\n             */\n            get_compare: function() {\n                return this._compare;\n            },\n\n            /**\n             * Sort list using a compare function.\n             * \n             * @param {function} compare compare function\n             */\n            sort: function(compare) {\n                compare = compare || this._compare;\n                if (!compare)\n                    return;\n                this.__items.sort(compare);\n                for (var i = 0; i < this.__items.length; ++i)\n                    this.__ident_changed(this.__items[i], i);\n                this._sorted();\n            },\n\n            _sorted: function() {},\n\n            /**\n             * Reindex the index of an item.\n             * \n             * @param {int} index index of the item\n             * \n             * @return {int} new index of the item\n             */\n            re_index: function(index) {\n                if (!this._compare)\n                    return index;\n                var last = this.__items.length - 1;\n                var object = this.__items[index];\n                var i = index;\n                while (i < last && this._compare(this.__items[i], this.__items[i + 1]) > 0) {\n                    this.__items[i] = this.__items[i + 1];\n                    this.__ident_changed(this.__items[i], i);\n                    this.__items[i + 1] = object;\n                    ++i;\n                }\n                if (i == index) {\n                    while (i > 0 && this._compare(this.__items[i], this.__items[i - 1]) < 0) {\n                        this.__items[i] = this.__items[i - 1];\n                        this.__ident_changed(this.__items[i], i);\n                        this.__items[i - 1] = object;\n                        --i;\n                    }\n                }\n                if (i != index) {\n                    this.__ident_changed(object, i);\n                    this._re_indexed(object);\n                }\n                return i;\n            },\n\n            _re_indexed: function(object) {},\n\n            __objectId: function(object) {\n                return this._get_ident ? this._get_ident(object) : Ids.objectId(object);\n            },\n\n            /**\n             * @override\n             */\n            _add: function(object) {\n                var last = this.__items.length;\n                this.__items.push(object);\n                var i = this.re_index(last);\n                this.__idToIndex[this.__objectId(object)] = i;\n                return i;\n            },\n\n            /**\n             * @override\n             */\n            _remove: function(ident) {\n                var obj = this.__items[ident];\n                for (var i = ident + 1; i < this.__items.length; ++i) {\n                    this.__items[i - 1] = this.__items[i];\n                    this.__ident_changed(this.__items[i - 1], i - 1);\n                }\n                this.__items.pop();\n                delete this.__idToIndex[this.__objectId(obj)];\n                return obj;\n            },\n\n            /**\n             * @override\n             */\n            _get: function(ident) {\n                return this.__items[ident];\n            },\n\n            /**\n             * @override\n             */\n            _iterate: function(callback, context) {\n                var items = Objs.clone(this.__items, 1);\n                for (var i = 0; i < items.length; ++i)\n                    callback.apply(context || this, [items[i], this.get_ident(items[i])]);\n            },\n\n            __ident_changed: function(object, index) {\n                this.__idToIndex[this.__objectId(object)] = index;\n                this._ident_changed(object, index);\n            },\n\n            /**\n             * @override\n             */\n            get_ident: function(object) {\n                var id = this.__objectId(object);\n                return id in this.__idToIndex ? this.__idToIndex[id] : null;\n            },\n\n            /**\n             * Returns the identifier given an id.\n             * \n             * @param {string} id id\n             * \n             * @return {string} identifier\n             */\n            ident_by_id: function(id) {\n                return this.__idToIndex[id];\n            }\n\n        };\n    });\n});\nScoped.define(\"module:MediaTypes\", [\n    \"module:Objs\",\n    \"module:Types\"\n], function(Objs, Types) {\n\n    /**\n     * Helper module for working with media types (MIME types)\n     *\n     * @module BetaJS.MediaTypes\n     */\n    return {\n\n        /**\n         * Get first matching extension for media type.\n         *\n         * @param {string} mediaType\n         *\n         * @returns {string} extension that matches given media type.\n         */\n        getExtension: function(mediaType) {\n            var extensions = this.getExtensions(mediaType);\n            return extensions && Objs.peek(extensions);\n        },\n\n        /**\n         * Get all matching extensions for media type.\n         *\n         * @param {string} mediaType\n         *\n         * @return {Array} array of extensions that match given media type.\n         */\n        getExtensions: function(mediaType) {\n            if (!Types.is_string(mediaType) || mediaType.length == 0) {\n                return false;\n            }\n            return this._getAll()[mediaType.split(';')[0].toLowerCase()] || false;\n        },\n\n        /**\n         * Returns content type from path or extension.\n         *\n         * @param {string} path\n         *\n         * @return {string} media type\n         */\n        getType: function(path) {\n            if (!Types.is_string(path)) {\n                return false;\n            }\n            return this._getAll()[path.split(\".\").pop().toLowerCase()] || false;\n        },\n\n        _getAll: function() {\n            if (!this._DB) {\n                this._DB = Objs.bidirectionalMap(this._types);\n            }\n            return this._DB;\n        },\n\n        _types: {\n            \"application/vnd.apple.mpegurl\": [\"m3u8\"],\n            \"audio/midi\": [\"midi\", \"mid\", \"kar\"],\n            \"audio/mpeg\": [\"mp3\"],\n            \"audio/ogg\": [\"ogg\"],\n            \"audio/webm\": [\"weba\"],\n            \"audio/x-aac\": [\"aac\"],\n            \"audio/x-flac\": [\"flac\"],\n            \"audio/x-m4a\": [\"m4a\"],\n            \"audio/x-realaudio\": [\"ra\"],\n            \"audio/x-wav\": [\"wav\"],\n            \"audio/x-ms-wma\": [\"wma\"],\n            \"image/gif\": [\"gif\"],\n            \"image/jpeg\": [\"jpeg\", \"jpg\"],\n            \"image/png\": [\"png\"],\n            \"image/svg+xml\": [\"svg\", \"svgz\"],\n            \"image/tiff\": [\"tif\", \"tiff\"],\n            \"image/vnd.wap.wbmp\": [\"wbmp\"],\n            \"image/webp\": [\"webp\"],\n            \"image/x-icon\": [\"ico\"],\n            \"image/x-jng\": [\"jng\"],\n            \"image/x-ms-bmp\": [\"bmp\"],\n            \"video/3gpp\": [\"3gpp\", \"3gp\"],\n            \"video/3gpp2\": [\"3g2\"],\n            \"video/mp2t\": [\"ts\"],\n            \"video/mp4\": [\"mp4\"],\n            \"video/mpeg\": [\"mpeg\", \"mpg\"],\n            \"video/quicktime\": [\"mov\"],\n            \"video/webm\": [\"webm\"],\n            \"video/x-flv\": [\"flv\"],\n            \"video/x-m4v\": [\"m4v\"],\n            \"video/x-matroska\": [\"mkv\", \"mk3d\", \"mks\"],\n            \"video/x-mng\": [\"mng\"],\n            \"video/x-ms-asf\": [\"asx\", \"asf\"],\n            \"video/x-ms-wmv\": [\"wmv\"],\n            \"video/x-msvideo\": [\"avi\"]\n        }\n    };\n});\nScoped.define(\"module:Objs\", [\n    \"module:Types\",\n    \"module:Functions\"\n], function(Types, Functions) {\n\n    /**\n     * Object and Array Manipulation Routines\n     * \n     * @module BetaJS.Objs\n     */\n    return {\n\n        /**\n         * Return the i-th key of an object.\n         * \n         * @param {object} obj the object\n         * @param {int} i index of the i-th key (default: 0)\n         * \n         * @return {string} i-th key\n         */\n        ithKey: function(obj, i) {\n            i = i || 0;\n            for (var key in obj) {\n                if (i <= 0)\n                    return key;\n                else --i;\n            }\n            return null;\n        },\n\n        /**\n         * Return the i-th value of an object.\n         * \n         * @param {object} obj the object\n         * @param {int} i index of the i-th value (default: 0)\n         * \n         * @return {string} i-th value\n         */\n        ithValue: function(obj, i) {\n            i = i || 0;\n            for (var key in obj) {\n                if (i <= 0)\n                    return obj[key];\n                else --i;\n            }\n            return null;\n        },\n\n        /**\n         * Return the i-th value of an object or array.\n         * \n         * @param obj the object or array\n         * @param {int} idx index of the i-th value (default: 0)\n         * \n         * @return {string} i-th value\n         */\n        valueByIndex: function(obj, idx) {\n            return Types.is_array(obj) ? obj[idx || 0] : this.ithValue(obj, idx);\n        },\n\n        /**\n         * Return the i-th key of an object or array.\n         * \n         * @param obj the object or array\n         * @param {int} idx index of the i-th key (default: 0)\n         * \n         * @return i-th key\n         */\n        keyByIndex: function(obj, idx) {\n            return Types.is_array(obj) ? idx || 0 : this.ithKey(obj, idx);\n        },\n\n        /**\n         * Returns the number of elements of an object or array.\n         * \n         * @param obj object or array\n         * \n         * @return {int} number of elements\n         */\n        count: function(obj) {\n            if (Types.is_array(obj))\n                return obj.length;\n            else {\n                var c = 0;\n                for (var key in obj)\n                    c++;\n                return c;\n            }\n        },\n\n        /**\n         * Clone an object or array up to a certain depth.\n         * \n         * @param item object or array\n         * @param {int} depth depth until to clone it (default 0)\n         * \n         * @return cloned object or array\n         */\n        clone: function(item, depth) {\n            if (!item || !depth || depth === 0)\n                return item;\n            if (Types.is_array(item))\n                return item.slice(0);\n            else if (Types.is_object(item))\n                return this.extend({}, item, depth - 1);\n            else\n                return item;\n        },\n\n        /**\n         * Acyclicly clone an object.\n         * \n         * @param {object} object source object\n         * \n         * @return acyclic cloned object\n         */\n        acyclic_clone: function(object) {\n            if (object === null || !Types.is_object(object))\n                return object;\n            var s = \"__acyclic_cloned\";\n            if (object[s])\n                return object[s];\n            var result = {};\n            object[s] = result;\n            for (var key in object)\n                if (key !== s)\n                    result[key] = this.acyclic_clone(object[key]);\n            delete object[s];\n            return result;\n        },\n\n        /**\n         * Extend target object by source object, modifying target object in-place.\n         * \n         * @param {object} target target object\n         * @param {object} source source object\n         * @param {int} depth optional depth for cloning source values\n         * \n         * @return {object} target object\n         */\n        extend: function(target, source, depth) {\n            target = target || {};\n            if (source) {\n                for (var key in source)\n                    target[key] = this.clone(source[key], depth);\n            }\n            return target;\n        },\n\n        /**\n         * Extend target object by source objects, modifying target object in-place.\n         *\n         */\n        multi_extend: function() {\n            var args = Functions.getArguments(arguments);\n            var depth;\n            if (!Types.is_object(args[args.length - 1])) {\n                depth = args[args.length - 1];\n                args.pop();\n            }\n            while (args.length > 1) {\n                args[1] = this.extend(args[0], args[1], depth);\n                args.shift();\n            }\n            return args[0];\n        },\n\n        /**\n         * Weakly extend target object by source object, modifying target object in-place.\n         * If a key already exists within the target object, it is not overwritten by source.\n         * \n         * @param {object} target target object\n         * @param {object} source source object\n         * @param {int} depth optional depth for cloning source values\n         * \n         * @return {object} target object\n         */\n        weak_extend: function(target, source, depth) {\n            target = target || {};\n            if (source) {\n                for (var key in source) {\n                    if (!(key in target))\n                        target[key] = this.clone(source[key], depth);\n                }\n            }\n            return target;\n        },\n\n        /**\n         * Extend target object by source object recursively, modifying target object in-place.\n         * \n         * @param {object} target target object\n         * @param {object} source source object\n         * @param {int} depth optional depth for cloning source values\n         * \n         * @return {object} target object\n         */\n        tree_extend: function(target, source, depth) {\n            target = target || {};\n            if (source) {\n                for (var key in source) {\n                    if (key in target && Types.is_object(target[key]) && Types.is_object(source[key]) && !Types.is_array(target[key]) && !Types.is_array(source[key]))\n                        target[key] = this.tree_extend(target[key], source[key], depth);\n                    else\n                        target[key] = this.clone(source[key], depth);\n                }\n            }\n            return target;\n        },\n\n        /**\n         * Returns the keys of an object.\n         * If mapped is given, an object is returned with all keys mapped to mapped. Otherwise, an array is returned.\n         * \n         * @param {object} object source object\n         * @param mapped optional value\n         * \n         * @return keys as array or as an object\n         */\n        keys: function(obj, mapped) {\n            var result = null;\n            var key = null;\n            if (Types.is_undefined(mapped)) {\n                result = [];\n                for (key in obj)\n                    result.push(key);\n                return result;\n            } else {\n                result = {};\n                for (key in obj)\n                    result[key] = mapped;\n                return result;\n            }\n        },\n\n        /**\n         * Returns true if all key-value-pairs of the first object are contained in the second object.\n         * \n         * @param a first object or array\n         * @param b second object or array\n         * \n         * @return {boolean} true if first contained in second\n         */\n        subset_of: function(a, b) {\n            a = Types.is_array(a) ? this.objectify(a) : a;\n            b = Types.is_array(b) ? this.objectify(b) : b;\n            for (var key in a)\n                if (a[key] != b[key])\n                    return false;\n            return true;\n        },\n\n        /**\n         * Returns true if all key-value-pairs of the second object are contained in the first object.\n         * \n         * @param a first object or array\n         * @param b second object or array\n         * \n         * @return {boolean} true if second contained in first\n         */\n        superset_of: function(a, b) {\n            return this.subset_of(b, a);\n        },\n\n        /**\n         * Converts an array into an object by pairing together odd and even items.\n         * \n         * @param {array} arr array with pairs\n         * \n         * @return {object} created object\n         */\n        pairArrayToObject: function(arr) {\n            var result = {};\n            for (var i = 0; i < arr.length / 2; i += 2)\n                result[arr[i]] = arr[i + 1];\n            return result;\n        },\n\n        /**\n         * Converts a list of arguments into an object by pairing together odd and even arguments.\n         * \n         * @return {object} created object\n         */\n        pairsToObject: function() {\n            var result = {};\n            for (var i = 0; i < arguments.length; ++i)\n                result[arguments[i][0]] = arguments[i][1];\n            return result;\n        },\n\n        /**\n         * Inverses the key-value pairs in an object.\n         * \n         * @param {object} obj object to be reversed\n         * @return {object} object with reversed key-value-pairs\n         */\n        inverseKeyValue: function(obj) {\n            var result = {};\n            this.iter(obj, function(value, key) {\n                result[value] = key;\n            });\n            return result;\n        },\n\n        /**\n         * Returns true if an entry in an object or array exists.\n         * \n         * @param obj object or array\n         * @param {function} f function to check for an entry to exist\n         * @param {object} context optional context for the function\n         * \n         * @return {boolean} returns true if an entry exists\n         * \n         */\n        exists: function(obj, f, context) {\n            var success = false;\n            this.iter(obj, function() {\n                success = success || f.apply(this, arguments);\n                return !success;\n            }, context);\n            return success;\n        },\n\n        /**\n         * Returns true if all entries in an object or array satisfy a condition\n         * \n         * @param obj object or array\n         * @param {function} f function to check for the condition\n         * @param {object} context optional context for the function\n         * \n         * @return {boolean} returns true if all entries satisfy the condition\n         * \n         */\n        all: function(obj, f, context) {\n            var success = true;\n            this.iter(obj, function() {\n                success = success && f.apply(this, arguments);\n                return success;\n            }, context);\n            return success;\n        },\n\n        /**\n         * Returns the first entry of an object or array.\n         * \n         * @param obj object or array\n         * \n         * @return first entry\n         */\n        peek: function(obj) {\n            if (Types.is_array(obj))\n                return obj.length > 0 ? obj[0] : null;\n            for (var key in obj)\n                return obj[key];\n            return null;\n        },\n\n        /**\n         * Returns and removes the first entry of an object or array.\n         * \n         * @param obj object or array\n         * \n         * @return first entry\n         */\n        poll: function(obj) {\n            if (Types.is_array(obj))\n                return obj.shift();\n            for (var key in obj) {\n                var item = obj[key];\n                delete obj[key];\n                return item;\n            }\n            return null;\n        },\n\n        /**\n         * Iterates over an object or array, calling a callback function for each item.\n         * \n         * @param obj object or array\n         * @param {function} f callback function\n         * @param {object} context optional callback context\n         * \n         */\n        iter: function(obj, f, context) {\n            var result = null;\n            if (Types.is_array(obj)) {\n                for (var i = 0; i < obj.length; ++i) {\n                    result = context ? f.apply(context, [obj[i], i]) : f(obj[i], i);\n                    if (Types.is_defined(result) && !result)\n                        return false;\n                }\n            } else {\n                for (var key in obj) {\n                    result = context ? f.apply(context, [obj[key], key]) : f(obj[key], key);\n                    if (Types.is_defined(result) && !result)\n                        return false;\n                }\n            }\n            return true;\n        },\n\n        /**\n         * Creates the intersection object of two objects.\n         * \n         * @param {object} a object one\n         * @param {object} b object two\n         * \n         * @return {object} intersection object\n         */\n        intersect: function(a, b) {\n            var c = {};\n            for (var key in a) {\n                if (key in b)\n                    c[key] = a[key];\n            }\n            return c;\n        },\n\n        /**\n         * Determines whether two objects have the same set of keys.\n         *\n         * @param {object} a object one\n         * @param {object} b object two\n         *\n         * @return {boolean} true if same keys\n         */\n        keyEquals: function(a, b) {\n            for (var key in a)\n                if (!(key in b))\n                    return false;\n            for (key in b)\n                if (!(key in a))\n                    return false;\n            return true;\n        },\n\n        /**\n         * Splits an object into two according to a callback function\n         *\n         * @param {object} obj object to split\n         * @param {function} f function to determine how to split\n         * @param {object} ctx optional context\n         *\n         * @return {array} two element array of two split objects\n         */\n        splitObject: function(obj, f, ctx) {\n            var x = {};\n            var y = {};\n            this.iter(obj, function(value, key) {\n                if (f.apply(this, arguments))\n                    x[key] = value;\n                else\n                    y[key] = value;\n            }, ctx);\n            return [x, y];\n        },\n\n        /**\n         * Creates the difference object of two objects.\n         * \n         * @param {object} a object one\n         * @param {object} b object two\n         * \n         * @return {object} difference object\n         */\n        diff: function(a, b) {\n            var c = {};\n            for (var key in a)\n                if (!(key in b) || a[key] !== b[key])\n                    c[key] = a[key];\n            return c;\n        },\n\n        /**\n         * Determines whether a key exists in an array or object.\n         * \n         * @param obj object or array\n         * @param key search key\n         * \n         * @return {boolean} true if key is contained in obj\n         */\n        contains_key: function(obj, key) {\n            if (Types.is_array(obj))\n                return Types.is_defined(obj[key]);\n            else\n                return key in obj;\n        },\n\n        /**\n         * Determines whether a value exists in an array or object.\n         * \n         * @param obj object or array\n         * @param value search value\n         * \n         * @return {boolean} true if value is contained in obj\n         */\n        contains_value: function(obj, value) {\n            if (Types.is_array(obj)) {\n                for (var i = 0; i < obj.length; ++i) {\n                    if (obj[i] === value)\n                        return true;\n                }\n            } else {\n                for (var key in obj) {\n                    if (obj[key] === value)\n                        return true;\n                }\n            }\n            return false;\n        },\n\n        /**\n         * Maps an array of object, mapping values using a function.\n         * \n         * @param obj object or array\n         * @param {function} f function for mapping values\n         * @param {object} context function context\n         * \n         * @return object or array with mapped values\n         * \n         */\n        map: function(obj, f, context) {\n            var result = null;\n            context = context || this;\n            if (Types.is_array(obj)) {\n                result = [];\n                for (var i = 0; i < obj.length; ++i)\n                    result.push(f.call(context, obj[i], i));\n                return result;\n            } else {\n                result = {};\n                for (var key in obj)\n                    result[key] = f.call(context, obj[key], key);\n                return result;\n            }\n        },\n\n        /**\n         * Maps the keys of an object using a function.\n         * \n         * @param {object} obj object\n         * @param {function} f function for mapping keys\n         * @param {object} context function context\n         * \n         * @return {object} object with mapped keys\n         */\n        keyMap: function(obj, f, context) {\n            result = {};\n            context = context || this;\n            for (var key in obj)\n                result[f.call(context, obj[key], key)] = obj[key];\n            return result;\n        },\n\n        /**\n         * Creates a bidirectional mapping of an object.\n         *\n         * @param {object} obj object\n         *\n         * @return {object} bidirectional map\n         */\n        bidirectionalMap: function(obj) {\n            var result = {};\n            this.iter(obj, function(value, key) {\n                if (Types.is_array(value)) {\n                    for (var i = 0; i < value.length; ++i) {\n                        result[value[i]] = key;\n                    }\n                } else {\n                    result[value] = key;\n                }\n                result[key] = value;\n            });\n            return result;\n        },\n\n        /**\n         * Returns all values of an object as an array.\n         * \n         * @param {object} obj object\n         * \n         * @return {array} values of object as array\n         */\n        values: function(obj) {\n            var result = [];\n            for (var key in obj)\n                result.push(obj[key]);\n            return result;\n        },\n\n        flatten: function(arr) {\n            var result = [];\n            arr.forEach(function(inner) {\n                result = result.concat(Types.is_array(inner) ? inner : [inner]);\n            });\n            return result;\n        },\n\n        treeValues: function(obj) {\n            if (obj && Types.is_array(obj))\n                return this.flatten(obj.map(this.treeValues, this));\n            if (obj && Types.is_object(obj))\n                return this.treeValues(this.values(obj));\n            return [obj];\n        },\n\n        uniqueValues: function(obj) {\n            var occ = {};\n            return this.filter(obj, function(v) {\n                if (v in occ)\n                    return false;\n                occ[v] = true;\n                return true;\n            });\n        },\n\n        /**\n         * Filters all values of an object or array.\n         * \n         * @param obj object or array\n         * @param {function} f filter function\n         * @param {object} context filter function context\n         * \n         * @return object or array with filtered items\n         */\n        filter: function(obj, f, context) {\n            f = f || function(x) {\n                return !!x;\n            };\n            if (Types.is_array(obj))\n                return obj.filter(f, context);\n            var ret = {};\n            for (var key in obj) {\n                if (context ? f.apply(context, [obj[key], key]) : f(obj[key], key))\n                    ret[key] = obj[key];\n            }\n            return ret;\n        },\n\n        /**\n         * Tests two objects for deep equality up to a certain depth.\n         * \n         * @param {object} obj1 first object\n         * @param {object} obj2 second object\n         * @param {int} depth depth until deep comparison should be done\n         * \n         * @return {boolean} true if both objects are equal \n         */\n        equals: function(obj1, obj2, depth) {\n            var key = null;\n            if (depth && depth > 0) {\n                for (key in obj1) {\n                    if (!(key in obj2) || !this.equals(obj1[key], obj2[key], depth - 1))\n                        return false;\n                }\n                for (key in obj2) {\n                    if (!(key in obj1))\n                        return false;\n                }\n                return true;\n            } else\n                return obj1 == obj2;\n        },\n\n        /**\n         * Converts an array into object using the array values as keys.\n         * \n         * @param {array} arr array to be converted\n         * @param f a function mapping the value of an array to a value of the object, or a constant value, or undefined (then true is used)\n         * @param {object} context optional function context\n         * \n         * @return {object} converted object\n         */\n        objectify: function(arr, f, context) {\n            var result = {};\n            var is_function = Types.is_function(f);\n            if (Types.is_undefined(f))\n                f = true;\n            for (var i = 0; i < arr.length; ++i)\n                result[arr[i]] = is_function ? f.apply(context || this, [arr[i], i]) : f;\n            return result;\n        },\n\n        /**\n         * Converts an object into an array using a function to merge value and key.\n         *\n         * @param {object} obj obj to be converted\n         * @param f a function mapping the value and key to an item instance of the array\n         * @param {object} context optional function context\n         *\n         * @return {array} converted array\n         */\n        arrayify: function(obj, f, context) {\n            var result = [];\n            this.iter(obj, function(value, key) {\n                result.push(f.call(this, value, key));\n            }, context);\n            return result;\n        },\n\n        /**\n         * Creates an object by pairing up the arguments to key value pairs.\n         * \n         * @return {object} created object\n         */\n        objectBy: function() {\n            var obj = {};\n            var count = arguments.length / 2;\n            for (var i = 0; i < count; ++i)\n                obj[arguments[2 * i]] = arguments[2 * i + 1];\n            return obj;\n        },\n\n        /**\n         * Extracts all key-value pairs from an object instance not matching default key-value pairs in another instance.\n         * \n         * @param {object} ordinary object with default key-value pairs\n         * @param {object} concrete object with a concrete list of key-value pairs\n         * @param {boolean} keys if true, iterating over the ordinary keys, otherwise iterating over the conrete keys (default)\n         * \n         * @return {object} specialized key-value pairs\n         */\n        specialize: function(ordinary, concrete, keys) {\n            var result = {};\n            var iterateOver = keys ? ordinary : concrete;\n            for (var key in iterateOver)\n                if (!(key in ordinary) || ordinary[key] != concrete[key])\n                    result[key] = concrete[key];\n            return result;\n        },\n\n        /**\n         * Merges two objects.\n         * \n         * @param {object} secondary Secondary object\n         * @param {object} primary Primary object\n         * @param {object} options Key-based options for merging\n         * \n         * @return {object} Merged object\n         */\n        merge: function(secondary, primary, options) {\n            secondary = secondary || {};\n            primary = primary || {};\n            var result = {};\n            var keys = this.extend(this.keys(secondary, true), this.keys(primary, true));\n            for (var key in keys) {\n                var opt = key in options ? options[key] : \"primary\";\n                if (opt == \"primary\" || opt == \"secondary\") {\n                    if (key in primary || key in secondary) {\n                        if (opt == \"primary\")\n                            result[key] = key in primary ? primary[key] : secondary[key];\n                        else\n                            result[key] = key in secondary ? secondary[key] : primary[key];\n                    }\n                } else if (Types.is_function(opt))\n                    result[key] = opt(secondary[key], primary[key]);\n                else if (Types.is_object(opt))\n                    result[key] = this.merge(secondary[key], primary[key], opt);\n            }\n            return result;\n        },\n\n        /**\n         * Recursively merges one object into another without modifying the source objects.\n         * \n         * @param {object} secondary Object to be merged into.\n         * @param {object} primary Object to be merged in\n         * \n         * @return {object} Recursively merged object\n         */\n        tree_merge: function(secondary, primary, array_support) {\n            if (array_support && (Types.is_array(secondary) || Types.is_array(primary)))\n                return Types.is_array(secondary) ? (Types.is_array(primary) ? secondary.concat(primary) : secondary) : primary;\n            if (!Types.is_object(secondary) || !secondary)\n                return primary;\n            if (!Types.is_object(primary) || !primary)\n                return secondary;\n            var result = {};\n            var keys = this.extend(this.keys(secondary, true), this.keys(primary, true));\n            for (var key in keys) {\n                if (Types.is_object(primary[key]) && secondary[key])\n                    result[key] = this.tree_merge(secondary[key], primary[key], array_support);\n                else\n                    result[key] = key in primary ? primary[key] : secondary[key];\n            }\n            return result;\n        },\n\n        /**\n         * Serializes an object in such a way that all subscopes appear in a flat notation.\n         * \n         * @param {object} obj source object\n         * @param {string} head prefix header, usually empty\n         * \n         * @return {array} serialized object\n         */\n        serializeFlatJSON: function(obj, head) {\n            var result = [];\n            if (Types.is_array(obj) && obj) {\n                obj.forEach(function(value) {\n                    result = result.concat(this.serializeFlatJSON(value, head + \"[]\"));\n                }, this);\n            } else if (Types.is_object(obj) && obj) {\n                this.iter(obj, function(value, key) {\n                    result = result.concat(this.serializeFlatJSON(value, head ? head + \"[\" + key + \"]\" : key));\n                }, this);\n            } else {\n                result = [{\n                    key: head,\n                    value: obj\n                }];\n            }\n            return result;\n        },\n\n        /**\n         * Converts an object into an array by calling a custom function for combining key and value.\n         *\n         * @param {object} obj source object\n         * @param f a function for combining key and value\n         * @param {object} context optional function context\n         *\n         * @return {array} resulint arrayarray\n         */\n        objectToArray: function(obj, f, ctx) {\n            var a = [];\n            this.iter(obj, function(value, key) {\n                a.push(f.call(this, key, value));\n            }, ctx);\n            return a;\n        },\n\n        /**\n         * Initializes an array with pre-computed values using a callback function.\n         *\n         * @param {int} count number of elements to be generated\n         * @param {function} callback function for computing the elements\n         * @param {object} context optional context\n         * @returns {array} generated array\n         */\n        initArray: function(count, callback, context) {\n            var result = [];\n            for (var i = 0; i < count; ++i)\n                result.push(callback.call(context || this, i));\n            return result;\n        },\n\n        /**\n         * Merge key / values from two objects; merge value with callback function on intersection of both objects\n         *\n         * @param {object} obj1 first object\n         * @param {object} obj2 second object\n         * @param {function} merger merging function\n         * @param {object} mergerCtx optional context\n         */\n        customMerge: function(obj1, obj2, merger, mergerCtx) {\n            var result = {};\n            for (var key1 in obj1)\n                result[key1] = key1 in obj2 ? merger.call(mergerCtx, key1, obj1[key1], obj2[key1]) : obj1[key1];\n            for (var key2 in obj2)\n                if (!(key2 in obj1))\n                    result[key2] = obj2[key2];\n            return result;\n        },\n\n        indexizeArray: function(arr, keyName) {\n            var result = {};\n            arr.forEach(function(value) {\n                result[value[keyName]] = value;\n            });\n            return result;\n        },\n\n        filterOutValues: function(obj, values) {\n            return this.filter(obj, function(value) {\n                return !values.includes(value);\n            });\n        },\n\n        mergeSortedArrays: function(arr1, arr2, compare) {\n            compare = compare || function(a, b) {\n                return a > b ? 1 : (a < b ? -1 : 0);\n            };\n            var result = [];\n            var i = 0;\n            arr1.forEach(function(el1) {\n                while (i < arr2.length && compare(el1, arr2[i]) > 0) {\n                    result.push(arr2[i]);\n                    i++;\n                }\n                result.push(el1);\n                while (i < arr2.length && compare(el1, arr2[i]) === 0)\n                    i++;\n            });\n            while (i < arr2.length) {\n                result.push(arr2[i]);\n                i++;\n            }\n            return result;\n        },\n\n        getObjKeyByValue: function(obj, value) {\n            for (var prop in obj) {\n                if (obj.hasOwnProperty(prop)) {\n                    if (obj[prop] === value)\n                        return prop;\n                }\n            }\n        }\n\n    };\n});\n\n\nScoped.define(\"module:Objs.Scopes\", [\"module:Types\"], function(Types) {\n    /**\n     * Scoped access of keys within objects.\n     * \n     * @module BetaJS.Objs.Scopes\n     */\n    return {\n\n        /**\n         * Determines whether a scoped key exists within a scope.\n         * \n         * @param {string} key key within scope\n         * @param {object} name scope context\n         * \n         * @return {boolean} true if key exists within scope\n         */\n        has: function(key, scope) {\n            var keys = key ? key.split(\".\") : [];\n            for (var i = 0; i < keys.length; ++i) {\n                if (!scope || !Types.is_object(scope))\n                    return false;\n                scope = scope[keys[i]];\n            }\n            return Types.is_defined(scope);\n        },\n\n        /**\n         * Returns the value of a key within a scope.\n         * \n         * @param {string} key key within scope\n         * @param {object} name scope context\n         * \n         * @return Value for key in scope\n         */\n        get: function(key, scope) {\n            var keys = key ? key.split(\".\") : [];\n            for (var i = 0; i < keys.length; ++i) {\n                if (!scope || !Types.is_object(scope))\n                    return null;\n                scope = scope[keys[i]];\n            }\n            return scope;\n        },\n\n        /**\n         * Sets the value of a key within a scope.\n         * \n         * @param {string} key key within scope\n         * @param name value to be set\n         * @param {object} name scope context\n         */\n        set: function(key, value, scope) {\n            if (!key)\n                return;\n            var keys = key.split(\".\");\n            for (var i = 0; i < keys.length - 1; ++i) {\n                if (!(keys[i] in scope) || !Types.is_object(scope[keys[i]]))\n                    scope[keys[i]] = {};\n                scope = scope[keys[i]];\n            }\n            scope[keys[keys.length - 1]] = value;\n        },\n\n        /**\n         * Unsets a key within a scope.\n         * \n         * @param {string} key key within scope\n         * @param {object} name scope context\n         */\n        unset: function(key, scope) {\n            if (!key)\n                return;\n            var keys = key.split(\".\");\n            for (var i = 0; i < keys.length - 1; ++i) {\n                if (!scope || !Types.is_object(scope))\n                    return;\n                scope = scope[keys[i]];\n            }\n            delete scope[keys[keys.length - 1]];\n        },\n\n        /**\n         * Makes sure that a certain key is accessible within a scope.\n         * \n         * @param {string} key key within scope\n         * @param {object} name scope context\n         * \n         * @return Touched value\n         */\n        touch: function(key, scope) {\n            if (!key)\n                return scope;\n            var keys = key.split(\".\");\n            for (var i = 0; i < keys.length; ++i) {\n                if (!(keys[i] in scope) || !Types.is_object(scope))\n                    scope[keys[i]] = {};\n                scope = scope[keys[i]];\n            }\n            return scope[keys[keys.length - 1]];\n        }\n\n    };\n});\nScoped.define(\"module:Parser.LexerException\", [\n    \"module:Exceptions.Exception\"\n], function(Exception, scoped) {\n    return Exception.extend({\n        scoped: scoped\n    }, function(inherited) {\n        /**\n         * Lexer Exception Class\n         * \n         * @class BetaJS.Parser.LexerException\n         */\n        return {\n\n            /**\n             * Instantiates a Lexer Exception\n             * \n             * @param {string} head head string that has been parsed\n             * @param {string} tail tail string that is not parsed yet\n             * \n             */\n            constructor: function(head, tail) {\n                inherited.constructor.call(this, \"Lexer error: Unrecognized identifier at \" + head.length + \".\");\n                this.__head = head;\n                this.__tail = tail;\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Parser.Lexer\", [\n    \"module:Class\", \"module:Types\", \"module:Objs\", \"module:Parser.LexerException\"\n], function(Class, Types, Objs, LexerException, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Simple Lexer Class for Parsing Strings\n         * \n         * @class BetaJS.Parser.Lexer\n         */\n        return {\n\n            /**\n             * Instantiates a Lexer\n             * \n             * @param {object} patterns a mapping from regular expressions to token identifiers or value preservers\n             */\n            constructor: function(patterns) {\n                inherited.constructor.call(this);\n                this.__patterns = [];\n                Objs.iter(patterns, function(value, key) {\n                    this.__patterns.push({\n                        regex: new RegExp(\"^\" + key, \"m\"),\n                        data: Types.is_string(value) ? {\n                            token: value\n                        } : value\n                    });\n                }, this);\n            },\n\n            /**\n             * Lexes a string w.r.t. the initialised patterns.\n             * \n             * @param {string} source source string\n             * @return {array} array of parsed tokens\n             */\n            lex: function(source) {\n                var result = [];\n                var head = \"\";\n                var tail = source;\n                while (tail) {\n                    var match = null;\n                    var data = null;\n                    for (var i = 0; i < this.__patterns.length; ++i) {\n                        match = this.__patterns[i].regex.exec(tail);\n                        if (match) {\n                            data = Objs.clone(this.__patterns[i].data, 1);\n                            break;\n                        }\n                    }\n                    if (!match)\n                        throw new LexerException(head, tail);\n                    head += match[0];\n                    tail = tail.substring(match[0].length);\n                    if (!data)\n                        continue;\n                    for (var key in data) {\n                        if (Types.is_string(data[key])) {\n                            for (var j = 0; j < match.length; ++j)\n                                data[key] = data[key].replace(\"$\" + j, match[j]);\n                        }\n                    }\n                    result.push(data);\n                }\n                return result;\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Properties.ObservableMixin\", [], function() {\n\n    /**\n     * Properties Observable Mixin\n     *\n     * @mixin BetaJS.Properties.ObservableMixin\n     */\n    return {\n\n        __observable_guid: \"48994ac3-7e0b-4ed5-8995-f146215dc795\",\n\n        /**\n         * Returns the value associated with a key.\n         *\n         * @param {string} key key to read value for\n         *\n         * @return value for key\n         */\n        get: function(key) {},\n\n        /**\n         * Checks whether a key is set.\n         *\n         * @param {string} key key in question\n         *\n         * @return {boolean} true if key is set\n         */\n        hasKey: function(key) {}\n\n    };\n});\n\n\nScoped.define(\"module:Properties.PropertiesMixin\", [\n    \"module:Objs.Scopes\",\n    \"module:Objs\",\n    \"module:Strings\",\n    \"module:Types\",\n    \"module:Functions\"\n], function(Scopes, Objs, Strings, Types, Functions) {\n\n    /**\n     * Properties Mixin\n     * \n     * @mixin BetaJS.Properties.PropertiesMixin\n     */\n    return {\n\n        __properties_guid: \"ec816b66-7284-43b1-a945-0600c6abfde3\",\n\n        _notifications: {\n            \"construct\": function() {\n                this.__properties = {\n                    // hierarchical organization\n                    data: {},\n                    // hierarchical organization\n                    watchers: {\n                        children: {},\n                        eventCount: 0,\n                        parent: null,\n                        key: null\n                    },\n                    // flat organization\n                    computed: {},\n                    // flat organization\n                    bindings: {}\n                };\n                Objs.iter(this.materializes, function(key) {\n                    this.materializeAttr(key);\n                }, this);\n            },\n            \"destroy\": function() {\n                Objs.iter(this.__properties.bindings, function(value, key) {\n                    this.unbind(key);\n                }, this);\n                Objs.iter(this.__properties.computed, function(value, key) {\n                    this.uncompute(key);\n                }, this);\n                /**\n                 * @event BetaJS.Properties.PropertiesMixin#destroy\n                 */\n                this.trigger(\"destroy\");\n            },\n            \"register_event\": function(event) {\n                Objs.iter([\"change\", \"unset\", \"deepchange\", \"deepunset\", \"strongdeepchange\", \"strongchange\"], function(eventType) {\n                    if (Strings.starts_with(event, eventType + \":\"))\n                        this.__registerWatcher(Strings.strip_start(event, eventType + \":\"), eventType);\n                }, this);\n            },\n            \"unregister_event\": function(event) {\n                Objs.iter([\"change\", \"unset\", \"deepchange\", \"deepunset\", \"strongdeepchange\", \"strongchange\"], function(eventType) {\n                    if (Strings.starts_with(event, eventType + \":\"))\n                        this.__unregisterWatcher(Strings.strip_start(event, eventType + \":\"), eventType);\n                }, this);\n            }\n        },\n\n        __registerWatcher: function(key, event) {\n            var keys = key ? key.split(\".\") : [];\n            var current = this.__properties.watchers;\n            for (var i = 0; i < keys.length; ++i) {\n                if (!(keys[i] in current.children)) {\n                    current.children[keys[i]] = {\n                        parent: current,\n                        eventCount: 0,\n                        children: {},\n                        key: keys[i]\n                    };\n                }\n                current = current.children[keys[i]];\n            }\n            current.eventCount++;\n        },\n\n        __unregisterWatcher: function(key, event) {\n            var keys = key ? key.split(\".\") : [];\n            var current = this.__properties.watchers;\n            for (var i = 0; i < keys.length; ++i) {\n                if (current)\n                    current = current.children[keys[i]];\n            }\n            if (!current)\n                return;\n            current.eventCount--;\n            while (current.eventCount <= 0 && Types.is_empty(current.children) && current.parent) {\n                var parent = current.parent;\n                delete parent.children[current.key];\n                current = parent;\n            }\n        },\n\n        __unsetChanged: function(key, oldValue) {\n            /**\n             * @event BetaJS.Properties.PropertiesMixin#unset\n             */\n            this.trigger(\"unset\", key, oldValue);\n            var keys = key ? key.split(\".\") : [];\n            var current = this.__properties.watchers;\n            var head = \"\";\n            var tail = key;\n            for (var i = 0; i < keys.length; ++i) {\n                if (current.eventCount > 0) {\n                    /**\n                     * @event BetaJS.Properties.PropertiesMixin#deepunset\n                     */\n                    this.trigger(\"deepunset:\" + head, oldValue, tail);\n                }\n                if (!(keys[i] in current.children))\n                    return this;\n                current = current.children[keys[i]];\n                head = head ? (head + \".\" + keys[i]) : keys[i];\n                tail = Strings.first_after(tail, \".\");\n            }\n\n            function process_unset(current, key, oldValue) {\n                if (Types.is_undefined(oldValue))\n                    return;\n                if (current.eventCount > 0) {\n                    /**\n                     * @event BetaJS.Properties.PropertiesMixin#unset\n                     */\n                    this.trigger(\"unset:\" + key, oldValue);\n                }\n                Objs.iter(current.children, function(child, subkey) {\n                    process_unset.call(this, child, key ? (key + \".\" + subkey) : subkey, oldValue[subkey]);\n                }, this);\n            }\n            process_unset.call(this, current, key, oldValue);\n            return this;\n        },\n\n        __setChanged: function(key, value, oldValue, notStrong) {\n            /**\n             * @event BetaJS.Properties.PropertiesMixin#change\n             */\n            this.trigger(\"change\", key, value, oldValue);\n            this._afterSet(key, value);\n            if (this.destroyed())\n                return;\n            var keys = key ? key.split(\".\") : [];\n            var current = this.__properties.watchers;\n            var head = \"\";\n            var tail = key;\n            for (var i = 0; i < keys.length; ++i) {\n                if (current.eventCount > 0) {\n                    if (!notStrong) {\n                        /**\n                         * @event BetaJS.Properties.PropertiesMixin#strongdeepchange\n                         */\n                        this.trigger(\"strongdeepchange:\" + head, value, oldValue, tail);\n                    }\n                    /**\n                     * @event BetaJS.Properties.PropertiesMixin#deepchange\n                     */\n                    this.trigger(\"deepchange:\" + head, value, oldValue, tail);\n                }\n                if (!(keys[i] in current.children))\n                    return;\n                current = current.children[keys[i]];\n                head = head ? (head + \".\" + keys[i]) : keys[i];\n                tail = Strings.first_after(tail, \".\");\n            }\n\n            function process_set(current, key, value, oldValue) {\n                if (value == oldValue)\n                    return;\n                if (current.eventCount > 0) {\n                    if (!notStrong) {\n                        /**\n                         * @event BetaJS.Properties.PropertiesMixin#strongchange\n                         */\n                        this.trigger(\"strongchange:\" + key, value, oldValue);\n                    }\n                    /**\n                     * @event BetaJS.Properties.PropertiesMixin#change\n                     */\n                    this.trigger(\"change:\" + key, value, oldValue);\n                }\n                Objs.iter(current.children, function(child, subkey) {\n                    process_set.call(this, child, key ? (key + \".\" + subkey) : subkey, Types.is_object(value) && value ? value[subkey] : null, Types.is_object(oldValue) && oldValue ? oldValue[subkey] : null);\n                }, this);\n            }\n            process_set.call(this, current, key, value, oldValue);\n        },\n\n        /**\n         * Attributes that will be materialized upon initialization.\n         */\n        materializes: [],\n\n        /**\n         * Resolve the scope associated with a key.\n         * \n         * @param {string} key key to resolve\n         * @return associated scope\n         * \n         * @protected\n         */\n        _resolveProps: function(key) {\n            var result = {\n                props: this,\n                key: key\n            };\n            var scope = this.data();\n            while (key) {\n                if (!scope || !Types.is_object(scope))\n                    return result;\n                if (scope.__properties_guid === this.__properties_guid)\n                    return scope._resolveProps(key);\n                var spl = Strings.splitFirst(key, \".\");\n                if (!(spl.head in scope))\n                    return result;\n                key = spl.tail;\n                scope = scope[spl.head];\n            }\n            return result;\n        },\n\n        /**\n         * Check whether a key can be set to a value.\n         * \n         * @param {string} key key in question\n         * @param value value in question\n         * \n         * @return {boolean} true if can be set\n         * \n         * @protected\n         */\n        _canSet: function(key, value) {\n            return true;\n        },\n\n        /**\n         * Called before setting a value.\n         * \n         * @param {string} key key in question\n         * @param value value in question\n         * @param oldValue oldValue in question\n         * \n         * @return value, possibly altered\n         * \n         * @protected\n         */\n        _beforeSet: function(key, value, oldValue) {\n            return value;\n        },\n\n        /**\n         * Called after setting a value.\n         * \n         * @param {string} key key in question\n         * @param value value in question\n         * \n         * @protected\n         */\n        _afterSet: function(key, value) {},\n\n        /**\n         * Get value for key, resolving intermediate properties instances.\n         * \n         * @param {string} key key to read\n         * \n         * @return associated value\n         */\n        getProp: function(key) {\n            var resolved = this._resolveProps(key);\n            return resolved.props.get(resolved.key);\n        },\n\n        /**\n         * Set value for key, resolving intermediate properties instances.\n         * \n         * @param {string} key to read\n         * @param value value to write\n         */\n        setProp: function(key, value) {\n            var resolved = this._resolveProps(key);\n            resolved.props.set(resolved.key, value);\n            return this;\n        },\n\n        /**\n         * Remove computation of a key.\n         * \n         * @param {string} key key to remove computation for\n         */\n        uncomputeProp: function(key) {\n            var resolved = this._resolveProps(key);\n            return resolved.props.uncompute(resolved.key);\n        },\n\n        /**\n         * Add computation of a key.\n         * \n         * @param {string} key key to add computation for\n         * @param {function} func function to compute the key\n         */\n        computeProp: function(key, func) {\n            var resolved = this._resolveProps(key);\n            var args = Functions.getArguments(arguments);\n            args[0] = resolved.key;\n            return resolved.props.compute.apply(resolved.props.compute, args);\n        },\n\n        /**\n         * Returns the value associated with a key.\n         * \n         * @param {string} key key to read value for\n         * \n         * @return value for key\n         */\n        get: function(key) {\n            return Scopes.get(key, this.__properties.data);\n        },\n\n        /**\n         * Checks whether a key is set.\n         * \n         * @param {string} key key in question\n         * \n         * @return {boolean} true if key is set\n         */\n        has: function(key) {\n            return Scopes.has(key, this.__properties.data);\n        },\n\n        /**\n         * Checks whether a key is set.\n         *\n         * @param {string} key key in question\n         *\n         * @return {boolean} true if key is set\n         */\n        hasKey: function(key) {\n            return this.has(key);\n        },\n\n        /**\n         * Sets all attributes in a JSON object.\n         * \n         * @param {object} obj JSON object data\n         * \n         */\n        setAll: function(obj) {\n            for (var key in obj)\n                this.set(key, obj[key]);\n            return this;\n        },\n\n        /**\n         * Returns all keys of the instance, possibly mapped.\n         * \n         * @param {function} mapped optional key mapping\n         * \n         * @return {array} all keys\n         */\n        keys: function(mapped) {\n            return Objs.keys(this.__properties.data, mapped);\n        },\n\n        /**\n         * Returns a data pointer to the raw data. Read only.\n         * \n         * @return {object} data pointer\n         */\n        data: function() {\n            return this.__properties.data;\n        },\n\n        /**\n         * Returns a raw data copy.\n         * \n         * @return {object} raw data copy\n         */\n        getAll: function() {\n            return Objs.clone(this.__properties.data, 1);\n        },\n\n        clone: function() {\n            return new(this.cls)(this.getAll());\n        },\n\n        /**\n         * Iterates over all key-value pairs.\n         *\n         * @param {function} cb callback function\n         * @param {object} ctx optional context\n         *\n         */\n        iterate: function(cb, ctx) {\n            Objs.iter(this.getAll(), cb, ctx);\n            return this;\n        },\n\n        /**\n         * Materializes an attribute as a function.\n         * \n         * @param {string} attr attribute to be materialized\n         * \n         */\n        materializeAttr: function(attr) {\n            this[attr] = function(value) {\n                if (arguments.length === 0)\n                    return this.get(attr);\n                this.set(attr, value);\n            };\n            return this;\n        },\n\n        /**\n         * Remove the computation of a key.\n         * \n         * @param {string} key key for which the computation should be removed\n         */\n        uncompute: function(key) {\n            if (key in this.__properties.computed) {\n                Objs.iter(this.__properties.computed[key].dependencies, function(dependency) {\n                    dependency.properties.off(\"change:\" + dependency.key, null, dependency);\n                    if (dependency.value && !dependency.value.destroyed())\n                        dependency.value.off(\"change update\", null, dependency);\n                }, this);\n                delete this.__properties.computed[key];\n            }\n            return this;\n        },\n\n        bicompute: function(left, right, leftToRight, rightToLeft) {\n            leftToRight.call(this);\n            var exclusive = false;\n            [\n                [left, leftToRight],\n                [right, rightToLeft]\n            ].forEach(function(direction) {\n                direction[0].forEach(function(key) {\n                    this.on(\"change:\" + key, function() {\n                        if (exclusive)\n                            return;\n                        try {\n                            exclusive = true;\n                            direction[1].call(this);\n                            exclusive = false;\n                        } catch (e) {\n                            exclusive = false;\n                            throw e;\n                        }\n                    }, this);\n                }, this);\n            }, this);\n            return this;\n        },\n\n        /**\n         * Add a computation for a key.\n         * \n         * @param {string} key key to add computation for\n         * @param {function} func function to compute the key\n         */\n        compute: function(key, func) {\n            var args = Functions.matchArgs(arguments, 2, {\n                setter: \"function\",\n                context: {\n                    type: \"object\",\n                    def: this\n                },\n                dependencies: true\n            });\n            this.uncompute(key);\n            var deps = [];\n            Objs.iter(args.dependencies, function(dep) {\n                if (Types.is_string(dep))\n                    deps.push({\n                        properties: this,\n                        key: dep\n                    });\n                else\n                    deps.push({\n                        properties: dep[0],\n                        key: dep[1]\n                    });\n            }, this);\n            var computed = {\n                ignore: 0,\n                func: func,\n                context: args.context,\n                setter: args.setter,\n                dependencies: deps\n            };\n            this.__properties.computed[key] = computed;\n            var self = this;\n\n            function recompute() {\n                if (computed.ignore > 0)\n                    return;\n                var values = Objs.map(deps, function(dep) {\n                    return dep.properties.get(dep.key);\n                });\n                self.set(key, func.apply(args.context, values));\n            }\n            Objs.iter(deps, function(dep) {\n                var value = dep.properties.get(dep.key);\n                // Ugly way of checking whether an EventsMixin is present - please improve in the future on this\n                if (value && typeof value == \"object\" && \"on\" in value && \"off\" in value && \"trigger\" in value) {\n                    dep.value = value;\n                    value.on(\"change update\", function() {\n                        recompute();\n                    }, dep);\n                }\n                dep.properties.on(\"change:\" + dep.key, function(value, oldValue) {\n                    dep.value = null;\n                    if (oldValue && typeof oldValue == \"object\" && \"on\" in oldValue && \"off\" in oldValue && \"trigger\" in oldValue) {\n                        oldValue.off(\"change update\", null, dep);\n                    }\n                    if (value && typeof value == \"object\" && \"on\" in value && \"off\" in value && \"trigger\" in value) {\n                        dep.value = value;\n                        value.on(\"change update\", function() {\n                            recompute();\n                        }, dep);\n                    }\n                    recompute();\n                }, dep);\n            }, this);\n            recompute();\n            return this;\n        },\n\n        /**\n         * Removes a binding for a key and another properties instance.\n         * \n         * @param {string} key key for which the binding should be removed\n         * @param {object} props other properties instance\n         */\n        unbind: function(key, props) {\n            if (key in this.__properties.bindings) {\n                for (var i = this.__properties.bindings[key].length - 1; i >= 0; --i) {\n                    var binding = this.__properties.bindings[key][i];\n                    if (!props || props == binding) {\n                        if (binding.left)\n                            binding.properties.off(null, null, binding);\n                        if (binding.right)\n                            this.off(null, null, binding);\n                        this.__properties.bindings[key].splice(i, 1);\n                        i--;\n                    }\n                }\n                if (this.__properties.bindings[key].length === 0)\n                    delete this.__properties.bindings[key];\n            }\n            return this;\n        },\n\n        /**\n         * Adds a binding for a key and another properties instance.\n         * \n         * @param {string} key key for which the binding should be added\n         * @param {object} props other properties instance\n         * @param {object} options optional options\n         */\n        bind: function(key, properties, options) {\n            options = Objs.extend({\n                secondKey: key,\n                left: true,\n                right: true,\n                deep: false\n            }, options);\n            var binding = {\n                key: options.secondKey,\n                left: options.left,\n                right: options.right,\n                deep: options.deep,\n                properties: properties\n            };\n            this.__properties.bindings[key] = this.__properties.bindings[key] || [];\n            this.__properties.bindings[key].push(binding);\n            var self = this;\n            if (binding.left) {\n                binding.properties.on(\"strongchange:\" + binding.key, function(value) {\n                    self.set(key, value);\n                }, binding);\n                binding.properties.on(\"unset:\" + binding.key, function(value) {\n                    self.unset(key);\n                }, binding);\n                if (binding.deep) {\n                    binding.properties.on(\"strongdeepchange:\" + binding.key, function(value, oldValue, subKey) {\n                        if (self.get(key ? key + \".\" + subKey : subKey) === value)\n                            self.__setChanged(key ? key + \".\" + subKey : subKey, value, oldValue, true);\n                        else\n                            self.set(key ? key + \".\" + subKey : subKey, value);\n                    }, binding);\n                    binding.properties.on(\"deepunset:\" + binding.key, function(oldValue, subKey) {\n                        if (!self.has(key ? key + \".\" + subKey : subKey))\n                            self.__unsetChanged(key ? key + \".\" + subKey : subKey, oldValue);\n                        else\n                            self.unset(key ? key + \".\" + subKey : subKey);\n                    }, binding);\n                }\n                if (!binding.right || !this.has(key))\n                    this.set(key, binding.properties.get(binding.key));\n                if (key === \"\") {\n                    Objs.iter(binding.properties.data(), function(value, k) {\n                        this.set(k, value);\n                    }, this);\n                }\n            }\n            if (binding.right) {\n                this.on(\"strongchange:\" + key, function(value) {\n                    binding.properties.set(binding.key, value);\n                }, binding);\n                this.on(\"unset:\" + key, function(value) {\n                    binding.properties.unset(binding.key);\n                }, binding);\n                if (binding.deep) {\n                    this.on(\"strongdeepchange:\" + key, function(value, oldValue, subKey) {\n                        if (binding.properties.get(binding.key ? binding.key + \".\" + subKey : subKey) === value)\n                            binding.properties.__setChanged(binding.key ? binding.key + \".\" + subKey : subKey, value, oldValue, true);\n                        else\n                            binding.properties.set(binding.key ? binding.key + \".\" + subKey : subKey, value);\n                    }, binding);\n                    this.on(\"deepunset:\" + key, function(oldValue, subKey) {\n                        if (!binding.properties.has(binding.key ? binding.key + \".\" + subKey : subKey))\n                            binding.properties.__unsetChanged(binding.key ? binding.key + \".\" + subKey : subKey, oldValue);\n                        else\n                            binding.properties.unset(binding.key ? binding.key + \".\" + subKey : subKey);\n                    }, binding);\n                }\n                if (!binding.left || this.has(key))\n                    binding.properties.set(binding.key, this.get(key));\n                if (key === \"\") {\n                    Objs.iter(this.data(), function(value, k) {\n                        binding.properties.set(k, value);\n                    }, this);\n                }\n            }\n            binding.properties.on(\"destroy\", function() {\n                if (!self.destroyed())\n                    self.unbind(key);\n            }, binding);\n            return this;\n        },\n\n        /**\n         * Removes a key from the properties instance.\n         * \n         * @param {string} key key to be removed\n         */\n        unset: function(key) {\n            if (this.has(key)) {\n                var oldValue = this.get(key);\n                Scopes.unset(key, this.__properties.data);\n                this.__unsetChanged(key, oldValue);\n            }\n            return this;\n        },\n\n        /**\n         * Sets a key in the properties instance.\n         * \n         * @param {string} key key to be set\n         * @param value value to be set\n         * @param {boolean} force optional force argument\n         */\n        set: function(key, value, force) {\n            if (Types.is_object(value) && value && value.guid == this.__properties_guid) {\n                if (value.properties)\n                    this.bind(key, value.properties, {\n                        secondKey: value.key\n                    });\n                if (value.func)\n                    this.compute(key, value.func, value.dependencies);\n                return this;\n            }\n            var oldValue = this.get(key);\n            value = this._beforeSet(key, value, oldValue);\n            if (oldValue !== value) {\n                Scopes.set(key, value, this.__properties.data);\n                this.__setChanged(key, value, oldValue);\n            } else if (force) {\n                /**\n                 * @event BetaJS.Properties.PropertiesMixin#change\n                 */\n                this.trigger(\"change\", key, value, oldValue, true);\n                /**\n                 * @event BetaJS.Properties.PropertiesMixin#change\n                 */\n                this.trigger(\"change:\" + key, value, oldValue, true);\n            }\n            return this;\n        },\n\n        /**\n         * @deprecated\n         */\n        binding: function(key) {\n            return {\n                guid: this.__properties_guid,\n                properties: this,\n                key: key\n            };\n        },\n\n        /**\n         * @deprecated\n         */\n        computed: function(f, dependencies) {\n            return {\n                guid: this.__properties_guid,\n                func: f,\n                dependencies: dependencies\n            };\n        },\n\n        /**\n         * Returns the properties unique id.\n         * \n         * @return {string} unique properties id\n         */\n        pid: function() {\n            return this.cid();\n        },\n\n        /**\n         * Checks whether this properties instance is a subset of another properties instance.\n         *  \n         * @param {object} props another properties instance or JSON object\n         * \n         * @return {boolean} true if this instance is a subset of the other properties object\n         */\n        isSubsetOf: function(props) {\n            return Objs.subset_of(this.data(), props.data ? props.data() : props);\n        },\n\n        /**\n         * Checks whether this properties instance is a superset of another properties instance.\n         *  \n         * @param {object} props another properties instance or JSON object\n         * \n         * @return {boolean} true if this instance is a superset of the other properties object\n         */\n        isSupersetOf: function(props) {\n            return Objs.superset_of(this.data(), props.data ? props.data() : props);\n        },\n\n        /**\n         * ES5 only\n         */\n        getProxy: function() {\n            var self = this;\n            return new Proxy(this.__properties.data, {\n                get: function(target, prop, receiver) {\n                    return self.get(prop);\n                },\n                set: function(target, prop, value) {\n                    self.set(prop, value);\n                }\n            });\n        }\n\n    };\n});\n\n\nScoped.define(\"module:Properties.Properties\", [\n    \"module:Class\",\n    \"module:Objs\",\n    \"module:Events.EventsMixin\",\n    \"module:Properties.ObservableMixin\",\n    \"module:Properties.PropertiesMixin\"\n], function(Class, Objs, EventsMixin, ObservableMixin, PropertiesMixin, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [EventsMixin, ObservableMixin, PropertiesMixin, function(inherited) {\n\n        /**\n         * Properties Class\n         * \n         * @class BetaJS.Properties.Properties\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {object} obj optional initial attributes\n             * @param {array} materializes optional initial attributes that should be materialized\n             */\n            constructor: function(obj, materializes) {\n                inherited.constructor.call(this);\n                if (obj)\n                    this.setAll(obj);\n                if (materializes) {\n                    Objs.iter(materializes, function(key) {\n                        this.materializeAttr(key);\n                    }, this);\n                }\n            }\n\n        };\n    }]);\n});\nScoped.define(\"module:Sort\", [\n    \"module:Comparators\",\n    \"module:Types\",\n    \"module:Objs\"\n], function(Comparators, Types, Objs) {\n\n    /**\n     * Sort objects and arrays.\n     * \n     * @module BetaJS.Sort\n     */\n    return {\n\n        /**\n         * Sort keys in an object according to a comparator. \n         * \n         * @param {object} object object to be sorted\n         * @param {function} f comparator comparator for sorting, accepting keys first and then optionally values\n         * \n         * @return {object} sorted object\n         */\n        sort_object: function(object, f) {\n            var a = [];\n            for (var key in object)\n                a.push({\n                    key: key,\n                    value: object[key]\n                });\n            a.sort(function(x, y) {\n                return f(x.key, y.key, x.value, y.value);\n            });\n            var o = {};\n            for (var i = 0; i < a.length; ++i)\n                o[a[i].key] = a[i].value;\n            return o;\n        },\n\n        /**\n         * Deep sorting an object according to a comparator. \n         * \n         * @param {object} object object to be sorted\n         * @param {function} f comparator comparator for sorting, accepting keys first and then optionally values\n         * \n         * @return {object} sorted object\n         */\n        deep_sort: function(object, f) {\n            f = f || Comparators.byValue;\n            if (Types.is_array(object)) {\n                for (var i = 0; i < object.length; ++i)\n                    object[i] = this.deep_sort(object[i], f);\n                return object.sort(f);\n            } else if (Types.is_object(object)) {\n                for (var key in object)\n                    object[key] = this.deep_sort(object[key], f);\n                return this.sort_object(object, f);\n            } else\n                return object;\n        },\n\n        /**\n         * Sort an array of items with inter-dependency specifiers s.t. every item in the resulting array has all its dependencies come before.\n         * \n         * @param {array} items list of items with inter-dependency specifiers\n         * @param {string|function} identifier function / key mapping an item to its unique identifier\n         * @param {string|function} before function / key mapping an item to its array of dependencies\n         * @param {string|function} after function / key mapping an item to its array of depending items\n         * \n         * @return {array} sorted array\n         */\n        dependency_sort: function(items, identifier, before, after) {\n            var identifierf = Types.is_string(identifier) ? function(obj) {\n                return obj[identifier];\n            } : identifier;\n            var beforef = Types.is_string(before) ? function(obj) {\n                return obj[before];\n            } : before;\n            var afterf = Types.is_string(after) ? function(obj) {\n                return obj[after];\n            } : after;\n            var n = items.length;\n            var data = [];\n            var identifier_to_index = {};\n            var todo = {};\n            var i = 0;\n            for (i = 0; i < n; ++i) {\n                todo[i] = true;\n                var ident = identifierf(items[i], i);\n                identifier_to_index[ident] = i;\n                data.push({\n                    before: {},\n                    after: {}\n                });\n            }\n            var make_before_iter_func = function(i) {\n                return function(before) {\n                    var before_index = identifier_to_index[before];\n                    if (Types.is_defined(before_index)) {\n                        data[i].before[before_index] = true;\n                        data[before_index].after[i] = true;\n                    }\n                };\n            };\n            var make_after_iter_func = function(i) {\n                return function(after) {\n                    var after_index = identifier_to_index[after];\n                    if (Types.is_defined(after_index)) {\n                        data[i].after[after_index] = true;\n                        data[after_index].before[i] = true;\n                    }\n                };\n            };\n            for (i = 0; i < n; ++i) {\n                Objs.iter(beforef(items[i], i) || [], make_before_iter_func(i));\n                Objs.iter(afterf(items[i]) || [], make_after_iter_func(i));\n            }\n            var result = [];\n            while (!Types.is_empty(todo)) {\n                for (i in todo) {\n                    if (Types.is_empty(data[i].after)) {\n                        delete todo[i];\n                        result.push(items[i]);\n                        for (var bef in data[i].before)\n                            delete data[bef].after[i];\n                    }\n                }\n            }\n            return result;\n        }\n\n    };\n});\nScoped.define(\"module:Strings\", [\"module:Objs\"], function(Objs) {\n    /**\n     * String Utilities\n     *\n     * @module BetaJS.Strings\n     */\n    return {\n\n\n        /**\n         * Will act like ASP.NET format function\n         *\n         * Use Example\n         * BetaJS.Strings.format(\"{0} formatted, and {1} formatted! Also no format {2}\", \"First\", \"Second\");\n         * Result should be: \"First formatted, and Second formatted! Also no format {2}\"\n         *\n         * @param {String} stringToFormat\n         * @return {String}\n         */\n        format: function(stringToFormat) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            return stringToFormat.replace(/{(\\d+)}/g, function(match, number) {\n                return typeof args[number] != 'undefined' ?\n                    args[number] :\n                    match;\n            });\n        },\n\n        /**\n         * Uppercases first character in string.\n         *\n         * @param {string} s string in question\n         *\n         * @return {string} uppercased string\n         */\n        ucFirst: function(s) {\n            s += '';\n            return s.charAt(0).toUpperCase() + s.substr(1);\n        },\n\n        /**\n         * Escapes a string to be used as an exact match in a regular expression.\n         *\n         * @param {string} s string in question\n         *\n         * @return {string} escaped string\n         *\n         * @link http://stackoverflow.com/a/3561711\n         */\n        regexEscape: function(s) {\n            return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n        },\n\n        /**\n         * Transforms a string with asterisks as placeholders to a regular expression\n         *\n         * @param {string} s string in question\n         *\n         * @return {string} escaped string\n         */\n        asteriskPatternToRegex: function(s) {\n            return s.replace(/[-\\/\\\\^$+?.()|[\\]{}]/g, '\\\\$&').replace(/\\*/g, '.*');\n        },\n\n        /**\n         * Pads a string from the left with characters if necessary.\n         *\n         * @param {string} s string that should be padded\n         * @param {string} padding padding string that should be used (e.g. whitespace)\n         * @param {int} length minimum length of result string\n         *\n         * @return {string} padded string\n         */\n        padLeft: function(s, padding, length) {\n            while (s.length < length)\n                s = padding + s;\n            return s;\n        },\n\n        /**\n         * Pads a string from the right with characters if necessary.\n         *\n         * @param {string} s string that should be padded\n         * @param {string} padding padding string that should be used (e.g. whitespace)\n         * @param {int} length minimum length of result string\n         *\n         * @return {string} padded string\n         */\n        padRight: function(s, padding, length) {\n            while (s.length < length)\n                s = s + padding;\n            return s;\n        },\n\n        /**\n         * Pads a string from the left with zeros ('0') if necessary.\n         *\n         * @param {string} s string that should be padded\n         * @param {int} length minimum length of result string\n         *\n         * @return {string} zero-padded string\n         */\n        padZeros: function(s, length) {\n            return this.padLeft(s + \"\", \"0\", length);\n        },\n\n        /** Converts a string new lines to html <br /> tags\n         *\n         * @param s string\n         * @return string with new lines replaced by <br />\n         */\n        nl2br: function(s) {\n            return (s + \"\").replace(/([^>\\r\\n]?)(\\r\\n|\\n\\r|\\r|\\n)/g, '$1<br />$2');\n        },\n\n        /** Converts special characters in a string to html entitiy symbols\n         *\n         * @param s string\n         * @return converted string\n         */\n        htmlentities: function(s) {\n            return (s + \"\").replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g, '&#x2F;');\n        },\n\n        JS_ESCAPES: {\n            \"'\": \"'\",\n            '\\\\': '\\\\',\n            '\\r': 'r',\n            '\\n': 'n',\n            '\\t': 't',\n            '\\u2028': 'u2028',\n            '\\u2029': 'u2029'\n        },\n\n        JS_ESCAPER_REGEX: function() {\n            if (!this.JS_ESCAPER_REGEX_CACHED)\n                this.JS_ESCAPER_REGEX_CACHED = new RegExp(Objs.keys(this.JS_ESCAPES).join(\"|\"), 'g');\n            return this.JS_ESCAPER_REGEX_CACHED;\n        },\n\n        /** Converts string such that it can be used in javascript by escaping special symbols\n         *\n         * @param s string\n         * @return escaped string\n         */\n        js_escape: function(s) {\n            var self = this;\n            return s.replace(this.JS_ESCAPER_REGEX(), function(match) {\n                return '\\\\' + self.JS_ESCAPES[match];\n            });\n        },\n\n        /** Determines whether a string starts with a sub string\n         *\n         * @param s string in question\n         * @param needle sub string\n         * @return true if string in question starts with sub string\n         */\n        starts_with: function(s, needle) {\n            return s.substring(0, needle.length) == needle;\n        },\n\n        /** Determines whether a string ends with a sub string\n         *\n         * @param s string in question\n         * @param needle sub string\n         * @return true if string in question ends with sub string\n         */\n        ends_with: function(s, needle) {\n            return s.indexOf(needle, s.length - needle.length) !== -1;\n        },\n\n        /** Removes sub string from a string if string starts with sub string\n         *\n         * @param s string in question\n         * @param needle sub string\n         * @return string without sub string if it starts with sub string otherwise it returns the original string\n         */\n        strip_start: function(s, needle) {\n            return this.starts_with(s, needle) ? s.substring(needle.length) : s;\n        },\n\n        /** Removes sub string from a string if string ends with sub string\n         *\n         * @param s string in question\n         * @param needle sub string\n         * @return string without sub string if it ends with sub string otherwise it returns the original string\n         */\n        strip_end: function(s, needle) {\n            return this.ends_with(s, needle) ? s.substring(0, s.length - needle.length) : s;\n        },\n\n        /** Inserts substring inside string after an index or match\n         *\n         * @param str string in question\n         * @param delimiter index, string or regex after which substring should be inserted\n         * @param substr string that will be inserted inside str\n         */\n        insert: function(str, delimiter, substr) {\n            var index = 0;\n            if (typeof delimiter === \"number\") index = delimiter;\n            else if (typeof delimiter === \"string\") {\n                index = str.indexOf(delimiter);\n                if (index < 0) return str;\n                index += delimiter.length;\n            } else if (delimiter instanceof RegExp) {\n                var matches = str.match(delimiter);\n                if (!matches) return str;\n                index = matches.index + matches[0].length;\n            }\n            return str.slice(0, index) + substr + str.slice(index);\n        },\n\n        /**\n         * Returns the complete remaining part of a string after the last occurrence of a sub string\n         *\n         * @param s string in question\n         * @param needle sub string\n         * @return remaining part of the string in question after the last occurrence of the sub string\n         */\n        last_after: function(s, needle) {\n            return this.splitLast(s, needle).tail;\n        },\n\n        /**\n         * Returns the complete remaining part of a string after the first occurrence of a sub string\n         *\n         * @param s string in question\n         * @param needle sub string\n         * @return remaining part of the string in question after the first occurrence of the sub string\n         */\n        first_after: function(s, needle) {\n            return s.substring(s.indexOf(needle) + 1, s.length);\n        },\n\n        EMAIL_ADDRESS_REGEX: /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,\n\n        STRICT_URL_REGEX: /^\\w+:\\/\\/[^\\s]+$/,\n\n        PERMISSIVE_URL_REGEX: /^[\\w\\.]+\\.(com|de|co\\.uk|fr|net|org|edu)[^\\s]*$/,\n\n        /** Determines whether a string is a syntactically valid email address\n         *\n         * @param s string in question\n         * @return true if string looks like an email address\n         */\n        is_email_address: function(s) {\n            return this.EMAIL_ADDRESS_REGEX.test(s);\n        },\n\n        STRIP_HTML_TAGS: [\"script\", \"style\", \"head\"],\n        STRIP_HTML_REGEX: /<\\/?([a-z][a-z0-9]*)\\b[^>]*>?/gi,\n        STRIP_HTML_COMMENT_REGEX: /<![^>]*>/gi,\n\n        /** Removes all html from data and returns plain text\n         *\n         * @param html string containing html\n         * @return string containing the plain text part of it\n         */\n        strip_html: function(html) {\n            var result = html;\n            for (var i = 0; i < this.STRIP_HTML_TAGS.length; ++i)\n                result = result.replace(new RegExp(\"<\" + this.STRIP_HTML_TAGS[i] + \".*</\" + this.STRIP_HTML_TAGS[i] + \">\", \"i\"), '');\n            result = result.replace(this.STRIP_HTML_REGEX, '').replace(this.STRIP_HTML_COMMENT_REGEX, '');\n            return result;\n        },\n\n        /** Trims all trailing and leading whitespace and removes block indentations\n         *\n         * @param s string\n         * @return string with trimmed whitespaces and removed block indentation\n         */\n        nltrim: function(s) {\n            var a = s.replace(/\\t/g, \"  \").split(\"\\n\");\n            var len = null;\n            var i = 0;\n            for (i = 0; i < a.length; ++i) {\n                var j = 0;\n                while (j < a[i].length) {\n                    if (a[i].charAt(j) != ' ')\n                        break;\n                    ++j;\n                }\n                if (j < a[i].length)\n                    len = len === null ? j : Math.min(j, len);\n            }\n            for (i = 0; i < a.length; ++i)\n                a[i] = a[i].substring(len);\n            return a.join(\"\\n\").trim();\n        },\n\n        /**\n         * Replaces all occurrences of a substring with something else.\n         *\n         * @param {string} s input string\n         * @param {string} sub search string\n         * @param {string} wth replacement string\n         *\n         * @return {string} input with all occurrences of the search string replaced by the replacement string\n         */\n        replaceAll: function(s, sub, wth) {\n            while (s.indexOf(sub) >= 0)\n                s = s.replace(sub, wth);\n            return s;\n        },\n\n        /**\n         * Capitalizes all first characters of all words in a string.\n         *\n         * @param {string} input input string\n         *\n         * @return {string} input with all first characters capitalized\n         */\n        capitalize: function(input) {\n            return input.replace(/\\w\\S*/g, function(txt) {\n                return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n            });\n        },\n\n        /**\n         * Converts string to pascal case\n         *\n         * @param {string} s input string\n         *\n         * @return {string} input in pascal case\n         */\n        pascalCase: function(s) {\n            return s.replace(/[A-Z][a-z0-9]/g, function(txt) {\n                return \" \" + txt;\n            }).replace(/[A-Za-z0-9]+/g, function(txt) {\n                return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n            }).replace(/[-_\\s]/g, \"\");\n        },\n\n        /**\n         * Converts string to camel case\n         *\n         * @param {string} s input string\n         *\n         * @return {string} input in camel case\n         */\n        camelCase: function(s) {\n            var txt = this.pascalCase(s);\n            return txt.charAt(0).toLowerCase() + txt.substr(1);\n        },\n\n        /**\n         * Converts string to train case\n         *\n         * @param {string} s input string\n         *\n         * @return {string} input in train case\n         */\n        trainCase: function(s) {\n            var txt = this.pascalCase(s);\n            return txt.replace(/[A-Z]/g, function(txt) {\n                return \"-\" + txt;\n            }).substring(1);\n        },\n\n        /**\n         * Converts string to snake case\n         *\n         * @param {string} s input string\n         *\n         * @return {string} input in snake case\n         */\n        snakeCase: function(s) {\n            return this.trainCase(s).replace(/-/g, \"_\").toLowerCase();\n        },\n\n        /**\n         * Converts string to kebab case\n         *\n         * @param {string} s input string\n         *\n         * @return {string} input in kebab case\n         */\n        kebabCase: function(s) {\n            return this.trainCase(s).toLowerCase();\n        },\n\n        /**\n         * Extracts the name from an email address name string (e.g. 'Foo Bar <foobar@domain.com>')\n         *\n         * @param {string} input email address name input string\n         *\n         * @return {string} name included in the string\n         */\n        email_get_name: function(input) {\n            input = input || \"\";\n            var temp = input.split(\"<\");\n            input = temp[0].trim();\n            if (!input || temp.length < 2) {\n                temp = temp[temp.length - 1].split(\"@\");\n                input = temp[0].trim();\n            }\n            input = input.replace(/['\"]/g, \"\").replace(/[\\\\._@]/g, \" \");\n            return this.capitalize(input);\n        },\n\n        /**\n         * Extracts the email from an email address name string (e.g. 'Foo Bar <foobar@domain.com>')\n         *\n         * @param {string} input email address name input string\n         *\n         * @return {string} email included in the string\n         */\n        email_get_email: function(input) {\n            input = input || \"\";\n            var temp = input.split(\"<\");\n            input = temp[0].trim();\n            if (temp.length > 1) {\n                temp = temp[1].split(\">\");\n                input = temp[0].trim();\n            }\n            input = input.replace(/'/g, \"\").replace(/\"/g, \"\").trim();\n            return input;\n        },\n\n        /**\n         * Extracts the salutatory name from an email address name string (normally the first name)\n         *\n         * @param {string} input email address name input string\n         *\n         * @return {string} salutatory name\n         */\n        email_get_salutatory_name: function(input) {\n            return (this.email_get_name(input || \"\").split(\" \"))[0];\n        },\n\n        /**\n         * Splits a string into two by the first occurrence of a delimiter\n         *\n         * @param {string} s input string\n         * @param {string} delimiter delimiter string\n         *\n         * @return {object} a json object, mapping 'head' to the region left and 'tail' to region right to the delimiter\n         */\n        splitFirst: function(s, delimiter) {\n            var i = s.indexOf(delimiter);\n            return {\n                head: i >= 0 ? s.substring(0, i) : s,\n                tail: i >= 0 ? s.substring(i + delimiter.length) : \"\"\n            };\n        },\n\n        /**\n         * Splits a string into two by the last occurrence of a delimiter\n         *\n         * @param {string} s input string\n         * @param {string} delimiter delimiter string\n         *\n         * @return {object} a json object, mapping 'head' to the region left and 'tail' to region right to the delimiter\n         */\n        splitLast: function(s, delimiter) {\n            var i = s.lastIndexOf(delimiter);\n            return {\n                head: i >= 0 ? s.substring(0, i) : \"\",\n                tail: i >= 0 ? s.substring(i + delimiter.length) : s\n            };\n        },\n\n        /**\n         * Replace all groups in a regular expression string by string parameters.\n         *\n         * @param {string} regex regular expression with groups as a string\n         * @param {array} args array of string parameters\n         *\n         * @return {string} regular expression with groups being replaced by string parameters\n         */\n        regexReplaceGroups: function(regex, args) {\n            var findGroup = /\\(.*?\\)/;\n            var f = function(captured) {\n                if (arg)\n                    return arg;\n                return captured.substring(1, captured.length - 1);\n            };\n            while (args.length > 0) {\n                var arg = args.shift();\n                regex = regex.replace(findGroup, f);\n            }\n            return regex;\n        },\n\n        /**\n         * Given a regular expression with named capture groups (e.g. '(foobar:\\d+)'), compute a normal regular expression with mappings to the named groups.\n         *\n         * @param {string} regex regular expression with named capture groups\n         *\n         * @return {object} mapping object\n         */\n        namedCaptureRegex: function(regex) {\n            var groupMap = {};\n            var groupIdx = 0;\n            var newRegex = new RegExp(regex.replace(/\\([^)]+\\)/ig, function(group) {\n                if (group.charAt(1) != \"?\" && group.indexOf(\":\") > 0) {\n                    var delimiter = group.indexOf(\":\");\n                    groupMap[group.substring(1, delimiter)] = groupIdx;\n                    group = \"(\" + group.substring(delimiter + 1, group.length - 1) + \")\";\n                }\n                groupIdx++;\n                return group;\n            }));\n            var map = function(groups) {\n                return Objs.map(groupMap, function(idx) {\n                    return groups[idx + 1];\n                });\n            };\n            var exec = function(test) {\n                var result = newRegex.exec(test);\n                return result ? map(result) : null;\n            };\n            var mapBack = function(args) {\n                var result = [];\n                for (var i = 0; i < groupIdx; ++i)\n                    result.push(null);\n                for (var key in args)\n                    if (key in groupMap)\n                        result[groupMap[key]] = args[key];\n                return result;\n            };\n            return {\n                regex: newRegex,\n                map: map,\n                exec: exec,\n                mapBack: mapBack\n            };\n        },\n\n        /**\n         * Given an int, returns the short form of its ordinal value\n         *\n         * @param {int} i An integer\n         *\n         * @return {string} The ordinal value of the number\n         */\n        ordinalSuffix: function(i) {\n            var j = i % 10,\n                k = i % 100;\n            if (j === 1 && k !== 11) {\n                return i + \"st\";\n            }\n            if (j === 2 && k !== 12) {\n                return i + \"nd\";\n            }\n            if (j === 3 && k !== 13) {\n                return i + \"rd\";\n            }\n            return i + \"th\";\n        },\n\n        __cachedRegExp: {},\n\n        /**\n         * Returns a reg exp object for a reg exp string from a cache.\n         *\n         * @param {string} regexString reg exp string\n         * @param {string} regexOptions reg exp options string\n         *\n         * @returns {object} RegExp object\n         */\n        cachedRegExp: function(regexString, regexOptions) {\n            regexOptions = regexOptions || \"\";\n            if (!this.__cachedRegExp[regexString])\n                this.__cachedRegExp[regexString] = {};\n            if (!this.__cachedRegExp[regexString][regexOptions])\n                this.__cachedRegExp[regexString][regexOptions] = new RegExp(regexString, regexOptions);\n            return this.__cachedRegExp[regexString][regexOptions];\n        },\n\n        IP_ADDRESS_REGEXP: /^\\d+\\.\\d+\\.\\d+\\.\\d+$/,\n\n        /**\n         * Checks whether a given string is an IP address.\n         *\n         * @param {string} str potential ip address\n         *\n         * @returns {boolean} true if ip address\n         */\n        isIPAddress: function(str) {\n            return this.IP_ADDRESS_REGEXP.test(str);\n        },\n\n        NORMALIZE_SEARCH_TEXT_MAPS: {\n            \"\\\\u00dc\": \"Ue\",\n            \"\\\\u00fc\": \"ue\",\n            \"\\\\u00c4\": \"Ae\",\n            \"\\\\u00e4\": \"ae\",\n            \"\\\\u00d6\": \"Oe\",\n            \"\\\\u00f6\": \"oe\",\n            \"\\\\u00df\": \"ss\",\n            /*\n            \"Ue\": \"U\",\n            \"ue\": \"u\",\n            \"Ae\": \"A\",\n            \"ae\": \"a\",\n            \"Oe\": \"O\",\n            \"oe\": \"o\",\n             */\n            \"\\\\W\": \" \",\n            \"\\\\s+\": \" \"\n        },\n\n        NORMALIZE_SEARCH_TEXT_MAPS_REGEX: function() {\n            if (!this.NORMALIZE_SEARCH_TEXT_MAPS_CACHED) {\n                this.NORMALIZE_SEARCH_TEXT_MAPS_CACHED = [];\n                Objs.iter(this.NORMALIZE_SEARCH_TEXT_MAPS, function(value, key) {\n                    this.NORMALIZE_SEARCH_TEXT_MAPS_CACHED.push({\n                        search: new RegExp(key, \"g\"),\n                        replace: value\n                    });\n                }, this);\n            }\n            return this.NORMALIZE_SEARCH_TEXT_MAPS_CACHED;\n        },\n\n        /**\n         * Normalizes a search text in regards to umlauts etc.\n         *\n         * @param {string} text search text to be normalized\n         * @returns {string} normalized search text\n         */\n        normalizeSearchText: function(text) {\n            Objs.iter(this.NORMALIZE_SEARCH_TEXT_MAPS_REGEX(), function(searchReplace) {\n                text = text.replace(searchReplace.search, searchReplace.replace);\n            });\n            return text.trim();\n        }\n\n    };\n\n});\nScoped.define(\"module:Structures.AvlTree\", function() {\n\n    /**\n     * Abstract AvlTree Structure\n     * \n     * @module BetaJS.Structures.AvlTree\n     */\n    return {\n\n        /**\n         * Returns an empty avl tree.\n         * \n         * @return {object} empty avl tree\n         */\n        empty: function() {\n            return null;\n        },\n\n        /**\n         * Returns a singleton avl tree.\n         * \n         * @param data data for singleton node\n         * \n         * @return {object} singleton avl tree\n         */\n        singleton: function(data) {\n            return {\n                data: data,\n                left: null,\n                right: null,\n                height: 1,\n                length: 1\n            };\n        },\n\n        /**\n         * Returns the smallest data item in an avl tree.\n         * \n         * @param {object} root tree root\n         * @return smallest data item\n         */\n        min: function(root) {\n            return root.left ? this.min(root.left) : root.data;\n        },\n\n        /**\n         * Returns the largest data item in an avl tree.\n         * \n         * @param {object} root tree root\n         * @return largest data item\n         */\n        max: function(root) {\n            return root.right ? this.max(root.right) : root.data;\n        },\n\n        /**\n         * Returns the height of an avl tree.\n         * \n         * @param {object} root tree root\n         * @return {int} height\n         */\n        height: function(node) {\n            return node ? node.height : 0;\n        },\n\n        /**\n         * Returns the number of nodes in an avl tree.\n         * \n         * @param {object} root tree root\n         * @return {int} number of nodes\n         */\n        length: function(node) {\n            return node ? node.length : 0;\n        },\n\n        /**\n         * @private\n         */\n        __height_join: function(left, right) {\n            return 1 + Math.max(this.height(left), this.height(right));\n        },\n\n        /**\n         * @private\n         */\n        length_join: function(left, right) {\n            return 1 + this.length(left) + this.length(right);\n        },\n\n        /**\n         * @private\n         */\n        __create: function(data, left, right) {\n            return {\n                data: data,\n                left: left,\n                right: right,\n                height: this.__height_join(left, right),\n                length: this.length_join(left, right)\n            };\n        },\n\n        /**\n         * Creates a new balanced tree from a tree of small elements, a tree of large elements and a data item inbetween.\n         * \n         * @param data data item\n         * @param {object} left avl tree of small elements\n         * @param {object} right avl tree of large elements\n         * \n         * @return {object} avl tree containing all data\n         */\n        balance: function(data, left, right) {\n            if (this.height(left) > this.height(right) + 2) {\n                if (this.height(left.left) >= this.height(left.right))\n                    return this.__create(left.data, left.left, this.__create(data,\n                        left.right, right));\n                else\n                    return this.__create(left.right.data, this.__create(left.data,\n                        left.left, left.right.left), this.__create(data,\n                        left.right.right, right));\n            } else if (this.height(right) > this.height(left) + 2) {\n                if (this.height(right.right) >= this.height(right.left))\n                    return this.__create(right.data, this.__create(data, left,\n                        right.left), right.right);\n                else\n                    return this.__create(right.left.data, this.__create(data, left,\n                        right.left.left), this.__create(right.data,\n                        right.left.right, right.right));\n            } else\n                return this.__create(data, left, right);\n        },\n\n        /**\n         * @private\n         */\n        __add_left: function(data, left) {\n            return left ? this.balance(left.data, this.__add_left(data, left.left),\n                left.right) : this.singleton(data);\n        },\n\n        /**\n         * @private\n         */\n        __add_right: function(data, right) {\n            return right ? this.balance(right.data, right.data, this.__add_right(\n                data, right.right)) : this.singleton(data);\n        },\n\n        /**\n         * @private\n         */\n        __join: function(data, left, right) {\n            if (!left)\n                return this.__add_left(data, right);\n            else if (!right)\n                return this.__add_right(data, left);\n            else if (this.height(left) > this.height(right) + 2)\n                return this.balance(left.data, left.left, this.__join(data,\n                    left.right, right));\n            else if (this.height(right) > this.height(left) + 2)\n                return this.balance(right.data, this.__join(data, left, right.left),\n                    right.right);\n            else\n                return this.__create(data, left, right);\n        },\n\n        /**\n         * Returns and removes the smallest item from the tree.\n         * \n         * @param {object} root avl tree\n         * \n         * @return {array} array, containing the smallest element and the remaining tree\n         */\n        take_min: function(root) {\n            if (!root.left)\n                return [root.data, root.right];\n            var result = this.take_min(root.left);\n            return [result[0], this.__join(root.data, result[1], root.right)];\n        },\n\n        /**\n         * Returns and removes the largest item from the tree.\n         * \n         * @param {object} root avl tree\n         * \n         * @return {array} array, containing the largest element and the remaining tree\n         */\n        take_max: function(root) {\n            if (!root.right)\n                return [root.data, root.left];\n            var result = this.take_max(root.right);\n            return [result[0], this.__join(root.data, root.left, result[1])];\n        },\n\n        /*\n        reroot : function(left, right) {\n        \tif (!left || !right)\n        \t\treturn left || right;\n        \tif (this.height(left) > this.height(right)) {\n        \t\tvar max = this.take_max(left);\n        \t\treturn this.__join(max[0], max[1], right);\n        \t}\n        \tvar min = this.take_min(right);\n        \treturn this.__join(min[0], left, min[1]);\n        },\n        */\n\n        /**\n         * Returns and removes the smallest item from the tree, denaturalizing the tree in an iterative fashion.\n         * \n         * @param {object} root avl tree\n         * \n         * @return {array} array, containing the smallest element and the remaining denaturalized tree\n         */\n        take_min_iter: function(root) {\n            if (!root)\n                return null;\n            if (!root.left)\n                return [root.data, root.left];\n            return this.take_min_iter(this.__create(root.left.data, root.left.left,\n                this.__create(root.data, root.left.right, root.right)));\n        },\n\n        /**\n         * Returns and removes the largest item from the tree, denaturalizing the tree in an iterative fashion.\n         * \n         * @param {object} root avl tree\n         * \n         * @return {array} array, containing the largest element and the remaining denaturalized tree\n         */\n        take_max_iter: function(root) {\n            if (!root)\n                return null;\n            if (!root.right)\n                return [root.data, root.right];\n            return this.take_max_iter(this.__create(root.right.data, this.__create(\n                root.data, root.left, root.right.left), root.right.right));\n        }\n\n    };\n\n});\n\n\nScoped.define(\"module:Structures.TreeMap\", [\"module:Structures.AvlTree\"], function(AvlTree) {\n\n    /**\n     * TreeMap Structure, based on AvlTree\n     * \n     * @module BetaJS.Structures.TreeMap\n     */\n    return {\n\n        /**\n         * Returns an empty Tree Map.\n         * \n         * @param {function} compare data comparison function\n         * @return {object} empty tree map\n         */\n        empty: function(compare) {\n            return {\n                root: null,\n                compare: compare || function(x, y) {\n                    return x > y ? 1 : x < y ? -1 : 0;\n                }\n            };\n        },\n\n        /**\n         * Determines whether a tree map is empty.\n         * \n         * @param {object} t tree map\n         * @return {boolean} true if empty\n         */\n        is_empty: function(t) {\n            return !t.root;\n        },\n\n        /**\n         * Returns the number of elements in the map.\n         * \n         * @param {object} t tree map\n         * @return {int} number of elements\n         */\n        length: function(t) {\n            return t.root ? t.root.length : 0;\n        },\n\n        /**\n         * @private\n         */\n        __add: function(key, value, t, node) {\n            var kv = {\n                key: key,\n                value: value\n            };\n            if (!node)\n                return AvlTree.singleton(kv);\n            var c = t.compare(key, node.data.key);\n            if (c === 0) {\n                node.data = kv;\n                return node;\n            } else if (c < 0)\n                return AvlTree.balance(node.data, this.__add(key, value, t, node.left), node.right);\n            else\n                return AvlTree.balance(node.data, node.left, this.__add(key, value, t, node.right));\n        },\n\n        /**\n         * Add a key value mapping to the map.\n         * \n         * @param key key\n         * @param value value\n         * @param {object} t tree map\n         * \n         * @return {object} updated tree map\n         */\n        add: function(key, value, t) {\n            t.root = this.__add(key, value, t, t.root);\n            return t;\n        },\n\n        /**\n         * Creates a singleton tree map.\n         * \n         * @param key key\n         * @param value value\n         * @param {function} compare comparison function\n         * \n         * @return {object} singleton tree map\n         */\n        singleton: function(key, value, compare) {\n            return this.add(key, value, this.empty(compare));\n        },\n\n        /**\n         * @private\n         */\n        __find: function(key, t, root) {\n            if (!root)\n                return null;\n            var c = t.compare(key, root.data.key);\n            return c === 0 ? root.data.value : this.__find(key, t, c < 0 ? root.left : root.right);\n        },\n\n        /**\n         * Finds a value for a key in the map.\n         * \n         * @param key key\n         * @param {object} t tree map\n         * @return value for key\n         */\n        find: function(key, t) {\n            return this.__find(key, t, t.root);\n        },\n\n        /**\n         * @private\n         */\n        __iterate: function(t, node, callback, context, reverse) {\n            if (!node)\n                return true;\n            return (\n                this.__iterate(t, reverse ? node.right : node.left, callback, context, reverse) &&\n                (callback.call(context, node.data.key, node.data.value) !== false) &&\n                this.__iterate(t, reverse ? node.left : node.right, callback, context, reverse));\n        },\n\n        /**\n         * Iterates over the tree map.\n         * \n         * @param {object} t tree map\n         * @param {function} callback callback function\n         * @param {object} context optional callback context\n         * @param {boolean} reverse optional reverse direction flag\n         */\n        iterate: function(t, callback, context, reverse) {\n            this.__iterate(t, t.root, callback, context, reverse);\n        },\n\n        /**\n         * @private\n         */\n        __iterate_from: function(key, t, node, callback, context, reverse) {\n            if (!node)\n                return true;\n            var c = t.compare(key, node.data.key) * (reverse ? -1 : 1);\n            if (c < 0 && !this.__iterate_from(key, t, reverse ? node.right : node.left, callback, context, reverse))\n                return false;\n            if (c <= 0 && callback.call(context, node.data.key, node.data.value) === false)\n                return false;\n            return this.__iterate_from(key, t, reverse ? node.left : node.right, callback, context, reverse);\n        },\n\n        /**\n         * Iterates over the tree map starting with a key.\n         * \n         * @param key key to start with\n         * @param {object} t tree map\n         * @param {function} callback callback function\n         * @param {object} context optional callback context\n         * @param {boolean} reverse optional reverse direction flag\n         */\n        iterate_from: function(key, t, callback, context, reverse) {\n            this.__iterate_from(key, t, t.root, callback, context, reverse);\n        },\n\n        /**\n         * Iterates over the tree map between two keys.\n         * \n         * @param from_key key to start with\n         * @param to_key key to end with\n         * @param {object} t tree map\n         * @param {function} callback callback function\n         * @param {object} context optional callback context\n         * @param {boolean} reverse optional reverse direction flag\n         */\n        iterate_range: function(from_key, to_key, t, callback, context, reverse) {\n            this.iterate_from(from_key, t, function(key, value) {\n                return t.compare(key, to_key) * (reverse ? -1 : 1) <= 0 && callback.call(context, key, value) !== false;\n            }, this, reverse);\n        },\n\n        /*\n        __downpath: function (current, reverse, path) {\n        \tpath = path || [];\n        \twhile (current) {\n        \t\tpath.push(current);\n        \t\tcurrent = reverse ? current.right : current.left\n        \t}\n        \treturn path;\n        },\n\t\t\n        iteratorInit: function (t, reverse) {\n        \treturn {\n        \t\tpath: this.__downpath(t.root, reverse),\n        \t\treverse: reverse\n        \t};\n        },\n\t\t\n        iteratorHasNext: function (iter) {\n        \treturn iter.path.length > 0;\n        },\n\t\t\n        iteratorNext: function (iter) {\n        \tvar current = iter.path[iter.path.length - 1];\n        \tvar data = current.data;\n        \tvar next = iter.reverse ? current.left : current.right;\n        \tif (next)\n        \t\titer.path = this.__downpath(next, iter.reverse, iter.path);\n        \telse {\n        \t\twhile (iter.path.length > 0) {\n        \t\t\tvar child = iter.path.pop();\n        \t\t\tcurrent = iter.path[iter.path.length - 1];\n        \t\t\tnext = iter.reverse ? current.left : current.right;\n        \t\t\tif (current !== next)\n        \t\t\t\tbreak;\n        \t\t}\n        \t}\n        \treturn data;\n        },\n        */\n\n        /**\n         * Returns and removes the smallest element from the tree.\n         * \n         * @param {object} tree map\n         * @return {object} smalles key value pair\n         */\n        take_min: function(t) {\n            var a = AvlTree.take_min(t.root);\n            a[1] = {\n                compare: t.compare,\n                root: a[1]\n            };\n            return a;\n        },\n\n        /**\n         * @private\n         */\n        __treeSizeLeft: function(key, t, node) {\n            var c = t.compare(key, node.data.key);\n            if (c < 0)\n                return this.__treeSizeLeft(key, t, node.left);\n            return 1 + (node.left ? node.left.length : 0) + (c > 0 ? this.__treeSizeLeft(key, t, node.right) : 0);\n        },\n\n        /**\n         * @private\n         */\n        __treeSizeRight: function(key, t, node) {\n            var c = t.compare(key, node.data.key);\n            if (c > 0)\n                return this.__treeSizeRight(key, t, node.right);\n            return 1 + (node.right ? node.right.length : 0) + (c < 0 ? this.__treeSizeRight(key, t, node.left) : 0);\n        },\n\n        /**\n         * @private\n         */\n        __distance: function(keyLeft, keyRight, t, node) {\n            var cLeft = t.compare(keyLeft, node.data.key);\n            var cRight = t.compare(keyRight, node.data.key);\n            if (cLeft > 0 || cRight < 0)\n                return this.__distance(keyLeft, keyRight, t, cLeft > 0 ? node.right : node.left);\n            return 1 + (cRight > 0 ? this.__treeSizeLeft(keyRight, t, node.right) : 0) + (cLeft < 0 ? this.__treeSizeRight(keyLeft, t, node.left) : 0);\n        },\n\n        /**\n         * Counts the number of keys smaller than a given key.\n         * \n         * @param key key\n         * @param {object} t tree map\n         * @return {int} number of keys smaller than given key\n         */\n        treeSizeLeft: function(key, t) {\n            return this.__treeSizeLeft(key, t, t.root);\n        },\n\n        /**\n         * Counts the number of keys larger than a given key.\n         * \n         * @param key key\n         * @param {object} t tree map\n         * @return {int} number of keys larger than given key\n         */\n        treeSizeRight: function(key, t) {\n            return this.__treeSizeRight(key, t, t.root);\n        },\n\n        /**\n         * Counts the number of keys between two keys.\n         * \n         * @param keyLeft first key\n         * @param keyRight second key\n         * @param {object} t tree map\n         * @return {int} number of keys in-between\n         */\n        distance: function(keyLeft, keyRight, t) {\n            return t.compare(keyLeft, keyRight) < 0 ? this.__distance(keyLeft, keyRight, t, t.root) - 1 : 0;\n        }\n\n    };\n\n});\n/*\r\n * Inspired by Underscore's Templating Engine\r\n * (which itself is inspired by John Resig's implementation)\r\n */\r\n\r\nScoped.define(\"module:Templates\", [\"module:Types\", \"module:Strings\"], function(Types, Strings) {\r\n    /**\r\n     * A very simple templating engine.\r\n     *\r\n     * @module BetaJS.Templates\r\n     */\r\n    return {\r\n\r\n        /**\r\n         * Tokenizes a string comprised of escaped javascript code and normal text.\r\n         * \r\n         * @param {string} s input string\r\n         *\r\n         * @return {array} array of token objects\r\n         */\r\n        tokenize: function(s) {\r\n            // Already tokenized?\r\n            if (Types.is_array(s))\r\n                return s;\r\n            var tokens = [];\r\n            var index = 0;\r\n            var self = this;\r\n            s.replace(self.SYNTAX_REGEX(), function(match, expr, esc, code, offset) {\r\n                if (index < offset)\r\n                    tokens.push({\r\n                        type: self.TOKEN_STRING,\r\n                        data: Strings.js_escape(s.slice(index, offset))\r\n                    });\r\n                if (code)\r\n                    tokens.push({\r\n                        type: self.TOKEN_CODE,\r\n                        data: code\r\n                    });\r\n                if (expr)\r\n                    tokens.push({\r\n                        type: self.TOKEN_EXPR,\r\n                        data: expr\r\n                    });\r\n                if (esc)\r\n                    tokens.push({\r\n                        type: self.TOKEN_ESC,\r\n                        data: esc\r\n                    });\r\n                index = offset + match.length;\r\n                return match;\r\n            });\r\n            return tokens;\r\n        },\r\n\r\n        /**\r\n         * Compiles a template string into a function that evaluates the template w.r.t. a given environment.\r\n         * \r\n         * @param {string} s input string\r\n         * @param {object} options options hash, allowing to specify start_index and end_index within the input string (optional)\r\n         * @return {function} evaluation function\r\n         */\r\n        compile: function(source, options) {\r\n            if (Types.is_string(source))\r\n                source = this.tokenize(source);\r\n            options = options || {};\r\n            var start_index = options.start_index || 0;\r\n            var end_index = options.end_index || source.length;\r\n            var result = \"__p+='\";\r\n            for (var i = start_index; i < end_index; ++i) {\r\n                switch (source[i].type) {\r\n                    case this.TOKEN_STRING:\r\n                        result += source[i].data;\r\n                        break;\r\n                    case this.TOKEN_CODE:\r\n                        result += \"';\\n\" + source[i].data + \"\\n__p+='\";\r\n                        break;\r\n                    case this.TOKEN_EXPR:\r\n                        result += \"'+\\n((__t=(\" + source[i].data + \"))==null?'':__t)+\\n'\";\r\n                        break;\r\n                    case this.TOKEN_ESC:\r\n                        result += \"'+\\n((__t=(\" + source[i].data + \"))==null?'':Helpers.Strings.htmlentities(__t))+\\n'\";\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            result += \"';\\n\";\r\n            result = 'with(obj||{}){\\n' + result + '}\\n';\r\n            result = \"var __t,__p='',__j=Array.prototype.join,\" +\r\n                \"echo=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n                result + \"return __p;\\n\";\r\n            /*jslint evil: true */\r\n            var func = new Function('obj', 'Helpers', result);\r\n            var func_call = function(data) {\r\n                return func.call(this, data, {\r\n                    Strings: Strings\r\n                });\r\n            };\r\n            func_call.source = 'function(obj, Helpers){\\n' + result + '}';\r\n            return func_call;\r\n        },\r\n\r\n        SYNTAX: {\r\n            OPEN: \"{%\",\r\n            CLOSE: \"%}\",\r\n            MODIFIER_CODE: \"\",\r\n            MODIFIER_EXPR: \"=\",\r\n            MODIFIER_ESC: \"-\"\r\n        },\r\n\r\n        SYNTAX_REGEX: function() {\r\n            var syntax = this.SYNTAX;\r\n            if (!this.SYNTAX_REGEX_CACHED) {\r\n                this.SYNTAX_REGEX_CACHED = new RegExp(\r\n                    syntax.OPEN + syntax.MODIFIER_EXPR + \"([\\\\s\\\\S]+?)\" + syntax.CLOSE + \"|\" +\r\n                    syntax.OPEN + syntax.MODIFIER_ESC + \"([\\\\s\\\\S]+?)\" + syntax.CLOSE + \"|\" +\r\n                    syntax.OPEN + syntax.MODIFIER_CODE + \"([\\\\s\\\\S]+?)\" + syntax.CLOSE + \"|\" +\r\n                    \"$\",\r\n                    'g');\r\n            }\r\n            return this.SYNTAX_REGEX_CACHED;\r\n        },\r\n\r\n        TOKEN_STRING: 1,\r\n        TOKEN_CODE: 2,\r\n        TOKEN_EXPR: 3,\r\n        TOKEN_ESC: 4\r\n\r\n    };\r\n});\r\n\r\n\r\nScoped.define(\"module:Templates.Template\", [\"module:Class\", \"module:Templates\"], function(Class, Templates, scoped) {\r\n    return Class.extend({\r\n        scoped: scoped\r\n    }, function(inherited) {\r\n        return {\r\n\r\n            constructor: function(template_string) {\r\n                inherited.constructor.call(this);\r\n                this.__tokens = Templates.tokenize(template_string);\r\n                this.__compiled = Templates.compile(this.__tokens);\r\n            },\r\n\r\n            evaluate: function(obj) {\r\n                return this.__compiled.apply(this, [obj]);\r\n            }\r\n\r\n        };\r\n    });\r\n});\nScoped.define(\"module:TimeFormat\", [\"module:Time\", \"module:Strings\", \"module:Objs\"], function(Time, Strings, Objs) {\n    /**\n     * Module for formatting Time / Date\n     * \n     * @module BetaJS.TimeFormat\n     */\n    return {\n\n        /*\n        \tHH\tHours; leading zero for single-digit hours (24-hour clock).\n        \tH\tHours; no leading zero for single-digit hours (24-hour clock).\n        \th+  Hours; hours as absolute number\n        \thh\tHours; leading zero for single-digit hours (12-hour clock).\n        \th\tHours; no leading zero for single-digit hours (12-hour clock).\n        \tM+  Minutes; minutes as absolute number\n        \tMM\tMinutes; leading zero for single-digit minutes.\n        \tM\tMinutes; no leading zero for single-digit minutes.\n        \ts+\tSeconds; seconds as absolute number\n        \tss\tSeconds; leading zero for single-digit seconds.\n        \ts\tSeconds; no leading zero for single-digit seconds.\n        \tmmm\tMonth as a three-letter abbreviation.\n        \tmm\tMonth as digits; leading zero for single-digit months.\n        \tm\tMonth as digits; no leading zero for single-digit months.\n        \td+\tDays; days as absolute number\n        \tddddDay of the week as string.\n        \tddd\tDay of the week as a three-letter abbreviation.\n        \tdd\tDay of the month as digits; leading zero for single-digit days.\n        \td\tDay of the month as digits; no leading zero for single-digit days.\n        \tyy\tYear as last two digits; leading zero for years less than 10.\n        \tyyyyYear represented by four digits.\n        \tl+  Milliseconds; absolute\n        \tl   Milliseconds 3 digits\n        \tL   Milliseconds 2 digits\n        \tt\tLowercase, single-character time marker string: a or p.\n        \ttt\tLowercase, two-character time marker string: am or pm.\n        \tT\tUppercase, single-character time marker string: A or P.\n        \tTT\tUppercase, two-character time marker string: AM or PM.\n        \to\tGMT/UTC timezone offset, e.g. -0500 or +0230.\n        \t\n        */\n\n        formatMappings: {\n            \"HH\": function(t) {\n                return Strings.padZeros(Time.timeModulo(t, \"hour\", \"floor\"), 2);\n            },\n            \"H\": function(t) {\n                return Time.timeModulo(t, \"hour\", \"floor\");\n            },\n            \"h+\": function(t) {\n                return Time.timeComponent(t, \"hour\", \"floor\");\n            },\n            \"hh\": function(t) {\n                var h = Time.timeModulo(t, \"hour\", \"floor\");\n                h = h === 0 ? 12 : (h > 12 ? h - 12 : h);\n                return Strings.padZeros(h, \" \", 2);\n            },\n            \"h\": function(t) {\n                var h = Time.timeModulo(t, \"hour\", \"floor\");\n                h = h === 0 ? 12 : (h > 12 ? h - 12 : h);\n                return h;\n            },\n            \"M+\": function(t) {\n                return Time.timeComponent(t, \"minute\", \"floor\");\n            },\n            \"MM\": function(t) {\n                return Strings.padZeros(Time.timeModulo(t, \"minute\", \"floor\"), 2);\n            },\n            \"M\": function(t) {\n                return Time.timeModulo(t, \"minute\", \"floor\");\n            },\n            \"s+\": function(t) {\n                return Time.timeComponent(t, \"second\", \"floor\");\n            },\n            \"ss\": function(t) {\n                return Strings.padZeros(Time.timeModulo(t, \"second\", \"floor\"), 2);\n            },\n            \"s\": function(t) {\n                return Time.timeModulo(t, \"second\", \"floor\");\n            },\n            \"mmm\": function(t) {\n                return ((new Date(t)).toUTCString().split(\" \"))[2];\n            },\n            \"mm\": function(t) {\n                return Strings.padZeros(Time.timeComponentGet(t, \"month\") + 1, 2);\n            },\n            \"m\": function(t) {\n                return Time.timeComponentGet(t, \"month\") + 1;\n            },\n            \"d+\": function(t) {\n                return Time.timeComponent(t, \"day\", \"floor\");\n            },\n            \"dddd\": function(t) {\n                var map = {\n                    2: \"s\",\n                    3: \"nes\",\n                    4: \"rs\",\n                    6: \"ur\"\n                };\n                return (new Date(t)).toUTCString().substring(0, 3) + (map[Time.timeComponentGet(t, \"weekday\")] || \"\") + \"day\";\n            },\n            \"ddd\": function(t) {\n                return (new Date(t)).toUTCString().substring(0, 3);\n            },\n            \"dd\": function(t) {\n                return Strings.padZeros(Time.timeComponentGet(t, \"day\") + 1, 2);\n            },\n            \"d\": function(t) {\n                return Time.timeComponentGet(t, \"day\") + 1;\n            },\n            \"yyyy\": function(t) {\n                return Time.timeComponentGet(t, \"year\");\n            },\n            \"yy\": function(t) {\n                return Time.timeComponentGet(t, \"year\") % 100;\n            },\n            \"l+\": function(t) {\n                return t.getTime();\n            },\n            \"l\": function(t) {\n                return Strings.padZeros(Time.timeComponentGet(t, \"millisecond\"), 3);\n            },\n            \"L\": function(t) {\n                return Strings.padZeros(Math.floor(Time.timeComponentGet(t, \"millisecond\") / 10), 2);\n            },\n            \"tt\": function(t) {\n                return Time.timeModulo(t, \"hour\", \"floor\") < 12 ? 'am' : 'pm';\n            },\n            \"t\": function(t) {\n                return Time.timeModulo(t, \"hour\", \"floor\") < 12 ? 'a' : 'p';\n            },\n            \"TT\": function(t) {\n                return Time.timeModulo(t, \"hour\", \"floor\") < 12 ? 'AM' : 'PM';\n            },\n            \"T\": function(t) {\n                return Time.timeModulo(t, \"hour\", \"floor\") < 12 ? 'A' : 'P';\n            },\n            \"o\": function(t, bias) {\n                bias = Math.floor(bias / 1000 / 60);\n                return (bias > 0 ? \"-\" : \"+\") + Strings.padZeros(Math.floor(Math.abs(bias) / 60) * 100 + Math.abs(bias) % 60, 4);\n            }\n\n        },\n\n        ELAPSED_HOURS_MINUTES_SECONDS: \"h+:MM:ss\",\n        ELAPSED_MINUTES_SECONDS: \"M+:ss\",\n        FULL_YEAR: \"yyyy\",\n        LETTER_MONTH: \"mmm\",\n        LETTER_MONTH_AND_DAY: \"mmm d\",\n        WEEKDAY: \"ddd\",\n        HOURS_MINUTES_TT: \"hh:MM tt\",\n\n\n        /**\n         * Format a given time w.r.t. a given time format\n         * \n         * @param {string} timeFormat a time format string\n         * @param {int} time time as integer to be formatted\n         * @param {int} timezone timezone bias (optional)\n         * @return {string} formatted time\n         * \n         */\n        format: function(timeFormat, time, timezone) {\n            time = time === 0 ? time : time || Time.now();\n            var timezoneTime = Time.timeToTimezoneBasedDate(time, timezone);\n            var bias = Time.timezoneBias(timezone, time);\n            var result = timeFormat;\n            var replacers = [];\n            Objs.iter(this.formatMappings, function(formatter, key) {\n                if (result.indexOf(key) >= 0) {\n                    var i = replacers.length;\n                    replacers.push(formatter(timezoneTime, bias));\n                    result = result.replace(key, \"$\" + i + \"$\");\n                }\n            }, this);\n            for (var i = 0; i < replacers.length; ++i)\n                result = result.replace(\"$\" + i + \"$\", replacers[i]);\n            return result;\n        },\n\n        /**\n         * Format the month as a three letter string\n         * \n         * @param {int} month month as an int\n         * @return {string} three letter month string\n         */\n        monthString: function(month) {\n            return this.format(\"mmm\", Time.encodePeriod({\n                month: month\n            }));\n        },\n\n        /**\n         * Format the weekday as a three letter string\n         * \n         * @param {int} weekday weekday as an int\n         * @return {string} three letter weekday string\n         */\n        weekdayString: function(weekday) {\n            return this.format(\"ddd\", Time.encodePeriod({\n                weekday: weekday\n            }));\n        },\n\n        /**\n         * Returns the week number\n         *\n         * @param {int} time time\n         * @param {int} timezone timezone\n         * @return {int} number of the week in a year\n         */\n        weekNumber: function(time, timezone) {\n            var base = new Date(time + Time.timezoneBias(timezone, time));\n            var d = new Date(Date.UTC(base.getFullYear(), base.getMonth(), base.getDate()));\n            var dayNum = d.getUTCDay() || 7;\n            d.setUTCDate(d.getUTCDate() + 4 - dayNum);\n            var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n            return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);\n        },\n\n        // /**\n        //  * Format most significant part of date / time relative to current time\n        //  *\n        //  * @param {int} time date/time to be formatted\n        //  * @param {int} currentTime relative to current time (optional)\n        //  * @param {int} timezone time zone bias (optional)\n        //  * @return {string} formatted time\n        //  */\n        // formatRelativeMostSignificant: function(time, currentTime, timezone) {\n        //     currentTime = currentTime || Time.now();\n        //     var t = Time.decodeTime(time, timezone);\n        //     var c = Time.decodeTime(currentTime, timezone);\n        //     // Same day. Return time.\n        //     if (t.year === c.year && t.month === c.month && t.day === c.day)\n        //         return this.format('hh:MM tt', time, timezone);\n        //     // Less than 7 days. Return week day.\n        //     if (currentTime - time < 7 * 24 * 60 * 60 * 1000 && t.weekday !== c.weekday)\n        //         return this.format('dddd', time, timezone);\n        //     // Last 2 months?\n        //     if ((t.year === c.year && t.month + 1 >= c.month) || (t.year + 1 === c.year && t.month + 1 >= c.month + 12 - 1))\n        //         return this.format('mmm d', time, timezone);\n        //     // Last 11 month?\n        //     if (t.year === c.year || (t.year + 1 === c.year && t.month > c.month))\n        //         return this.format('mmm', time, timezone);\n        //     // Return year\n        //     return this.format('yyyy', time, timezone);\n        // },\n\n        /**\n         * Format most significant part of date / time relative to current time\n         *\n         * @param {int} time date/time to be formatted\n         * @param {int} currentTime relative to current time (optional)\n         * @param {int} timezone time zone bias (optional)\n         * @return {string} formatted time\n         */\n        formatRelativeMostSignificant: function(time, currentTime, timezone) {\n            if (time === Infinity)\n                return 'Someday';\n\n            currentTime = currentTime || Time.now();\n            var t = Time.decodeTime(time, timezone);\n            var c = Time.decodeTime(currentTime, timezone);\n\n            // Yesterday + time\n            if (t.year === c.year && t.month === c.month && t.day === c.day - 1)\n                return 'Yesterday ' + this.format('hh:MM tt', time, timezone);\n            // Today + time\n            if (t.year === c.year && t.month === c.month && t.day === c.day)\n                return 'Today ' + this.format('hh:MM tt', time, timezone);\n            // Tomorrow + time.\n            if (t.year === c.year && t.month === c.month && t.day === c.day + 1)\n                return 'Tomorrow ' + this.format('hh:MM tt', time, timezone);\n            // Less than 7 days. Return week day.\n            if (Math.abs(currentTime - time) < 7 * 24 * 60 * 60 * 1000 && t.weekday !== c.weekday)\n                return this.format('dddd', time, timezone);\n            // Last 2 months?\n            if ((t.year === c.year && t.month + 1 >= c.month) || (t.year + 1 === c.year && t.month + 1 >= c.month + 12 - 1))\n                return this.format('mmm d', time, timezone);\n            // Last 11 month?\n            if (t.year === c.year || (t.year + 1 === c.year && t.month > c.month))\n                return this.format('mmm', time, timezone);\n            // Return year\n            return this.format('yyyy', time, timezone);\n        }\n\n    };\n});\nScoped.define(\"module:Time\", [], function() {\n    /**\n     * Time Helper Functions\n     * \n     * All time routines are based on UTC time.\n     * The optional timezone parameter should be used as follows:\n     *    - undefined or false: UTC\n     *    - true: user's local time zone\n     *    - int value: actual time zone bias in minutes\n     *    \n     * @module BetaJS.Time\n     */\n    return {\n\n        __components: {\n            \"year\": {\n                \"set\": function(date, value) {\n                    date.setUTCFullYear(value);\n                },\n                \"get\": function(date) {\n                    return date.getUTCFullYear();\n                }\n            },\n            \"month\": {\n                \"set\": function(date, value) {\n                    date.setUTCMonth(value);\n                },\n                \"get\": function(date) {\n                    return date.getUTCMonth();\n                }\n            },\n            \"day\": {\n                \"dependencies\": {\n                    \"weekday\": true\n                },\n                \"set\": function(date, value) {\n                    date.setUTCDate(value + 1);\n                },\n                \"get\": function(date) {\n                    return date.getUTCDate() - 1;\n                },\n                \"milliseconds\": 24 * 60 * 60 * 1000\n            },\n            \"weekday\": {\n                \"dependencies\": {\n                    \"day\": true,\n                    \"month\": true,\n                    \"year\": true\n                },\n                \"set\": function(date, value) {\n                    date.setUTCDate(date.getUTCDate() + value - date.getUTCDay());\n                },\n                \"get\": function(date) {\n                    return date.getUTCDay();\n                }\n            },\n            \"hour\": {\n                \"set\": function(date, value) {\n                    date.setUTCHours(value);\n                },\n                \"get\": function(date) {\n                    return date.getUTCHours();\n                },\n                \"max\": 23,\n                \"milliseconds\": 60 * 60 * 1000\n            },\n            \"minute\": {\n                \"set\": function(date, value) {\n                    date.setUTCMinutes(value);\n                },\n                \"get\": function(date) {\n                    return date.getUTCMinutes();\n                },\n                \"max\": 59,\n                \"milliseconds\": 60 * 1000\n            },\n            \"second\": {\n                \"set\": function(date, value) {\n                    date.setUTCSeconds(value);\n                },\n                \"get\": function(date) {\n                    return date.getUTCSeconds();\n                },\n                \"max\": 59,\n                \"milliseconds\": 1000\n            },\n            \"millisecond\": {\n                \"set\": function(date, value) {\n                    date.setUTCMilliseconds(value);\n                },\n                \"get\": function(date) {\n                    return date.getUTCMilliseconds();\n                },\n                \"max\": 999,\n                \"milliseconds\": 1\n            }\n        },\n\n        /**\n         * Reads the current timezone offset.\n         *\n         * @param {int} time time in milliseconds\n         *\n         * @return {int} timezone offset in minutes\n         */\n        getTimezoneOffset: function(time) {\n            if (this.__timezoneOffset !== undefined) {\n                return this.__timezoneOffset;\n            }\n            return time ? (new Date(time).getTimezoneOffset()) : new Date().getTimezoneOffset();\n        },\n\n        /**\n         * Overwrites the current timezone offset.\n         *\n         * @param {int} timezoneOffset timezone offset in minutes (undefined to disable overwrite)\n         */\n        setTimezoneOffset: function(timezoneOffset) {\n            this.__timezoneOffset = timezoneOffset;\n        },\n\n        /**\n         * Computes the timezone bias in milliseconds from UTC\n         * \n         * @param {int} timezone bias in minutes; can be true to use current time zone; can be undefined to use UTC\n         * @param {int} time time in milliseconds\n         * \n         * @return {int} timezone bias in milliseconds\n         */\n        timezoneBias: function(timezone, time) {\n            if (timezone === true)\n                timezone = this.getTimezoneOffset(time);\n            if (typeof timezone == \"undefined\" || timezone === null || timezone === false)\n                timezone = 0;\n            return timezone * 60 * 1000;\n        },\n\n        /**\n         * Given a time in milliseconds, compute a Date object.\n         * \n         * @param {int} t time in milliseconds\n         * @param {int} timezone timezone (optional)\n         * \n         * @return {object} Date object\n         */\n        timeToDate: function(t, timezone) {\n            return new Date(t + this.timezoneBias(timezone, t));\n        },\n\n        /**\n         * Given a time as a Date object, return UTC time in milliseconds.\n         * \n         * @param {object} d time as Date object\n         * @param {int} timezone timezone (optional)\n         * \n         * @return {int} UTC time in milliseconds\n         */\n        dateToTime: function(d, timezone) {\n            return d.getTime() - this.timezoneBias(timezone, d.getTime());\n        },\n\n        /**\n         * Given a time in milliseconds, compute a timezone-based Date object.\n         * \n         * @param {int} t time in milliseconds\n         * @param {int} timezone timezone (optional)\n         * \n         * @return {object} timezone-based Date object\n         */\n        timeToTimezoneBasedDate: function(t, timezone) {\n            return new Date(t - this.timezoneBias(timezone, t));\n        },\n\n        /**\n         * Given a time as a timezone-based Date object, return UTC time in milliseconds.\n         * \n         * @param {object} d time as a timezone-based Date object\n         * @param {int} timezone timezone (optional)\n         * \n         * @return {int} UTC time in milliseconds\n         */\n        timezoneBasedDateToTime: function(d, timezone) {\n            return d.getTime() + this.timezoneBias(timezone, d.getTime());\n        },\n\n        /**\n         * Decode time into its time components\n         *\n         * @param {int} t time in milliseconds\n         * @param {int} timezone timezone (optional)\n         * \n         * @return {object} decoded time component\n         */\n        decodeTime: function(t, timezone) {\n            var d = this.timeToTimezoneBasedDate(t || this.now(), timezone);\n            var result = {};\n            for (var key in this.__components)\n                result[key] = this.__components[key].get(d);\n            return result;\n        },\n\n        /**\n         * Encode time from components to UTC time\n         * \n         * @param {object} data component data\n         * @param {int} timezone timezone (optional)\n         * \n         * @return {int} encoded UTC time\n         */\n        encodeTime: function(data, timezone) {\n            return this.updateTime(this.now(), data, timezone);\n        },\n\n        /**\n         * Encode time period data from components to milliseconds\n         * \n         * @param {object} data component data\n         * \n         * @return {int} encoded milliseconds\n         */\n        encodePeriod: function(data) {\n            return this.incrementTime(0, data);\n        },\n\n        /**\n         * Updates a given time with respect to provided component data\n         * \n         * @param {int} t UTC time\n         * @param {object} data component data\n         * @param {int} timezone timezone (optional)\n         * \n         * @return {int} updated UTC time\n         */\n        updateTime: function(t, data, timezone) {\n            var d = this.timeToTimezoneBasedDate(t, timezone);\n            for (var key in data)\n                this.__components[key].set(d, data[key]);\n            return this.timezoneBasedDateToTime(d, timezone);\n        },\n\n        /**\n         * Returns the current time in milliseconds\n         * \n         * @param {int} timezone timezone (optional)\n         * \n         * @return {int} current time\n         */\n        now: function(timezone) {\n            return this.dateToTime(new Date(), timezone);\n        },\n\n        /**\n         * Returns the earliest time in the future in milliseconds that has not been queried before.\n         *\n         * @param {int} delta delta (optional, default 1)\n         * @param {int} timezone timezone (optional)\n         *\n         * @return {int} earliest time in the future\n         */\n        uniqueAtLeastNow: function(delta, timezone) {\n            var candidate = this.now(timezone);\n            if (this.__unique_at_least_now && this.__unique_at_least_now >= candidate)\n                candidate = this.__unique_at_least_now + (delta || 1);\n            this.__unique_at_least_now = candidate;\n            return candidate;\n        },\n\n        /**\n         * Returns the performance time in millseconds\n         * \n         * @return {float} performance time\n         */\n        perfNow: function() {\n            return typeof performance === \"undefined\" ? (new Date()).getTime() : performance.now();\n        },\n\n        /**\n         * Increments a given time with respect to provided component data\n         * \n         * @param {int} t UTC time\n         * @param {object} data component data\n         * \n         * @return {int} incremented UTC time\n         */\n        incrementTime: function(t, data) {\n            var d = this.timeToDate(t);\n            for (var key in data)\n                this.__components[key].set(d, this.__components[key].get(d) + data[key]);\n            return this.dateToTime(d);\n        },\n\n        /**\n         * Floors a given time with respect to a component key and all smaller components.\n         * \n         * @param {int} t time\n         * @param {string} key component key\n         * @param {int} timezone timezone (optional)\n         * \n         * @return {int} floored time\n         */\n        floorTime: function(t, key, timezone) {\n            var d = this.timeToTimezoneBasedDate(t, timezone);\n            var found = false;\n            for (var comp in this.__components) {\n                var c = this.__components[comp];\n                found = found || comp == key;\n                if (found && (!c.dependencies || !c.dependencies[key]))\n                    c.set(d, 0);\n            }\n            return this.timezoneBasedDateToTime(d, timezone);\n        },\n\n        /**\n         * Computes how long a specific time is ago from now.\n         * \n         * @param {int} t time\n         * @param {int} timezone timezone (optional)\n         * \n         * @return {int} milliseconds ago\n         */\n        ago: function(t, timezone) {\n            return this.now(timezone) - t;\n        },\n\n        /**\n         * Returns the multiplicity of a time component given a time.\n         * \n         * @param {int} t time\n         * @param {string} key component key\n         * @param {function} rounding function (default is floor)\n         * \n         * @return {int} multiplicity of time\n         */\n        timeComponent: function(t, key, round) {\n            return Math[round || \"floor\"](t / this.__components[key].milliseconds);\n        },\n\n        /**\n         * Returns the value of a time component given a time.\n         * \n         * @param {int} t time\n         * @param {string} key component key\n         * @param {int} timezone timezone (optional)\n         * \n         * @return {int} value of time\n         */\n        timeComponentGet: function(t, key, timezone) {\n            return this.__components[key].get(this.timeToTimezoneBasedDate(t, timezone));\n        },\n\n        /**\n         * Returns the remainder of a time component given a time.\n         * \n         * @param {int} t time\n         * @param {string} key component key\n         * @param {function} rounding function (default is floor)\n         * \n         * @return {int} remainder of time\n         */\n        timeModulo: function(t, key, round) {\n            return this.timeComponent(t, key, round) % (this.__components[key].max + 1);\n        }\n\n    };\n\n});\nScoped.define(\"module:Trees.TreeNavigator\", function() {\n\n    /**\n     * Abstract Tree Navigator Mixin\n     * \n     * @mixin BetaJS.Trees.TreeNavigator\n     */\n    return {\n\n        /**\n         * Returns the root node of a tree.\n         * \n         * @return {object} Root node\n         */\n        nodeRoot: function() {},\n\n        /**\n         * Retrusns the id of a node.\n         * \n         * @param {object} node Node\n         * @return {string} Id of node\n         */\n        nodeId: function(node) {},\n\n        /**\n         * Returns the parent of a node.\n         * \n         * @param {object} node Node\n         * @return {object} Parent node\n         */\n        nodeParent: function(node) {},\n\n        /**\n         * Returns the children of a node.\n         * \n         * @param {object} node Node\n         * @return {array} Children of the node\n         */\n        nodeChildren: function(node) {},\n\n        /**\n         * Watches a node for changes.\n         * \n         * @param {object} node Node\n         * @param {function} func Change callback function\n         * @param {object} context Optional change callback context\n         */\n        nodeWatch: function(node, func, context) {},\n\n        /**\n         * Unwatches a node for changes.\n         * \n         * @param {object} node Node\n         * @param {function} func Change callback function\n         * @param {object} context Optional change callback context\n         */\n        nodeUnwatch: function(node, func, context) {},\n\n        /**\n         * Returns the data associated with a node.\n         * \n         * @param {object} node Node\n         * @return {object} Node data\n         */\n        nodeData: function(node) {}\n\n    };\n});\n\n\nScoped.define(\"module:Trees.TreeQueryEngine\", [\n    \"module:Class\",\n    \"module:Parser.Lexer\",\n    \"module:Trees.TreeQueryObject\"\n], function(Class, Lexer, TreeQueryObject, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Tree Query Engine Class\n         * \n         * @class BetaJS.Trees.TreeQueryEngine\n         */\n        return {\n\n            /**\n             * Create a new instance.\n             * \n             * @param {object} navigator Navigator instance\n             */\n            constructor: function(navigator) {\n                inherited.constructor.call(this);\n                this.__navigator = navigator;\n                this.__lexer = this._auto_destroy(new Lexer({\n                    \"<\\\\+\": {\n                        token: \"Up\"\n                    },\n                    \"<\": {\n                        token: \"Up\",\n                        single: true\n                    },\n                    \">\\\\+\": {\n                        token: \"Down\"\n                    },\n                    \">\": {\n                        token: \"Down\",\n                        single: true\n                    },\n                    \"\\\\[\\s*([a-zA-Z]+)\\s*=\\s*\\'([^']*)\\'\\s*\\\\]\": {\n                        token: \"Selector\",\n                        key: \"$1\",\n                        value: \"$2\"\n                    },\n                    \"\\\\[\\s*([a-zA-Z]+)\\s*=\\s*\\\"([^']*)\\\"\\s*\\\\]\": {\n                        token: \"Selector\",\n                        key: \"$1\",\n                        value: \"$2\"\n                    },\n                    \"\\s\": null\n                }));\n            },\n\n            /**\n             * Query the tree.\n             * \n             * @param {object} node Node to start the query from\n             * @param {string} query Query string\n             * \n             * @return {object} Tree query object for the query\n             */\n            query: function(node, query) {\n                return new TreeQueryObject(this.__navigator, node, this.__lexer.lex(query));\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Trees.TreeQueryObject\", [\n    \"module:Class\",\n    \"module:Events.EventsMixin\",\n    \"module:Objs\",\n    \"module:Types\"\n], function(Class, EventsMixin, Objs, Types, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [EventsMixin, function(inherited) {\n\n        /**\n         * Object representing a tree query on a node\n         *\n         * @class BetaJS.Trees.TreeQueryObject\n         */\n        return {\n\n            /**\n             * Create new instance.\n             * \n             * @param {object} navigator Navigator object\n             * @param {object} node Node of the query\n             * @param {object} query Lexed query\n             */\n            constructor: function(navigator, node, query) {\n                inherited.constructor.call(this);\n                this.__navigator = navigator;\n                this.__node = node;\n                this.__query = query;\n                this.__result = {};\n                this.__partials = {};\n                this.__ids = 0;\n                this.__register(node, 0, {});\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                Objs.iter(this.__partials, function(partials) {\n                    Objs.iter(partials.partials, function(partial) {\n                        this.__navigator.nodeUnwatch(partials.node, null, partial);\n                    }, this);\n                }, this);\n                inherited.destroy.call(this);\n            },\n\n            /**\n             * Returns the currently matching nodes.\n             * \n             * @return {array} Matching nodes.\n             */\n            result: function() {\n                var result = [];\n                Objs.iter(this.__result, function(value) {\n                    result.push(value.node);\n                });\n                return result;\n            },\n\n            __register: function(node, index) {\n                var node_id = this.__navigator.nodeId(node);\n                if (!this.__partials[node_id]) {\n                    this.__partials[node_id] = {\n                        node: node,\n                        partials: {}\n                    };\n                }\n                var partials = this.__partials[node_id];\n                this.__ids++;\n                var partial = {\n                    owner: partials,\n                    id: this.__ids,\n                    query_index_start: index,\n                    query_index_next: index,\n                    query_index_last: index,\n                    partial_match: false,\n                    partial_final: index >= this.__query.length,\n                    partial_data: false,\n                    partial_children: false,\n                    partial_parent: false,\n                    partial_star: false,\n                    parent: null,\n                    deps: {}\n                };\n                partials.partials[partial.id] = partial;\n                for (var i = partial.query_index_start; i < this.__query.length; ++i) {\n                    if (this.__query[i].token == \"Selector\")\n                        partial.partial_data = true;\n                    else {\n                        if (this.__query[i].token == \"Up\")\n                            partial.partial_parent = true;\n                        else if (this.__query[i].token == \"Down\")\n                            partial.partial_children = true;\n                        partial.partial_star = !this.__query[i].single;\n                        if (!partial.partial_star)\n                            partial.query_index_next = i + 1;\n                        break;\n                    }\n                    partial.query_index_next = i + 1;\n                    partial.partial_final = i + 1 == this.__query.length;\n                }\n                partial.query_index_last = partial.partial_star ? partial.query_index_next + 1 : partial.query_index_next;\n                var self = this;\n                this.__navigator.nodeWatch(node, function(action, node) {\n                    if (action == \"data\" && partial.partial_data)\n                        self.__update(partial);\n                    if (action == \"remove\")\n                        self.__unregisterPartial(partial);\n                    if (action == \"addChild\" && partial.partial_children && partial.partial_match)\n                        self.__addDependentPartial(partial, node);\n                }, partial);\n                this.__update(partial);\n                return partial;\n            },\n\n            __unregisterPartial: function(partial) {\n                var owner = partial.owner;\n                var node = owner.node;\n                var node_id = this.__navigator.nodeId(node);\n                if (partial.partial_final && this.__result[node_id]) {\n                    this.__result[node_id].count--;\n                    if (this.__result[node_id].count <= 0) {\n                        delete this.__result[node_id];\n                        /**\n                         * @event BetaJS.Trees.TreeQueryObject#remove\n                         */\n                        this.trigger(\"remove\", node);\n                        /**\n                         * @event BetaJS.Trees.TreeQueryObject#change\n                         */\n                        this.trigger(\"change\");\n                    }\n                }\n                Objs.iter(partial.deps, this.__unregisterPartial, this);\n                if (partial.parent)\n                    delete partial.parent.deps[partial.id];\n                this.__navigator.nodeUnwatch(node, null, partial);\n                delete owner.partials[partial.id];\n                if (Types.is_empty(owner.partials))\n                    delete this.__partials[node_id];\n            },\n\n            __addDependentPartial: function(partial, node) {\n                var partials = [];\n                partials.push(this.__register(node, partial.query_index_next));\n                if (partial.partial_star)\n                    partials.push(this.__register(node, partial.query_index_next + 1));\n                Objs.iter(partials, function(p) {\n                    partial.deps[p.id] = p;\n                    p.parent = partial;\n                }, this);\n            },\n\n            __update: function(partial) {\n                var matching = true;\n                var node = partial.owner.node;\n                var node_id = this.__navigator.nodeId(node);\n                var node_data = this.__navigator.nodeData(node);\n                for (var i = partial.query_index_start; i < partial.query_index_last; ++i) {\n                    var q = this.__query[i];\n                    if (q.token != \"Selector\")\n                        break;\n                    if (node_data[q.key] != q.value) {\n                        matching = false;\n                        break;\n                    }\n                }\n                if (matching == partial.partial_match)\n                    return;\n                partial.partial_match = matching;\n                if (matching) {\n                    if (partial.partial_final) {\n                        if (!this.__result[node_id]) {\n                            this.__result[node_id] = {\n                                node: node,\n                                count: 1\n                            };\n                            /**\n                             * @event BetaJS.Trees.TreeQueryObject#add\n                             */\n                            this.trigger(\"add\", node);\n                            /**\n                             * @event BetaJS.Trees.TreeQueryObject#change\n                             */\n                            this.trigger(\"change\");\n                        } else\n                            this.__result[node_id].count++;\n                    } else if (partial.partial_parent) {\n                        var parent = this.__navigator.nodeParent(node);\n                        if (parent)\n                            this.__addDependentPartial(partial, parent);\n                    } else if (partial.partial_children) {\n                        Objs.iter(this.__navigator.nodeChildren(node), function(child) {\n                            this.__addDependentPartial(partial, child);\n                        }, this);\n                    }\n                } else {\n                    if (partial.partial_final) {\n                        this.__result[node_id].count--;\n                        if (this.__result[node_id].count <= 0) {\n                            delete this.__result[node_id];\n                            /**\n                             * @event BetaJS.Trees.TreeQueryObject#remove\n                             */\n                            this.trigger(\"remove\", node);\n                            /**\n                             * @event BetaJS.Trees.TreeQueryObject#change\n                             */\n                            this.trigger(\"change\");\n                        }\n                    }\n                    Objs.iter(partial.deps, this.__unregisterPartial, this);\n                }\n            }\n        };\n    }]);\n});\nScoped.define(\"module:Types\", function() {\n    /**\n     * Type-Testing and Type-Parsing\n     * \n     * @module BetaJS.Types\n     */\n    return {\n        /**\n         * Returns whether argument is an object and is not null\n         *\n         * @param x argument\n         * @return true if x is an object\n         */\n        is_object_instance: function(x) {\n            return this.is_object(x) && !this.is_null(x);\n        },\n\n        /**\n         * Returns whether argument is an object\n         * \n         * @param x argument\n         * @return true if x is an object\n         */\n        is_object: function(x) {\n            return typeof x === \"object\";\n        },\n\n        /**\n         * Returns whether argument is an array\n         * \n         * @param x argument\n         * @return true if x is an array\n         */\n        is_array: function(x) {\n            return Array.isArray(x);\n        },\n\n        /**\n         * Returns whether argument is undefined (which is different from being\n         * null)\n         * \n         * @param x argument\n         * @return true if x is undefined\n         */\n        is_undefined: function(x) {\n            return typeof x === \"undefined\";\n        },\n\n        /**\n         * Returns whether argument is null (which is different from being\n         * undefined)\n         * \n         * @param x argument\n         * @return true if x is null\n         */\n        is_null: function(x) {\n            return x === null;\n        },\n\n        /**\n         * Returns whether argument is undefined or null\n         * \n         * @param x argument\n         * @return true if x is undefined or null\n         */\n        is_none: function(x) {\n            return this.is_undefined(x) || this.is_null(x);\n        },\n\n        /**\n         * Returns whether argument is defined (could be null)\n         * \n         * @param x argument\n         * @return true if x is defined\n         */\n        is_defined: function(x) {\n            return typeof x !== \"undefined\";\n        },\n\n        /**\n         * Returns whether argument is empty (undefined, null, an empty array or\n         * an empty object)\n         * \n         * @param x argument\n         * @return true if x is empty\n         */\n        is_empty: function(x) {\n            return this.is_none(x) || (this.is_array(x) && x.length === 0) || (this.is_object(x) && this.is_empty_object(x));\n        },\n\n        /**\n         * Returns whether object argument is empty\n         * \n         * @param x object argument\n         * @return true if x is empty\n         */\n        is_empty_object: function(x) {\n            for (var key in x)\n                return false;\n            return true;\n        },\n\n        /**\n         * Returns whether argument is a string\n         * \n         * @param x argument\n         * @return true if x is a a string\n         */\n        is_string: function(x) {\n            return typeof x === \"string\";\n        },\n\n        /**\n         * Returns whether argument is a function\n         * \n         * @param x argument\n         * @return true if x is a function\n         */\n        is_function: function(x) {\n            return typeof x === \"function\";\n        },\n\n        /**\n         * Returns whether argument is boolean\n         * \n         * @param x argument\n         * @return true if x is boolean\n         */\n        is_boolean: function(x) {\n            return typeof x === \"boolean\";\n        },\n\n        /**\n         * Compares two values\n         * \n         * If values are booleans, we compare them directly. If values are\n         * arrays, we compare them recursively by their components. Otherwise,\n         * we use localeCompare which compares strings.\n         * \n         * @param x left value\n         * @param y right value\n         * @return 1 if x > y, -1 if x < y and 0 if x == y\n         */\n        compare: function(x, y) {\n            if (this.is_boolean(x) && this.is_boolean(y))\n                return x === y ? 0 : (x ? 1 : -1);\n            if (this.is_array(x) && this.is_array(y)) {\n                var len_x = x.length;\n                var len_y = y.length;\n                var len = Math.min(len_x, len_y);\n                for (var i = 0; i < len; ++i) {\n                    var c = this.compare(x[i], y[i]);\n                    if (c !== 0)\n                        return c;\n                }\n                return len_x === len_y ? 0 : (len_x > len_y ? 1 : -1);\n            }\n            return x.localeCompare(y);\n        },\n\n        /**\n         * Parses a boolean string\n         * \n         * @param x boolean as a string\n         * @return boolean value\n         */\n        parseBool: function(x) {\n            if (this.is_boolean(x))\n                return x;\n            if (x === \"true\" || x === \"\")\n                return true;\n            if (x === \"false\")\n                return false;\n            return null;\n        },\n\n        /**\n         * Parses an array of type \"foo,bar\"\n         * \n         * @param x array as a string\n         * @return array\n         */\n        parseArray: function(x) {\n            return this.is_string(x) ? x.split(\",\") : x;\n        },\n\n        /**\n         * Returns the type of a given expression\n         * \n         * @param x expression\n         * @return type string\n         */\n        type_of: function(x) {\n            if (this.is_array(x))\n                return \"array\";\n            return typeof x;\n        },\n\n        /**\n         * Returns whether argument is a number\n         *\n         * @param x argument\n         * @return true if x is a number\n         */\n        isNumber: function(x) {\n            return typeof x === \"number\";\n        },\n\n        /**\n         * Parses an integer string\n         *\n         * @param x integer as a string\n         * @return integer value\n         */\n        parseInt: function(x) {\n            return this.isNumber(x) ? x : parseInt(x, 10);\n        },\n\n        /**\n         * Parses a float string\n         *\n         * @param x float as a string\n         * @return float value\n         */\n        parseFloat: function(x) {\n            return this.isNumber(x) ? x : parseFloat(x);\n        },\n\n        /**\n         * Parses a date time string\n         *\n         * @param x date time as a string\n         * @return integer value\n         */\n        parseDateTime: function(x) {\n            if (typeof x === \"number\" || this.is_none(x))\n                return x;\n            if (typeof x === \"object\")\n                x = x.toString();\n            var d = new Date(x);\n            return isNaN(d.getTime()) ? parseInt(x, 10) : d.getTime();\n        },\n\n        /**\n         * Parses a value given a specific type.\n         * \n         * @param x value to be parsed\n         * @param {string} type the specific type to be parsed (accepts: bool, boolean, int, integer, date, time, datetime, float, double)\n         * @return parsed value\n         */\n        parseType: function(x, type) {\n            switch (type.toLowerCase()) {\n                case \"bool\":\n                case \"boolean\":\n                    return this.parseBool(x);\n                case \"int\":\n                case \"integer\":\n                case \"number\":\n                    return this.parseInt(x);\n                case \"date\":\n                case \"time\":\n                case \"datetime\":\n                    return this.parseDateTime(x);\n                case \"float\":\n                case \"double\":\n                    return this.parseFloat(x);\n                case \"array\":\n                    return this.parseArray(x);\n                case \"jsonarray\":\n                    return typeof x === \"string\" ? JSON.parse(x) : x;\n                case \"object\":\n                case \"json\":\n                    return typeof x === \"string\" ? JSON.parse(x) : x;\n                case \"id\":\n                    return typeof x === \"object\" && x ? x.toString() : x;\n                default:\n                    return x;\n            }\n        },\n\n        /**\n         * Parses an object with given types.\n         * \n         * @param {object} data object with key value pairs\n         * @param {object} types object mapping keys to types\n         * \n         * @return {object} object with properly parsed types\n         */\n        parseTypes: function(data, types) {\n            var result = {};\n            for (var key in data)\n                result[key] = key in types ? this.parseType(data[key], types[key]) : data[key];\n            return result;\n        },\n\n        /**\n         * Returns the specific type of a JavaScript object\n         * \n         * @param {object} obj an object instance\n         * @return {string} the object type\n         */\n        objectType: function(obj) {\n            if (!this.is_object(obj))\n                return null;\n            var matcher = obj.toString().match(/\\[object (.*)\\]/);\n            return matcher ? matcher[1] : null;\n        },\n\n        /**\n         * Returns whether a given object is a pure object\n         * \n         * @param {object} obj an object instance\n         * @return {boolean} true if pure\n         */\n        is_pure_object: function(obj) {\n            return this.is_object(obj) && (obj.toString().toLowerCase() === '[object]' || obj.toString().toLowerCase() === '[object object]');\n        },\n\n        /**\n         * Takes a value of any type and recursively tries to aggressively replace strings by more specific types.\n         *\n         * @param data input data\n         *\n         * @returns typefied data\n         */\n        typefy: function(data) {\n            var simplify = function(data) {\n                var len = data.length;\n                [\"'\", '\"'].forEach(function(c) {\n                    if (data.indexOf(c) === 0 && data.lastIndexOf(c) === data.length - c.length)\n                        data = data.substring(c.length, data.length - 2 * c.length + 1);\n                });\n                data = data.trim();\n                return data.length < len ? simplify(data) : data;\n            };\n            switch (typeof(data)) {\n                case \"object\":\n                    if (!Array.isArray(data)) {\n                        for (var key in data)\n                            data[key] = this.typefy(data[key]);\n                        return data;\n                    }\n                    return data.map(this.typefy);\n                case \"string\":\n                    data = simplify(data);\n                    if (data === \"true\")\n                        return true;\n                    if (data === \"false\")\n                        return false;\n                    if (parseInt(data, 10) + \"\" === data)\n                        return parseInt(data, 10);\n                    try {\n                        if (JSON.parse(data)) return this.typefy(JSON.parse(data));\n                    } catch (e) {}\n                    return data;\n                default:\n                    return data;\n            }\n        }\n\n    };\n});\nScoped.define(\"module:Channels.Sender\", [\n    \"module:Class\",\n    \"module:Events.EventsMixin\"\n], function(Class, EventsMixin, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [EventsMixin,\n\n        /**\n         * Abstract Sender Channel Class\n         * \n         * @class BetaJS.Channels.Sender\n         */\n        {\n\n            /**\n             * Sends a message into the channel.\n             * \n             * @param {string} message Message string\n             * @param data Custom message data\n             * @param serializerInfo Custom serializer information\n             * @fires BetaJS.Channels.Sender#send\n             */\n            send: function(message, data, serializerInfo) {\n                /**\n                 * @event BetaJS.Channels.Sender#send\n                 */\n                this.trigger(\"send\", message, data);\n                this._send(message, data, serializerInfo);\n            },\n\n            /**\n             * Protected function for sending the message.\n             * \n             * @param {string} message Message string\n             * @param data Custom message data\n             * @param serializerInfo Custom serializer information\n             */\n            _send: function(message, data, serializerInfo) {},\n\n            /**\n             * Connect sender directly to a receiver.\n             *\n             * @param {object} receiver receiver object\n             */\n            connectToReceiver: function(receiver) {\n                receiver.connectToSender(this);\n                return this;\n            }\n\n\n        }\n    ]);\n});\n\n\nScoped.define(\"module:Channels.Receiver\", [\n    \"module:Class\",\n    \"module:Events.EventsMixin\"\n], function(Class, EventsMixin, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [EventsMixin,\n\n        /**\n         * Abstract Receiver Channel Class\n         * \n         * @class BetaJS.Channels.Receiver\n         */\n        {\n\n            /**\n             * Protected function for receiving the message.\n             * \n             * @param {string} message Message string\n             * @param data Custom message data\n             * @fires BetaJS.Channels.Receiver#receive\n             */\n            _receive: function(message, data) {\n                /**\n                 * @event BetaJS.Channels.Receiver#receive\n                 */\n                this.trigger(\"receive\", message, data);\n                this.trigger(\"receive:\" + message, data);\n            },\n\n            /**\n             * Connect receiver directly to a sender.\n             *\n             * @param {object} sender sender object\n             */\n            connectToSender: function(sender) {\n                this.on(\"receive\", sender.send, sender);\n                return this;\n            }\n\n        }\n    ]);\n});\n\n\nScoped.define(\"module:Channels.ReceiverSender\", [\n    \"module:Channels.Sender\",\n    \"module:Channels.Receiver\",\n    \"module:Async\"\n], function(Sender, Receiver, Async, scoped) {\n    return Sender.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * ReceiverSender Class, directly connecting this sender to a receiver.\n         * \n         * @class BetaJS.Channels.ReceiverSender\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {object} receiver Receiver object\n             * @param {boolean} async Handle every invocation asynchronously\n             * @param {int} delay Delay time for asynchronous invocation\n             * @param {boolean} json Convert to JSON (optional, false)\n             */\n            constructor: function(receiver, async, delay, json) {\n                inherited.constructor.call(this);\n                this.__receiver = receiver;\n                this.__async = async;\n                this.__delay = delay;\n                this.__json = json;\n            },\n\n            /**\n             * @override\n             */\n            _send: function(message, data, serializerInfo) {\n                if (this.__json)\n                    data = JSON.parse(JSON.stringify(data));\n                if (this.__async) {\n                    Async.eventually(function() {\n                        this.__receiver._receive(message, data);\n                    }, this, this.__delay);\n                } else\n                    this.__receiver._receive(message, data);\n            }\n\n        };\n    }, {\n\n        createPair: function(async, delay, json) {\n            var receiver = new Receiver();\n            return {\n                sender: new this(receiver, async, delay, json),\n                receiver: receiver\n            };\n        }\n\n    });\n});\n\n\nScoped.define(\"module:Channels.ReadySender\", [\n    \"module:Channels.Sender\"\n], function(Sender, scoped) {\n    return Sender.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * ReadySender class that buffers messages until sender is ready.\n         * \n         * @class BetaJS.Channels.ReadySender\n         */\n        return {\n\n            /**\n             * Instantiates a Ready Sender instance.\n             * \n             * @param {object} sender sender instance that should be used as delegate\n             */\n            constructor: function(sender) {\n                inherited.constructor.call(this);\n                this.__cache = [];\n                this.__sender = sender;\n            },\n\n            /**\n             * @override\n             */\n            _send: function(message, data, serializerInfo) {\n                if (this.__ready)\n                    this.__sender.send(message, data, serializerInfo);\n                else\n                    this.__cache.push({\n                        message: message,\n                        data: data,\n                        serializerInfo: serializerInfo\n                    });\n            },\n\n            /**\n             * Allow all messages to be flushed directly to the sender delegate.\n             * \n             */\n            ready: function() {\n                this.__ready = true;\n                this.__cache.forEach(function(entry) {\n                    this.__sender.send(entry.message, entry.data, entry.serializerInfo);\n                }, this);\n                this.__cache = [];\n            },\n\n            /**\n             * Stop all messages being flushed.\n             * \n             */\n            unready: function() {\n                this.__ready = false;\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Channels.SenderMultiplexer\", [\"module:Channels.Sender\"], function(Sender, scoped) {\n    return Sender.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Channel Sender Multiplexer Class\n         * \n         * @class BetaJS.Channels.SenderMultiplexer\n         * \n         */\n        return {\n\n            /**\n             * Instantiates the Multiplexer Sender\n             * \n             * @param {object} sender sender channel\n             * @param {string} prefix prefix string for multiplexing\n             * \n             */\n            constructor: function(sender, prefix) {\n                inherited.constructor.call(this);\n                this.__sender = sender;\n                this.__prefix = prefix;\n            },\n\n            _send: function(message, data, serializerInfo) {\n                this.__sender.send(this.__prefix + \":\" + message, data, serializerInfo);\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Channels.ReceiverMultiplexer\", [\"module:Channels.Receiver\", \"module:Strings\"], function(Receiver, Strings, scoped) {\n    return Receiver.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Channel Receiver Multiplexer Class\n         * \n         * @class BetaJS.Channels.ReceiverMultiplexer\n         * \n         */\n        return {\n\n            /**\n             * Instantiates the Multiplexer Receiver\n             * \n             * @param {object} receiver receiver channel\n             * @param {string} prefix prefix string for de-multiplexing\n             * \n             */\n            constructor: function(receiver, prefix) {\n                inherited.constructor.call(this);\n                this.__receiver = receiver;\n                this.__prefix = prefix;\n                this.__receiver.on(\"receive\", function(message, data) {\n                    if (Strings.starts_with(message, this.__prefix + \":\"))\n                        this._receive(Strings.strip_start(message, this.__prefix + \":\"), data);\n                }, this);\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Channels.SimulatorSender\", [\n    \"module:Channels.Sender\"\n], function(Sender, scoped) {\n    return Sender.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Sender Simulating Online / Offline behavior\n         * \n         * @class BetaJS.Channels.SimulatorSender\n         */\n        return {\n\n            /**\n             * Attribute for setting / online offline\n             * \n             * @member {boolean} online online / offline setting\n             */\n            online: true,\n\n            /**\n             * Create a new instance given an inner sender channel.\n             * \n             * @param {object} sender sender instance\n             * \n             * @return {object} simulated sender instance\n             */\n            constructor: function(sender) {\n                inherited.constructor.call(this);\n                this.__sender = sender;\n            },\n\n            _send: function(message, data) {\n                if (this.online)\n                    this.__sender.send(message, data);\n            }\n\n        };\n    });\n});\n\n\n\nScoped.define(\"module:Channels.SimulatorReceiver\", [\n    \"module:Channels.Receiver\"\n], function(Receiver, scoped) {\n    return Receiver.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Receiver Simulating Online / Offline behavior\n         *\n         * @class BetaJS.Channels.SimulatorReceiver\n         */\n        return {\n\n            /**\n             * Attribute for setting / online offline\n             *\n             * @member {boolean} online online / offline setting\n             */\n            online: true,\n\n            /**\n             * Create a new instance given an inner receiver channel.\n             *\n             * @param {object} receiver receiver instance\n             *\n             * @return {object} simulated receiver instance\n             */\n            constructor: function(receiver) {\n                inherited.constructor.call(this);\n                this.__receiver = receiver;\n                this.__receiver.on(\"receive\", function(message, data) {\n                    if (this.online)\n                        this._receive(message, data);\n                }, this);\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Channels.TransportChannel\", [\n    \"module:Class\",\n    \"module:Objs\",\n    \"module:Timers.Timer\",\n    \"module:Time\",\n    \"module:Promise\"\n], function(Class, Objs, Timer, Time, Promise, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Transport Channel for reliable transmission of data.\n         * \n         * @class BetaJS.Channels.TransportChannel\n         */\n        return {\n\n            /**\n             * Instantiates TransportChannel\n             * \n             * @param {object} sender Sender Channel\n             * @param {object} receiver Receiver Channel\n             * @param {object} options options (timeout, tries, timer, auto_destroy) for configuring the Transport Channel\n             */\n            constructor: function(sender, receiver, options) {\n                inherited.constructor.call(this);\n                this.__sender = sender;\n                this.__receiver = receiver;\n                this.__options = Objs.extend(options, {\n                    timeout: 10000,\n                    tries: 1,\n                    timer: 500\n                });\n                if (this.__options.auto_destroy) {\n                    this.auto_destroy(sender);\n                    this.auto_destroy(receiver);\n                }\n                this.__receiver.on(\"receive:send\", function(data) {\n                    this.__reply(data);\n                }, this);\n                this.__receiver.on(\"receive:reply\", function(data) {\n                    this.__complete(data);\n                }, this);\n                this.__sent_id = 0;\n                this.__sent = {};\n                this.__received = {};\n                this.__timer = this._auto_destroy(new Timer({\n                    delay: this.__options.timer,\n                    context: this,\n                    fire: this.__maintenance\n                }));\n            },\n\n            /**\n             * Callback function for replying to a message. Needs to be overwritten from the outside.\n             * \n             * @param {string} message message string\n             * @param {object} data data object\n             * \n             * @return {object} promise object containin the reply data or an error\n             */\n            _reply: function(message, data) {},\n\n            /**\n             * Send a message through the channel.\n             * \n             * @param {string} message message string\n             * @param {object} data data object\n             * @param {object} options options (stateless) for sending the message\n             * \n             * @return {object} promise object\n             */\n            send: function(message, data, options) {\n                var promise = Promise.create();\n                options = options || {};\n                if (options.stateless) {\n                    this.__sender.send(\"send\", {\n                        message: message,\n                        data: data,\n                        stateless: true\n                    }, options.serializerInfo);\n                    promise.asyncSuccess(true);\n                } else {\n                    this.__sent_id++;\n                    this.__sent[this.__sent_id] = {\n                        message: message,\n                        data: data,\n                        tries: 1,\n                        time: Time.now(),\n                        id: this.__sent_id,\n                        promise: promise\n                    };\n                    this.__sender.send(\"send\", {\n                        message: message,\n                        data: data,\n                        id: this.__sent_id\n                    }, options.serializerInfo);\n                }\n                return promise;\n            },\n\n            __reply: function(data) {\n                if (data.stateless) {\n                    this._reply(data.message, data.data);\n                    return;\n                }\n                if (!this.__received[data.id]) {\n                    this.__received[data.id] = data;\n                    this.__received[data.id].time = Time.now();\n                    this.__received[data.id].returned = false;\n                    this.__received[data.id].success = false;\n                    Promise.value(this._reply(data.message, data.data)).success(function(result) {\n                        this.__received[data.id].reply = result;\n                        this.__received[data.id].success = true;\n                    }, this).error(function(error) {\n                        if (error && error.constructor && error.constructor === Error)\n                            error = error.toString();\n                        this.__received[data.id].reply = error;\n                    }, this).callback(function() {\n                        this.__received[data.id].returned = true;\n                        this.__sender.send(\"reply\", {\n                            id: data.id,\n                            reply: data.reply,\n                            success: data.success\n                        });\n                    }, this);\n                } else if (this.__received[data.id].returned) {\n                    this.__sender.send(\"reply\", {\n                        id: data.id,\n                        reply: data.reply,\n                        success: data.success\n                    });\n                }\n            },\n\n            __complete: function(data) {\n                if (this.__sent[data.id]) {\n                    var promise = this.__sent[data.id].promise;\n                    promise[data.success ? \"asyncSuccess\" : \"asyncError\"](data.reply);\n                    if (this.__sent)\n                        delete this.__sent[data.id];\n                }\n            },\n\n            __maintenance: function() {\n                var now = Time.now();\n                for (var received_key in this.__received) {\n                    var received = this.__received[received_key];\n                    if (received.time + this.__options.tries * this.__options.timeout <= now)\n                        delete this.__received[received_key];\n                }\n                for (var sent_key in this.__sent) {\n                    var sent = this.__sent[sent_key];\n                    if (sent.time + sent.tries * this.__options.timeout <= now) {\n                        if (sent.tries < this.__options.tries) {\n                            sent.tries++;\n                            this.__sender.send(\"send\", {\n                                message: sent.message,\n                                data: sent.data,\n                                id: sent.id\n                            });\n                        } else {\n                            sent.promise.asyncError({\n                                message: sent.message,\n                                data: sent.data\n                            });\n                            delete this.__sent[sent_key];\n                        }\n                    }\n                }\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Classes.ConditionalInstance\", [\n    \"module:Class\",\n    \"module:Objs\"\n], function(Class, Objs, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Conditional Instance Class for registering and creating particular flavors of a certain class under particular conditions\n         * \n         * @class BetaJS.Classes.ConditionalInstance\n         */\n        return {\n\n            /**\n             * Instantiates a particular flavor of a ConditionalInstance\n             * \n             * @param {object} options Options for the instance\n             */\n            constructor: function(options) {\n                inherited.constructor.call(this);\n                this._options = this.cls._initializeOptions(options);\n            }\n\n        };\n    }, {\n\n        /**\n         * Initialize given options with potentially additional parameters\n         * \n         * @param {object} options Given options\n         * @return {object} Initialized options\n         * \n         * @static\n         */\n        _initializeOptions: function(options) {\n            return options;\n        },\n\n        /**\n         * Determines whether a set of options is supported by this flavor of a ConditionalInstance\n         * \n         * @param {object} options set of options\n         * @return {boolean} true if supported\n         * \n         * @static\n         */\n        supported: function(options) {\n            return false;\n        }\n\n    }, {\n\n        __registry: [],\n\n        /**\n         * Registers a particular flavor of a ConditionalInstance\n         * \n         * @param {object} cls flavor class\n         * @param {int} priority priority of this class; the higher the priority the more likely it is to be instantiated\n         * \n         * @static\n         */\n        register: function(cls, priority) {\n            this.__registry.push({\n                cls: cls,\n                priority: priority\n            });\n        },\n\n        /**\n         * Determines the best match of all registered flavors, given a set of options.\n         * \n         * @param {object} options Set of options\n         * @return {object} flavor class being the best match\n         * \n         * @static\n         */\n        match: function(options) {\n            options = this._initializeOptions(options);\n            var bestMatch = null;\n            Objs.iter(this.__registry, function(entry) {\n                if ((!bestMatch || bestMatch.priority < entry.priority) && entry.cls.supported(options))\n                    bestMatch = entry;\n            }, this);\n            return bestMatch;\n        },\n\n        /**\n         * Instantiates the best match.\n         * \n         * @param {object} options Set of options\n         * @return {object} Instance of best match\n         * \n         * @static\n         */\n        create: function(options) {\n            var match = this.match(options);\n            return match ? new match.cls(options) : null;\n        },\n\n        /**\n         * Determines whether there is any support for a given set of options.\n         * \n         * @param {object} options Set of options\n         * @return {boolean} True if there is at least one match.\n         * \n         * @static\n         */\n        anySupport: function(options) {\n            return this.match(options) !== null;\n        }\n\n    });\n});\n\n\n\n\nScoped.define(\"module:Classes.OptimisticConditionalInstance\", [\n    \"module:Class\",\n    \"module:Objs\",\n    \"module:Promise\"\n], function(Class, Objs, Promise, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * OptimisticConditionalInstance for registering and optimistically creating particular flavors of a certain class under particular conditions\n         * \n         * @class BetaJS.Classes.OptimisticConditionalInstance\n         */\n        return {\n\n            /**\n             * Instantiates a particular flavor of a OptimisticConditionalInstance\n             * \n             * @param {object} options Options for the instance\n             * @param {object} transitionals Particular transitional data that should be passed on from one instance to the next\n             */\n            constructor: function(options, transitionals) {\n                inherited.constructor.call(this);\n                this._transitionals = {};\n            },\n\n            /**\n             * Returns an initialization promise.\n             * \n             * @return {object} Initialization promise\n             */\n            _initializer: function() {\n                // returns a promise\n            },\n\n            /**\n             * Tries to initialize this instance.\n             * \n             * @return {object} Success promise\n             */\n            _initialize: function() {\n                return this._initializer().success(function() {\n                    this._afterInitialize();\n                }, this);\n            },\n\n            /**\n             * Returns the current set of transitionals.\n             * \n             * @return {object} Set of transitionals\n             */\n            transitionals: function() {\n                return this._transitionals;\n            },\n\n            /**\n             * Will be called after an instance has been initialized.\n             * \n             */\n            _afterInitialize: function() {\n                // setup\n            }\n\n        };\n    }, {}, {\n\n        __registry: [],\n\n        /**\n         * Registers a particular flavor of an OptimisticConditionalInstance\n         * \n         * @param {object} cls flavor class\n         * @param {int} priority priority of this class; the higher the priority the more likely it is to be instantiated\n         * \n         * @static\n         */\n        register: function(cls, priority) {\n            this.__registry.push({\n                cls: cls,\n                priority: priority\n            });\n        },\n\n        /**\n         * Instantiates the best match.\n         * \n         * @param {object} options Set of options\n         * @return {object} Instance of best match as a promise\n         * \n         * @static\n         */\n        create: function(options) {\n            var promise = Promise.create();\n            var reg = Objs.clone(this.__registry, 1);\n            var transitionals = {};\n            var next = function() {\n                if (!reg.length) {\n                    promise.asyncError(true);\n                    return;\n                }\n                var p = -1;\n                var j = -1;\n                for (var i = 0; i < reg.length; ++i) {\n                    if (reg[i].priority > p) {\n                        p = reg[i].priority;\n                        j = i;\n                    }\n                }\n                var cls = reg[j].cls;\n                reg.splice(j, 1);\n                var instance = new cls(options, transitionals);\n                instance._initialize().error(function() {\n                    transitionals = instance.transitionals();\n                    instance.destroy();\n                    next.call(this);\n                }, this).success(function() {\n                    promise.asyncSuccess(instance);\n                });\n            };\n            next.call(this);\n            return promise;\n        }\n\n    });\n});\nScoped.define(\"module:Classes.LocaleMixin\", function() {\n\n    /**\n     * Locale Mixin for adding Locale access to a Class\n     * \n     * @mixin BetaJS.Classes.LocaleMixin\n     */\n    return {\n\n        _clearLocale: function() {},\n        _setLocale: function(locale) {},\n\n        /**\n         * Returns the current locale.\n         * \n         * @return {object} current locale\n         */\n        getLocale: function() {\n            return this.__locale;\n        },\n\n        /**\n         * Clears the current locale.\n         * \n         */\n        clearLocale: function() {\n            this._clearLocale();\n            this.__locale = null;\n        },\n\n        /**\n         * Sets the current locale\n         * \n         * @param {object} locale New locale\n         */\n        setLocale: function(locale) {\n            this.clearLocale();\n            this.__locale = locale;\n            this._setLocale(locale);\n        },\n\n        /**\n         * Returns whether a locale is set.\n         * \n         * @return {boolean} true if locale is set\n         */\n        isLocaleSet: function() {\n            return !!this.__locale;\n        },\n\n        /**\n         * Sets a locale if not locale is set.\n         * \n         * @param {object} locale New weak locale\n         */\n        setWeakLocale: function(locale) {\n            if (!this.isLocaleSet())\n                this.setLocale(locale);\n        }\n\n    };\n});\n\n\n\nScoped.define(\"module:Classes.LocaleAggregator\", [\n    \"module:Class\",\n    \"module:Classes.LocaleMixin\",\n    \"module:Objs\"\n], function(Class, LocaleMixin, Objs, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [LocaleMixin, function(inherited) {\n\n        /**\n         * Locale Aggregator Class for combining multiple locales into one.\n         * \n         * @class BetaJS.Classes.LocaleAggregator\n         */\n        return {\n\n            /**\n             * Create a Locale Aggregator instance.\n             * \n             */\n            constructor: function() {\n                inherited.constructor.call(this);\n                this.__locales = [];\n            },\n\n            /**\n             * Registers a new locale.\n             * \n             * @return {object} Locale\n             */\n            register: function(obj) {\n                this.__locales.push(obj);\n            },\n\n            /**\n             * @override\n             */\n            _clearLocale: function() {\n                Objs.iter(this.__locales, function(obj) {\n                    obj.clearLocale();\n                }, this);\n            },\n\n            /**\n             * @override\n             */\n            _setLocale: function(locale) {\n                Objs.iter(this.__locales, function(obj) {\n                    obj.setLocale(locale);\n                }, this);\n            }\n\n        };\n    }]);\n});\nScoped.define(\"module:Classes.ObjectCache\", [\n    \"module:Class\",\n    \"module:Objs\"\n], function(Class, Objs, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Object Cache Class\n         * \n         * @class BetaJS.Classes.ObjectCache\n         */\n        return {\n\n            /**\n             * Creates an instance.\n             * \n             * @param {function} keyFunction Function mapping objects to strings\n             * @param {object} keyFunctionCtx Optional key function context\n             */\n            constructor: function(keyFunction, keyFunctionCtx) {\n                inherited.constructor.call(this);\n                this.__keyFunction = keyFunction;\n                this.__keyFunctionCtx = keyFunctionCtx;\n                this.__cache = {};\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                Objs.iter(this.__cache, function(obj) {\n                    obj.off(null, null, this);\n                }, this);\n            },\n\n            /**\n             * Returns an object for a key.\n             * \n             * @param {string} key Key of an object\n             * \n             * @return {object} Object with that key\n             */\n            get: function(key) {\n                return this.__cache[key];\n            },\n\n            /**\n             * Registers an object in the cache.\n             * \n             * @param {object} obj Object to register.\n             * \n             */\n            register: function(obj) {\n                var key = this.__keyFunction.call(this.__keyFunctionCtx || this, obj);\n                if (this.__cache[key] && !this.__cache[key].destroyed())\n                    this.__cache[key].off(null, null, this);\n                this.__cache[key] = obj;\n                obj.on(\"destroy\", function() {\n                    delete this.__cache[key];\n                }, this);\n                return this;\n            }\n\n        };\n    });\n});\n\nScoped.define(\"module:Classes.ClassRegistry\", [\n    \"module:Class\",\n    \"module:Types\",\n    \"module:Functions\",\n    \"module:Objs\"\n], function(Class, Types, Functions, Objs, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Class Registry Class\n         * \n         * @class BetaJS.Classes.ClassRegistry\n         */\n        return {\n\n            /**\n             * Creates an instance.\n             * \n             * @param {array} classes Class maps in an array\n             * @param {boolean} lowercase Should all keys be lowercased\n             */\n            constructor: function(classes, lowercase) {\n                inherited.constructor.call(this);\n                this._classes = Types.is_array(classes) ? classes : [classes || {}];\n                this._lowercase = lowercase;\n            },\n\n            /**\n             * Sanitizes the key of a class.\n             * \n             * @param {string} key Key to be sanitized\n             * \n             * @return {string} Sanitized key\n             */\n            _sanitize: function(key) {\n                return this._lowercase ? key.toLowerCase() : key;\n            },\n\n            /**\n             * Register a class.\n             * \n             * @param {string} key Key of class\n             * @param {object} cls Class to be registered\n             * \n             */\n            register: function(key, cls) {\n                this._classes[this._classes.length - 1][this._sanitize(key)] = cls;\n                return this;\n            },\n\n            /**\n             * Return a class by key.\n             * \n             * @param {string} key Key of class\n             * \n             * @return {object} Class referenced by key\n             */\n            get: function(key) {\n                if (!Types.is_string(key))\n                    return key;\n                key = this._sanitize(key);\n                for (var i = this._classes.length - 1; i >= 0; --i)\n                    if (key in this._classes[i])\n                        return this._classes[i][key];\n                return null;\n            },\n\n            /**\n             * Creates a new class based on its key.\n             * \n             * @param {string} key Key of class\n             * \n             * @return {object} Class instance\n             */\n            create: function(key) {\n                var cons = Functions.newClassFunc(this.get(key));\n                return cons.apply(this, Functions.getArguments(arguments, 1));\n            },\n\n            /**\n             * Returns all classes as key-object map.\n             * \n             * @return {object} Key-object map.\n             */\n            classes: function() {\n                var result = {};\n                Objs.iter(this._classes, function(classes) {\n                    result = Objs.extend(result, classes);\n                });\n                return result;\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Classes.ContextRegistry\", [\n    \"module:Class\",\n    \"module:Ids\",\n    \"module:Types\",\n    \"module:Objs\",\n    \"module:Iterators.MappedIterator\",\n    \"module:Iterators.ObjectValuesIterator\"\n], function(Class, Ids, Types, Objs, MappedIterator, ObjectValuesIterator, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Context Registry Class\n         * \n         * @class BetaJS.Classes.ContextRegistry\n         */\n        return {\n\n            /**\n             * Creates an instance.\n             * \n             * @param {function} serializer Serializer function\n             * @param {object} serializerContext Optional serializer context\n             */\n            constructor: function(serializer, serializerContext) {\n                inherited.constructor.apply(this);\n                this.__data = {};\n                this.__contexts = {};\n                this.__serializer = serializer || this.__defaultSerializer;\n                this.__serializerContext = serializerContext || this;\n            },\n\n            __defaultSerializer: function(data) {\n                return Types.is_object(data) ? Ids.objectId(data) : data;\n            },\n\n            /**\n             * Serialize a context.\n             * \n             * @param {object} ctx Context object to be serialized\n             * \n             * @return {string} Serialized context object\n             */\n            _serializeContext: function(ctx) {\n                return ctx ? Ids.objectId(ctx) : null;\n            },\n\n            /**\n             * Serializes data.\n             * \n             * @param data Data to be serialized\n             * \n             * @return {string} Serialized data\n             */\n            _serializeData: function(data) {\n                return this.__serializer.call(this.__serializerContext, data);\n            },\n\n            /**\n             * Returns stored data based on serializing data\n             * \n             * @param data Data to be serialized\n             * \n             * @return Stored data\n             */\n            get: function(data) {\n                var serializedData = this._serializeData(data);\n                return this.__data[serializedData];\n            },\n\n            /**\n             * Registers data with respect to an optional context.\n             *\n             * @param data manatory data\n             * @param {object} context optional context\n             * \n             * @return data if data was not registered before, null otherwise\n             * \n             */\n            register: function(data, context) {\n                var serializedData = this._serializeData(data);\n                var serializedCtx = this._serializeContext(context);\n                var result = false;\n                if (!(serializedData in this.__data)) {\n                    this.__data[serializedData] = {\n                        data: data,\n                        contexts: {}\n                    };\n                    result = true;\n                }\n                if (!(serializedCtx in this.__contexts)) {\n                    this.__contexts[serializedCtx] = {\n                        context: context,\n                        datas: {}\n                    };\n                }\n                this.__data[serializedData].contexts[serializedCtx] = true;\n                this.__contexts[serializedCtx].datas[serializedData] = true;\n                return result ? this.__data[serializedData].data : null;\n            },\n\n            /**\n             * Unregisters data with respect to a context.\n             * If no data is given, all data with respect to the context is unregistered.\n             * If no context is given, all context with respect to the data are unregistered.\n             * If nothing is given, everything is unregistered.\n             * \n             * @param data optional data\n             * @param {object} context optional context\n             * \n             * @result {array} unregistered data in an array\n             */\n            unregister: function(data, context) {\n                var result = [];\n                if (data) {\n                    var serializedData = this.__serializer.call(this.__serializerContext, data);\n                    if (this.__data[serializedData]) {\n                        if (context) {\n                            var serializedCtx = this._serializeContext(context);\n                            if (this.__contexts[serializedCtx]) {\n                                delete this.__contexts[serializedCtx].datas[serializedData];\n                                if (Types.is_empty(this.__contexts[serializedCtx].datas))\n                                    delete this.__contexts[serializedCtx];\n                            }\n                            delete this.__data[serializedData].contexts[serializedCtx];\n                            if (Types.is_empty(this.__data[serializedData].contexts)) {\n                                result.push(this.__data[serializedData].data);\n                                delete this.__data[serializedData];\n                            }\n                        } else {\n                            Objs.iter(this.__data[serializedData].contexts, function(dummy, serializedCtx) {\n                                if (this.__contexts[serializedCtx]) {\n                                    delete this.__contexts[serializedCtx].datas[serializedData];\n                                    if (Types.is_empty(this.__contexts[serializedCtx].datas))\n                                        delete this.__contexts[serializedCtx];\n                                }\n                            }, this);\n                            result.push(this.__data[serializedData].data);\n                            delete this.__data[serializedData];\n                        }\n                    }\n                } else if (context) {\n                    var serializedCtx2 = this._serializeContext(context);\n                    if (this.__contexts[serializedCtx2]) {\n                        Objs.iter(this.__contexts[serializedCtx2].datas, function(dummy, serializedData) {\n                            if (this.__data[serializedData]) {\n                                delete this.__data[serializedData].contexts[serializedCtx2];\n                                if (Types.is_empty(this.__data[serializedData].contexts)) {\n                                    result.push(this.__data[serializedData].data);\n                                    delete this.__data[serializedData];\n                                }\n                            }\n                        }, this);\n                        delete this.__contexts[serializedCtx2];\n                    }\n                } else {\n                    Objs.iter(this.__data, function(data) {\n                        result.push(data.data);\n                    }, this);\n                    this.__data = {};\n                    this.__contexts = [];\n                }\n                return result;\n            },\n\n            /**\n             * Custom iterator iterating over the stored data\n             * \n             * @return {object} Iterator\n             */\n            customIterator: function() {\n                return new ObjectValuesIterator(this.__data);\n            },\n\n            /**\n             * Data iterator iterating over the stored data\n             * \n             * @return {object} Iterator\n             */\n            iterator: function() {\n                var customIt = this.customIterator();\n                return (new MappedIterator(customIt, function(item) {\n                    return item.data;\n                })).auto_destroy(customIt, true);\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Classes.Taggable\", [\n    \"module:Objs\"\n], function(Objs) {\n\n    /**\n     * Taggable Mixin for handling instance tags\n     * \n     * @mixin BetaJS.Classes.Taggable\n     */\n    return {\n\n        /**\n         * Determines whether a specific tag is present. \n         * \n         * @param {string} tag tag in question\n         * @return {boolean} true if tag present\n         */\n        hasTag: function(tag) {\n            return this.__tags && (tag in this.__tags);\n        },\n\n        /**\n         * Returns all tags being present.\n         *  \n         * @return {array} Array of tags\n         */\n        getTags: function() {\n            return Object.keys(this.__tags || {});\n        },\n\n        /**\n         * Removes a specific tag. \n         * \n         * @param {string} tag tag in question\n         * @return {object} this\n         */\n        removeTag: function(tag) {\n            if (this.__tags) {\n                delete this.__tags[tag];\n                this._notify(\"tags-changed\");\n            }\n            return this;\n        },\n\n        /**\n         * Remove a list of tags. \n         * \n         * @param {array} tags tags to be removed\n         * @return {object} this\n         */\n        removeTags: function(tags) {\n            Objs.iter(tags, this.removeTag, this);\n            return this;\n        },\n\n        /**\n         * Add a tag to the instance. \n         * \n         * @param {string} tag tag in question\n         * @return {object} this\n         */\n        addTag: function(tag) {\n            this.__tags = this.__tags || {};\n            this.__tags[tag] = true;\n            this._notify(\"tags-changed\");\n            return this;\n        },\n\n        /**\n         * Add a number of tags to the instance. \n         * \n         * @param {array} tags tag to be added\n         * @return {object} this\n         */\n        addTags: function(tags) {\n            Objs.iter(tags, this.addTag, this);\n            return this;\n        },\n\n        /**\n         * Returns the subset of the given tags that are present in the instance. \n         * \n         * @param {array} tags Superset of tags to be checkd\n         * @return {array} Subset of intersecting tags\n         */\n        tagIntersect: function(tags) {\n            return Objs.filter(tags, this.hasTag, this);\n        }\n\n    };\n});\n\n\nScoped.define(\"module:Classes.StringTable\", [\n    \"module:Class\",\n    \"module:Classes.Taggable\",\n    \"module:Functions\",\n    \"module:Objs\"\n], function(Class, Taggable, Functions, Objs, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [Taggable, function(inherited) {\n\n        /**\n         * Taggable StringTable Class \n         * \n         * @class BetaJS.Classes.StringTable\n         */\n        return {\n\n            _notifications: {\n                \"tags-changed\": function() {\n                    this.__cache = {};\n                }\n            },\n\n            /**\n             * Instantiates a StringTable. \n             */\n            constructor: function() {\n                inherited.constructor.call(this);\n                this.__cache = {};\n                this.__strings = {};\n            },\n\n            __resolveKey: function(key, prefix) {\n                if (prefix)\n                    key = prefix + \".\" + key;\n                key = key.replace(/[^\\.]+\\.</g, \"\");\n                return key;\n            },\n\n            __betterMatch: function(candidate, reference) {\n                var c = this.tagIntersect(candidate.tags).length - this.tagIntersect(reference.tags).length;\n                if (c !== 0)\n                    return c > 0;\n                c = candidate.priority - reference.priority;\n                if (c !== 0)\n                    return c > 0;\n                c = reference.tags.length - candidate.tags.length;\n                return c > 0;\n            },\n\n            /**\n             * Registers string resources. \n             * \n             * @param {object} strings key-value representation of strings\n             * @param {string} prefix optional prefix for the keys\n             * @param {array} tags optional tags\n             * @param {int} priority optional priority\n             * \n             * @return {object} this\n             */\n            register: function() {\n                var args = Functions.matchArgs(arguments, {\n                    strings: true,\n                    prefix: \"string\",\n                    tags: \"array\",\n                    priority: \"number\"\n                });\n                Objs.iter(args.strings, function(value, key) {\n                    key = this.__resolveKey(key, args.prefix);\n                    this.__strings[key] = this.__strings[key] || [];\n                    this.__strings[key].push({\n                        value: value,\n                        tags: args.tags || [],\n                        priority: args.priority || 0\n                    });\n                    delete this.__cache[key];\n                }, this);\n                return this;\n            },\n\n            /**\n             * Returns a string resource by key \n             * \n             * @param {string} key key to be retrieved\n             * @param {string} prefix optional prefix for the key\n             * \n             * @return {string} resource string\n             */\n            get: function(key, prefix) {\n                key = this.__resolveKey(key, prefix);\n                if (key in this.__cache)\n                    return this.__cache[key];\n                if (!(key in this.__strings))\n                    return null;\n                var current = null;\n                Objs.iter(this.__strings[key], function(candidate) {\n                    if (!current || this.__betterMatch(candidate, current))\n                        current = candidate;\n                }, this);\n                this.__cache[key] = current.value;\n                return current.value;\n            },\n\n            /**\n             * Retruns all included string resources \n             * \n             * @return {object} key-value representation of the included string resources\n             */\n            all: function() {\n                return Objs.map(this.__strings, function(value, key) {\n                    return this.get(key);\n                }, this);\n            }\n\n        };\n    }]);\n});\n\n\n\nScoped.define(\"module:Classes.LocaleTable\", [\n    \"module:Classes.StringTable\",\n    \"module:Classes.LocaleMixin\"\n], function(StringTable, LocaleMixin, scoped) {\n    return StringTable.extend({\n        scoped: scoped\n    }, [LocaleMixin,\n\n        /**\n         * Locale Table Class\n         * \n         * @class BetaJS.Classes.LocaleTable\n         */\n        {\n\n            _localeTags: function(locale) {\n                if (!locale)\n                    return null;\n                var result = [];\n                result.push(\"language:\" + locale);\n                if (locale.indexOf(\"-\") > 0)\n                    result.push(\"language:\" + locale.substring(0, locale.indexOf(\"-\")));\n                return result;\n            },\n\n            /**\n             * @override \n             */\n            _clearLocale: function() {\n                this.removeTags(this._localeTags(this.getLocale()));\n            },\n\n            /**\n             * @override \n             */\n            _setLocale: function(locale) {\n                this.addTags(this._localeTags(locale));\n            }\n\n        }\n    ]);\n});\nScoped.define(\"module:Collections.Collection\", [\n    \"module:Class\",\n    \"module:Events.EventsMixin\",\n    \"module:Objs\",\n    \"module:Functions\",\n    \"module:Lists.ArrayList\",\n    \"module:Ids\",\n    \"module:Properties.ObservableMixin\",\n    \"module:Properties.Properties\",\n    \"module:Iterators.ArrayIterator\",\n    \"module:Iterators.MappedIterator\",\n    \"module:Iterators.ConcatIterator\",\n    \"module:Iterators.FilteredIterator\",\n    \"module:Iterators.ObjectValuesIterator\",\n    \"module:Types\",\n    \"module:Promise\"\n], function(Class, EventsMixin, Objs, Functions, ArrayList, Ids, ObservableMixin, Properties, ArrayIterator, MappedIterator, ConcatIterator, FilteredIterator, ObjectValuesIterator, Types, Promise, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [EventsMixin, ObservableMixin, function(inherited) {\n\n        /**\n         * A collection class for managing a list of Properties-based objects.\n         * \n         * @class BetaJS.Collections.Collection\n         */\n        return {\n\n            /**\n             * Creates an instance.\n             * \n             * @param {object} options Options for the collection or an array of initial objects\n             */\n            constructor: function(options) {\n                inherited.constructor.call(this);\n                if (Types.is_array(options)) {\n                    options = {\n                        objects: options\n                    };\n                }\n                options = options || {};\n                this.bulk_operations = 0;\n                this.__indices = {};\n                if (options.release_references)\n                    this.__release_references = true;\n                var list_options = {};\n                if (\"compare\" in options)\n                    list_options.compare = options.compare;\n                list_options.get_ident = Functions.as_method(this.get_ident, this);\n                this.__data = new ArrayList([], list_options);\n                var self = this;\n                this.__data._ident_changed = function(object, index) {\n                    self._index_changed(object, index);\n                };\n                this.__data._re_indexed = function(object) {\n                    self._re_indexed(object);\n                };\n                this.__data._sorted = function() {\n                    self._sorted();\n                };\n                if (\"objects\" in options)\n                    this.add_objects(options.objects);\n                if (options.indices)\n                    Objs.iter(options.indices, this.add_secondary_index, this);\n                if (options.uniqueness)\n                    this.__uniqueness = options.uniqueness;\n                if (options.progressiveUniqueness)\n                    this.__progressiveUniqueness = options.progressiveUniqueness;\n            },\n\n            /**\n             * Returns the value associated with an observable key.\n             *\n             * @param {string} key key to read value for\n             *\n             * @return value for key\n             */\n            get: function(key) {\n                switch (key) {\n                    case \"observable_count\":\n                        return this.count();\n                }\n                return undefined;\n            },\n\n            /**\n             * Checks whether an observable key is set.\n             *\n             * @param {string} key key in question\n             *\n             * @return {boolean} true if key is set\n             */\n            hasKey: function(key) {\n                switch (key) {\n                    case \"observable_count\":\n                        return true;\n                }\n                return false;\n            },\n\n            /**\n             * Add a secondary key index to the collection.\n             * \n             * @param {string} key Name of key to be added\n             */\n            add_secondary_index: function(key) {\n                this.__indices[key] = {};\n                this.iterate(function(object) {\n                    var value = object.get(key);\n                    this.__indices[key][value] = this.__indices[key][value] || {};\n                    this.__indices[key][value][this.get_ident(object)] = object;\n                }, this);\n                return this;\n            },\n\n            /**\n             * Return entry by value from a secondary index.\n             * \n             * @param {string} key Name of secondary index key\n             * @param value Value to the secondary index\n             * @param {boolean} returnFirst Only return single element\n             * \n             * @return Returns entry associated with the key value pair\n             */\n            get_by_secondary_index: function(key, value, returnFirst) {\n                return returnFirst ? Objs.ithValue(this.__indices[key][value]) : this.__indices[key][value];\n            },\n\n            /**\n             * Get the identifier of an object.\n             * \n             * @param {object} obj Source object\n             * \n             * @return {string} identifier of source object\n             */\n            get_ident: function(obj) {\n                return Ids.objectId(obj);\n            },\n\n            /**\n             * Set the comparison function.\n             * \n             * @param {function} compare Comparison function\n             * @fires BetaJS.Collections.Collection#set_compare\n             */\n            set_compare: function(compare) {\n                /**\n                 * @event BetaJS.Collections.Collection#set_compare\n                 */\n                this.trigger(\"set_compare\", compare);\n                this.__data.set_compare(compare);\n                return this;\n            },\n\n            /**\n             * Return the current comparison function.\n             * \n             * @return {function} current compare function\n             */\n            get_compare: function() {\n                return this.__data.get_compare();\n            },\n\n            __load_item: function(object) {\n                if (\"on\" in object) {\n                    object.on(\"change\", function(key, value, oldvalue) {\n                        this._object_changed(object, key, value, oldvalue);\n                    }, this);\n                }\n                if (this.__release_references)\n                    object.increaseRef(this);\n            },\n\n            __unload_item: function(object) {\n                if (\"off\" in object)\n                    object.off(null, null, this);\n                if (this.__release_references)\n                    object.decreaseRef(this);\n            },\n\n            /**\n             * @override\n             * @fires BetaJS.Collections.Collection#destroy\n             */\n            destroy: function() {\n                this.__data.iterate(this.__unload_item, this);\n                this.__data.destroy();\n                /**\n                 * @event BetaJS.Collections.Collection#destroy\n                 */\n                this.trigger(\"destroy\");\n                inherited.destroy.call(this);\n            },\n\n            /**\n             * Return the number of elements in the collection.\n             * \n             * @return {int} number of elements\n             */\n            count: function() {\n                return this.__data.count();\n            },\n\n            /**\n             * Called when the index of an object has changed.\n             * \n             * @param {object} object Object whose index has changed\n             * @param {int} index New index\n             * @fires BetaJS.Collections.Collection#index\n             */\n            _index_changed: function(object, index) {\n                /**\n                 * @event BetaJS.Collections.Collection#index\n                 */\n                this.trigger(\"index\", object, index);\n            },\n\n            /**\n             * Called when the index of an object has been successfully updated.\n             * \n             * @param {object} object Object whose index has been updated\n             * @fires BetaJS.Collections.Collection#reindexed\n             */\n            _re_indexed: function(object) {\n                /**\n                 * @event BetaJS.Collections.Collection#reindexed\n                 */\n                this.trigger(\"reindexed\", object);\n            },\n\n            /**\n             * Called when the collection has been sorted.\n             * \n             * @fires BetaJS.Collections.Collection#sorted\n             */\n            _sorted: function() {\n                /**\n                 * @event BetaJS.Collections.Collection#sorted\n                 */\n                this.trigger(\"sorted\");\n            },\n\n            /**\n             * Called when an attribute of an object has changed.\n             * \n             * @param {object} object Object whose attribute has changed\n             * @param {string} key Key of changed attribute\n             * @param value New value of the object\n             * @param oldValue Old value of the object\n             * @fires BetaJS.Collections.Collection#update\n             * @fires BetaJS.Collections.Collection#change\n             */\n            _object_changed: function(object, key, value, oldValue) {\n                /**\n                 * @event BetaJS.Collections.Collection#update\n                 */\n                this.trigger(\"update\");\n                /**\n                 * @event BetaJS.Collections.Collection#change\n                 */\n                this.trigger(\"change\", object, key, value, oldValue);\n                this.trigger(\"change:\" + key, object, value, oldValue);\n                this.__data.re_index(this.getIndex(object));\n            },\n\n            /**\n             * Add an object to the collection.\n             * \n             * @param {object} object Object to be added\n             * @return {string} Identifier of added object\n             * @fires BetaJS.Collections.Collection#add\n             * @fires BetaJS.Collections.Collection#update\n             */\n            add: function(object) {\n                if (!Class.is_class_instance(object))\n                    object = new Properties(object);\n                if (this.__progressiveUniqueness && this.__indices[this.__progressiveUniqueness]) {\n                    var obj = this.get_by_secondary_index(this.__progressiveUniqueness, object.get(this.__progressiveUniqueness), true);\n                    if (obj && obj !== object) {\n                        this.remove(obj);\n                    }\n                }\n                if (this.exists(object))\n                    return null;\n                var ident = this.__data.add(object);\n                if (ident !== null) {\n                    Objs.iter(this.__indices, function(entries, key) {\n                        var value = object.get(key);\n                        entries[value] = entries[value] || {};\n                        entries[value][this.get_ident(object)] = object;\n                    }, this);\n                    /**\n                     * @event BetaJS.Collections.Collection#add\n                     */\n                    this.trigger(\"add\", object);\n                    /**\n                     * @event BetaJS.Collections.Collection#update\n                     */\n                    this.trigger(\"update\");\n                    this.trigger(\"change:observable_count\", this.count());\n                    this.__load_item(object);\n                }\n                return ident;\n            },\n\n            /**\n             * Checks whether a bulk operation is in progress.\n             *\n             * @returns {boolean} true if in progress\n             */\n            bulkOperationInProgress: function() {\n                return this.bulk_operations > 0;\n            },\n\n            /**\n             * Replace objects by other objects with the same id.\n             * \n             * @param {array} object New objects with ids\n             * @param {boolean} keep_others True if objects with ids not included should be kept\n             * \n             */\n            replace_objects: function(objects, keep_others) {\n                if (this.destroyed())\n                    return this;\n                this.bulk_operations++;\n                var addQueue = [];\n                var ids = {};\n                Objs.iter(objects, function(oriObject) {\n                    var is_prop = Class.is_class_instance(oriObject);\n                    var obj = is_prop ? oriObject : new Properties(oriObject);\n                    var id = this.get_ident(obj);\n                    ids[id] = true;\n                    var old = this.getById(id);\n                    if (!old)\n                        addQueue.push(obj);\n                    else if (is_prop) {\n                        /*\n                        this.remove(old);\n                        this.add(obj);\n                        */\n                    } else {\n                        obj.destroy();\n                        old.setAll(oriObject);\n                    }\n                }, this);\n                if (!keep_others) {\n                    var iterator = this.iterator();\n                    while (iterator.hasNext()) {\n                        var object = iterator.next();\n                        if (!ids[this.get_ident(object)]) {\n                            this.remove(object);\n                            if (addQueue.length > 0)\n                                this.add(addQueue.shift());\n                        }\n                    }\n                    iterator.destroy();\n                }\n                while (addQueue.length > 0)\n                    this.add(addQueue.shift());\n                this.bulk_operations--;\n                this.trigger(\"replaced-objects\");\n                return this;\n            },\n\n            /**\n             * Add objects in a bulk.\n             * \n             * @param {array} objects Objects to be added\n             * @param {boolean} return_collection Whether the return value should be the collection or its length\n             * @return {int} Number of objects added\n             */\n            add_objects: function(objects, return_collection) {\n                var count = 0;\n                Objs.iter(objects, function(object) {\n                    if (this.add(object))\n                        count++;\n                }, this);\n                if (return_collection)\n                    return this;\n                else\n                    return count;\n            },\n\n            /**\n             * Determine whether an object is already included.\n             * \n             * @param {object} object Object in question\n             * @return {boolean} True if contained\n             */\n            exists: function(object) {\n                if (this.__data.exists(object))\n                    return true;\n                if (!this.__uniqueness)\n                    return false;\n                if (this.__indices[this.__uniqueness])\n                    return !!this.get_by_secondary_index(this.__uniqueness, object.get(this.__uniqueness), true);\n                return !!this.queryOne(Objs.objectBy(this.__uniqueness, object.get(this.__uniqueness)));\n            },\n\n            /**\n             * Remove an object from the collection.\n             * \n             * @param {object} object Object to be removed\n             * @return {object} Removed object\n             * @fires BetaJS.Collections.Collection#remove\n             * @fires BetaJS.Collections.Collection#update\n             */\n            remove: function(object) {\n                if (!this.exists(object))\n                    return null;\n                Objs.iter(this.__indices, function(entry, key) {\n                    var value = object.get(key);\n                    if (entry[value]) {\n                        delete entry[value][this.get_ident(object)];\n                        if (Types.is_empty(entry[value]))\n                            delete entry[value];\n                    }\n                }, this);\n                var result = this.__data.remove(object);\n                /**\n                 * @event BetaJS.Collections.Collection#remove\n                 */\n                this.trigger(\"remove\", object);\n                this.trigger(\"change:observable_count\", this.count());\n                this.__unload_item(object);\n                /**\n                 * @event BetaJS.Collections.Collection#update\n                 */\n                this.trigger(\"update\");\n                return result;\n            },\n\n            /**\n             * Get an object by index.\n             * \n             * @param {int} index Index to be returned\n             * @return {object} Object at that index\n             */\n            getByIndex: function(index) {\n                return this.__data.get(index);\n            },\n\n            /**\n             * Get an object by identifier.\n             * \n             * @param {string} id Identifier of object\n             * @return {object} Object with that identifier\n             */\n            getById: function(id) {\n                return this.__data.get(this.__data.ident_by_id(id));\n            },\n\n            /**\n             * Get the index of an object.\n             * \n             * @param {object} object Object in question\n             * @return {int} Index of object\n             */\n            getIndex: function(object) {\n                return this.__data.get_ident(object);\n            },\n\n            /**\n             * Iterate over the collection.\n             * \n             * @param {function} cb Item callback\n             * @param {object} context Context for callback\n             * \n             */\n            iterate: function(cb, context) {\n                this.__data.iterate(cb, context);\n                return this;\n            },\n\n            /**\n             * Checks whether an item exists\n             *\n             * @param {function} cb Item callback\n             * @param {object} context Context for callback\n             * @returns {boolean} true if element exists\n             *\n             */\n            has: function(cb, context) {\n                var result = false;\n                this.iterate(function(item) {\n                    result = result || cb.call(this, item);\n                }, context);\n                return result;\n            },\n\n            /**\n             * Checks whether something holds for all items\n             *\n             * @param {function} cb Item callback\n             * @param {object} context Context for callback\n             * @returns {boolean} true if holds for all items\n             *\n             */\n            forall: function(cb, context) {\n                var result = true;\n                this.iterate(function(item) {\n                    result = result && cb.call(this, item);\n                }, context);\n                return result;\n            },\n\n            /**\n             * Creates an iterator instance for the collection.\n             * \n             * @return {object} Iterator instance\n             */\n            iterator: function() {\n                return ArrayIterator.byIterate(this.iterate, this);\n            },\n\n            /**\n             * Creates an iterator instance via a secondary index for a specific value.\n             * \n             * @param {string} key Key of secondary index\n             * @param value Particular value\n             * @return {object} Iterator instance\n             */\n            iterateSecondaryIndexValue: function(key, value) {\n                if (Types.is_array(value)) {\n                    return new ConcatIterator(new MappedIterator(new ArrayIterator(value), function(v) {\n                        return this.iterateSecondaryIndexValue(key, v);\n                    }, this));\n                }\n                return new ObjectValuesIterator(this.__indices[key][value]);\n            },\n\n            /**\n             * Query the collection for items matching some query data.\n             * \n             * @param {object} subset Query data to be matched.\n             * @return {object} Iterator instance\n             */\n            query: function(subset) {\n                var iterator = null;\n                for (var index_key in this.__indices) {\n                    if (index_key in subset) {\n                        iterator = this.iterateSecondaryIndexValue(index_key, subset[index_key]);\n                        delete subset[index_key];\n                        break;\n                    }\n                }\n                return new FilteredIterator(iterator || this.iterator(), function(prop) {\n                    return prop.isSupersetOf(subset);\n                });\n            },\n\n            /**\n             * Query the collection for a single item matching some query data.\n             *\n             * @param {object} subset Query data to be matched.\n             * @return {object} Item match\n             */\n            queryOne: function(subset) {\n                return this.query(subset).next();\n            },\n\n            /**\n             * Clears the whole collection.\n             * \n             */\n            clear: function() {\n                this.iterate(function(obj) {\n                    this.remove(obj);\n                }, this);\n                return this;\n            },\n\n            /**\n             * Increase the view of the collection by a number of steps.\n             * \n             * @param {int} steps Steps to increase\n             */\n            increase_forwards: function(steps) {\n                return Promise.error(true);\n            },\n\n            /**\n             * Increase the view of the collection by a number of steps backwards.\n             *\n             * @param {int} steps Steps to increase\n             */\n            increase_backwards: function(steps) {\n                return Promise.error(true);\n            },\n\n            /**\n             * Returns the first item in the collection.\n             *\n             * @returns {Object} first item\n             */\n            first: function() {\n                return this.getByIndex(0);\n            },\n\n            /**\n             * Returns the last item in the collection\n             *\n             * @returns {Object} last item\n             */\n            last: function() {\n                return this.getByIndex(this.count() - 1);\n            },\n\n            /**\n             * Sets a key value pair in all items\n             *\n             * @param {string} key key of pair\n             * @param value value of pair\n             *\n             * @returns {BetaJS.Collections.Collection}\n             */\n            allSet: function(key, value) {\n                this.iterate(function(obj) {\n                    obj.set(key, value);\n                });\n                return this;\n            },\n\n            /**\n             * Sets a set of key-value pairs in all items\n             *\n             * @param {object} data key-value pair to be set\n             *\n             * @returns {BetaJS.Collections.Collection}\n             */\n            allSetAll: function(data) {\n                this.iterate(function(obj) {\n                    obj.setAll(data);\n                });\n                return this;\n            },\n\n            asJSON: function() {\n                var result = [];\n                this.iterate(function(p) {\n                    result.push(p.data());\n                });\n                return result;\n            }\n\n        };\n    }]);\n});\nScoped.define(\"module:Collections.ConcatCollection\", [\n    \"module:Collections.Collection\",\n    \"module:Objs\",\n    \"module:Functions\"\n], function(Collection, Objs, Functions, scoped) {\n    return Collection.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * A Concat Collection allows you to dynamically concatinate Collections \n         * \n         * @class BetaJS.Collections.ConcatCollection\n         */\n        return {\n\n            /**\n             * Instantiate a Concat Collection.\n             * \n             * @param {array} parents List of parent collections\n             * @param {object} options Collection options\n             * \n             */\n            constructor: function(parents, options) {\n                this.__parents = {};\n                this.__itemToParent = {};\n                options = options || {};\n                delete options.objects;\n                if (!options.compare)\n                    options.compare = Functions.as_method(this.__compareByParent, this);\n                inherited.constructor.call(this, options);\n                var idx = 0;\n                this.__firstParent = null;\n                this.__lastParent = null;\n                Objs.iter(parents, function(parent) {\n                    if (!this.__firstParent)\n                        this.__firstParent = parent;\n                    this.__lastParent = parent;\n                    this.__parents[parent.cid()] = {\n                        idx: idx,\n                        parent: parent\n                    };\n                    parent.iterate(function(item) {\n                        this.__parentAdd(parent, item);\n                    }, this);\n                    parent.on(\"add\", function(item) {\n                        this.__parentAdd(parent, item);\n                    }, this);\n                    parent.on(\"remove\", function(item) {\n                        this.__parentRemove(parent, item);\n                    }, this);\n                    idx++;\n                }, this);\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                Objs.iter(this.__parents, function(parent) {\n                    parent.parent.off(null, null, this);\n                }, this);\n                inherited.destroy.call(this);\n            },\n\n            /**\n             * @override\n             */\n            bulkOperationInProgress: function() {\n                return inherited.bulkOperationInProgress.call(this) || Objs.exists(this.__parents, function(parent) {\n                    return parent.parent.bulkOperationInProgress();\n                });\n            },\n\n            /**\n             * @override\n             */\n            increase_forwards: function(steps) {\n                return this.__lastParent.increase_forwards(steps);\n            },\n\n            /**\n             * @override\n             */\n            increase_backwards: function(steps) {\n                return this.__firstParent.increase_forwards(steps);\n            },\n\n            __parentAdd: function(parent, item) {\n                this.__itemToParent[item.cid()] = parent;\n                this.add(item);\n            },\n\n            __parentRemove: function(parent, item) {\n                delete this.__itemToParent[item.cid()];\n                this.remove(item);\n            },\n\n            __compareByParent: function(item1, item2) {\n                var parent1 = this.__itemToParent[item1.cid()];\n                var parent2 = this.__itemToParent[item2.cid()];\n                if (parent1 === parent2)\n                    return parent1.getIndex(item1) - parent2.getIndex(item2);\n                return this.__parents[parent1.cid()].idx - this.__parents[parent2.cid()].idx;\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Collections.FilteredCollection\", [\n    \"module:Collections.Collection\"\n], function(Collection, scoped) {\n    return Collection.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * The FilteredCollection Class allows you to create a dynamic sub collection based on another Collection instance and a filter function.\n         * \n         * @class BetaJS.Collections.FilteredCollection\n         */\n        return {\n\n            /**\n             * Instantiates a FilteredCollection.\n             * \n             * @param {object} parent Parent Collection\n             * @param {object} options Standard Collection options, plus filter and context\n             */\n            constructor: function(parent, options) {\n                this.__parent = parent;\n                options = options || {};\n                delete options.objects;\n                options.compare = options.compare || parent.get_compare();\n                inherited.constructor.call(this, options);\n                this.__parent.on(\"add\", this.add, this);\n                this.__parent.on(\"remove\", this.__selfRemove, this);\n                this.__parent.on(\"change\", this.add, this);\n                this.setFilter(options.filter, options.context);\n            },\n\n            /**\n             * Determines whether an item satisfies the filter of this collection.\n             * \n             * @param {object} object Properties instance to be checked\n             * \n             * @return {boolean} True if object satisfies current filter\n             */\n            filter: function(object) {\n                return !this.__filter || this.__filter.call(this.__filterContext || this, object);\n            },\n\n            /**\n             * Sets the current filter\n             * \n             * @param {function} filterFunction Filter function to be used for checking items\n             * @param {object} filterContext Optional filter function context\n             */\n            setFilter: function(filterFunction, filterContext) {\n                this.__filterContext = filterContext;\n                this.__filter = filterFunction;\n                this.iterate(function(obj) {\n                    if (!this.filter(obj))\n                        this.__selfRemove(obj);\n                }, this);\n                this.__parent.iterate(function(object) {\n                    if (!this.exists(object) && this.filter(object))\n                        this.__selfAdd(object);\n                    return true;\n                }, this);\n            },\n\n            /**\n             * @override\n             */\n            _object_changed: function(object, key, value) {\n                inherited._object_changed.call(this, object, key, value);\n                if (!this.filter(object))\n                    this.__selfRemove(object);\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                this.__parent.off(null, null, this);\n                inherited.destroy.call(this);\n            },\n\n            __selfAdd: function(object) {\n                return inherited.add.call(this, object);\n            },\n\n            /**\n             * @override\n             */\n            add: function(object) {\n                if (this.exists(object) || !this.filter(object))\n                    return null;\n                var id = this.__selfAdd(object);\n                this.__parent.add(object);\n                return id;\n            },\n\n            __selfRemove: function(object) {\n                return inherited.remove.call(this, object);\n            },\n\n            /**\n             * @override\n             */\n            remove: function(object) {\n                if (!this.exists(object))\n                    return null;\n                var result = this.__selfRemove(object);\n                if (!result)\n                    return null;\n                return this.__parent.remove(object);\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Collections.GroupedCollection\", [\n    \"module:Collections.Collection\",\n    \"module:Objs\",\n    \"module:Properties.Properties\",\n    \"module:Functions\",\n    \"module:Promise\",\n    \"module:Async\"\n], function(Collection, Objs, Properties, Functions, Promise, Async, scoped) {\n    return Collection.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * The GroupedCollection Class allows you to create a dynamic sub collection based on another Collection instance by grouping together single items.\n         * \n         * @class BetaJS.Collections.GroupedCollection\n         */\n        return {\n\n            /**\n             * Instantiates a GroupedCollection.\n             * \n             * @param {object} parent Parent Collection\n             * @param {object} options Standard Collection options, plus groupby, insert, remove, context, properties and create\n             */\n            constructor: function(parent, options) {\n                this.__parent = parent;\n                options = options || {};\n                delete options.objects;\n                this.__groupby = options.groupby;\n                this.__groupbyCompute = options.groupbyCompute;\n                this.__keepEmptyGroups = options.keepEmptyGroups;\n                this.__autoIncreaseGroups = options.autoIncreaseGroups;\n                this.__generateGroupData = options.generateGroupData;\n                this.__nogaps = !!options.nogaps;\n                this.__lazyNogaps = !!options.lazyNogaps;\n                this.__insertCallback = options.insert;\n                this.__removeCallback = options.remove;\n                this.__afterGroupCreate = options.afterGroupCreate;\n                this.__callbackContext = options.context || this;\n                this.__ignoreParentIncrease = options.ignoreParentIncrease;\n                this.__propertiesClass = options.properties || Properties;\n                this.__itemsAttribute = options.itemsAttribute || \"items\";\n                this.__createProperties = options.create;\n                inherited.constructor.call(this, options);\n                Objs.iter(this.__groupby, this.add_secondary_index, this);\n                this.__parent.iterate(this.__addParentObject, this);\n                this.__parent.on(\"add\", this.__addParentObject, this);\n                this.__parent.on(\"remove\", this.__removeParentObject, this);\n                this.__objectToGroup = {};\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                this.__parent.off(null, null, this);\n                inherited.destroy.call(this);\n            },\n\n            touchGroup: function(data, create, lazy) {\n                if (this.destroyed())\n                    return;\n                if (lazy)\n                    return Async.eventually(this.touchGroup, [data, create], this);\n                data = Properties.is_instance_of(data) ? data.data() : data;\n                data = this.__groupbyCompute ? this.__groupbyCompute.call(this.__callbackContext, data) : data;\n                var query = {};\n                this.__groupby.forEach(function(key) {\n                    query[key] = data[key];\n                });\n                var group = this.query(query).nextOrNull();\n                if (!group && create) {\n                    group = this.__createProperties ? this.__createProperties.call(this.__callbackContext) : new this.__propertiesClass();\n                    group[this.__itemsAttribute] = group[this.__itemsAttribute] || group.auto_destroy(new Collection({\n                        compare: this.__parent.get_compare()\n                    }));\n                    group[this.__itemsAttribute].bulkOperationInProgress = Functions.as_method(this.bulkOperationInProgress, this);\n                    group.setAll(data);\n                    this.add(group);\n                    if (this.__afterGroupCreate)\n                        this.__afterGroupCreate.call(this.__callbackContext, group);\n                    this.trigger(\"touchgroup\", group);\n                    if (this.__nogaps) {\n                        if (group !== this.last())\n                            this.touchGroup(this.__generateGroupData.call(this.__callbackContext, group.data(), 1), true, this.__lazyNogaps);\n                        if (group !== this.first())\n                            this.touchGroup(this.__generateGroupData.call(this.__callbackContext, group.data(), -1), true, this.__lazyNogaps);\n                    }\n                }\n                return group;\n            },\n\n            __addParentObject: function(object) {\n                var group = this.touchGroup(object, true);\n                if (object.cid)\n                    this.__objectToGroup[object.cid()] = group;\n                this.__addObjectToGroup(object, group);\n            },\n\n            __removeParentObject: function(object) {\n                var group = object.cid && this.__objectToGroup[object.cid()] ? this.__objectToGroup[object.cid()] : this.touchGroup(object);\n                if (group) {\n                    this.__removeObjectFromGroup(object, group);\n                    if (!this.__keepEmptyGroups && group[this.__itemsAttribute].count() === 0)\n                        this.remove(group);\n                }\n            },\n\n            __addObjectToGroup: function(object, group) {\n                group[this.__itemsAttribute].add(object);\n                this.__insertObject(object, group);\n            },\n\n            __removeObjectFromGroup: function(object, group) {\n                group[this.__itemsAttribute].remove(object);\n                this.__removeObject(object, group);\n            },\n\n            /**\n             * @override\n             */\n            increase_forwards: function(steps) {\n                var oldCount = this.__parent.count();\n                var promise = this.__ignoreParentIncrease ? Promise.create(true) : this.__parent.increase_forwards(steps);\n                return promise.success(function() {\n                    if (!this.__autoIncreaseGroups)\n                        return;\n                    var delta = this.__parent.count() - oldCount;\n                    var current = this.last();\n                    while (delta < steps) {\n                        current = this.touchGroup(this.__generateGroupData.call(this.__callbackContext, current.data(), 1), true);\n                        delta++;\n                    }\n                }, this);\n            },\n\n            /**\n             * @override\n             */\n            bulkOperationInProgress: function() {\n                return inherited.bulkOperationInProgress.call(this) || this.__parent.bulkOperationInProgress();\n            },\n\n            /**\n             * @override\n             */\n            increase_backwards: function(steps) {\n                var oldCount = this.__parent.count();\n                var promise = this.__ignoreParentIncrease ? Promise.create(true) : this.__parent.increase_backwards(steps);\n                return promise.success(function() {\n                    if (!this.__autoIncreaseGroups)\n                        return;\n                    var delta = this.__parent.count() - oldCount;\n                    var current = this.first();\n                    while (delta < steps) {\n                        current = this.touchGroup(this.__generateGroupData.call(this.__callbackContext, current.data(), -1), true);\n                        delta++;\n                    }\n                }, this);\n            },\n\n            __insertObject: function(object, group) {\n                if (this.__insertCallback)\n                    this.__insertCallback.call(this.__callbackContext, object, group);\n                else {\n                    /**\n                     * @event BetaJS.Collections.GroupedCollection#insert\n                     */\n                    group.trigger(\"insert\", object);\n                }\n            },\n\n            __removeObject: function(object, group) {\n                if (this.__removeCallback)\n                    this.__removeCallback.call(this.__callbackContext, object, group);\n                else {\n                    /**\n                     * @event BetaJS.Collections.GroupedCollection#remove\n                     */\n                    group.trigger(\"remove\", object);\n                }\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Collections.MappedCollection\", [\n    \"module:Collections.Collection\",\n    \"module:Functions\"\n], function(Collection, Functions, scoped) {\n    return Collection.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * The MappedCollection Class allows you to create a dynamic sub collection based on another Collection instance and a mapping function.\n         * \n         * @class BetaJS.Collections.MappedCollection\n         */\n        return {\n\n            /**\n             * Instantiates a MappedCollection.\n             * \n             * @param {object} parent Parent Collection\n             * @param {object} options Standard Collection options, plus map and context\n             */\n            constructor: function(parent, options) {\n                this.__parent = parent;\n                this.__parentToThis = {};\n                this.__thisToParent = {};\n                options = options || {};\n                delete options.objects;\n                options.compare = Functions.as_method(this.__compareByParent, this);\n                inherited.constructor.call(this, options);\n                this._mapFunction = options.map;\n                this._mapCtx = options.context;\n                parent.on(\"add\", this.__parentAdd, this);\n                parent.on(\"remove\", this.__parentRemove, this);\n                parent.on(\"change\", this.__parentUpdate, this);\n                parent.iterate(this.__parentAdd, this);\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                this.__parent.off(null, null, this);\n                inherited.destroy.call(this);\n            },\n\n            __compareByParent: function(item1, item2) {\n                return this.__parent.getIndex(this.__thisToParent[item1.cid()]) - this.__parent.getIndex(this.__thisToParent[item2.cid()]);\n            },\n\n            __mapItem: function(parentItem, thisItem) {\n                return this._mapFunction.call(this._mapCtx || this, parentItem, thisItem);\n            },\n\n            __parentAdd: function(item) {\n                var mapped = this.__mapItem(item);\n                this.__parentToThis[item.cid()] = mapped;\n                this.__thisToParent[mapped.cid()] = item;\n                this.add(mapped);\n            },\n\n            __parentUpdate: function(item) {\n                this.__mapItem(item, this.__parentToThis[item.cid()]);\n            },\n\n            __parentRemove: function(item) {\n                var mapped = this.__parentToThis[item.cid()];\n                delete this.__parentToThis[item.cid()];\n                delete this.__thisToParent[mapped.cid()];\n                this.remove(mapped);\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Exceptions.ErrorCatcher\", [\n    \"module:Class\"\n], function(Class, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * ErrorCatcher Object\n         * \n         * @class BetaJS.Exceptions.ErrorCatcher\n         */\n        return {\n\n            /**\n             * Creates an instance.\n             * \n             * @param {object} thrower thrower instance\n             */\n            constructor: function(thrower) {\n                inherited.constructor.call(this);\n                this.__thrower = thrower;\n            },\n\n            /**\n             * Throws an exception object.\n             * \n             * @param e Exception object\n             */\n            throwException: function(e) {\n                this.__thrower.throwException(e);\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Exceptions.UncaughtErrorCatcher\", [\n    \"module:Exceptions.ErrorCatcher\",\n    \"module:Functions\"\n], function(ErrorCatcher, Functions, scoped) {\n    return ErrorCatcher.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * UncaughtErrorCatcher Object\n         * \n         * @class BetaJS.Exceptions.UncaughtErrorCatcher\n         */\n        return {\n\n            /**\n             * Creates an instance.\n             * \n             * @param {object} thrower Thrower object\n             */\n            constructor: function(thrower) {\n                inherited.constructor.call(this, thrower);\n                this.__listenerFunction = Functions.as_method(this._listenerFunction, this);\n                try {\n                    window.addEventListener(\"error\", this.__listenerFunction);\n                } catch (e) {}\n                try {\n                    process.on('uncaughtException', this.__listenerFunction);\n                } catch (e) {}\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                try {\n                    window.removeEventListener(\"error\", this.__listenerFunction);\n                } catch (e) {}\n                try {\n                    process.off('uncaughtException', this.__listenerFunction);\n                } catch (e) {}\n                inherited.destroy.call(this);\n            },\n\n            _listenerFunction: function(e) {\n                this.throwException(e);\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Exceptions.ExceptionThrower\", [\n    \"module:Class\"\n], function(Class, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n        /**\n         * Abstract Exception Thrower Class\n         * \n         * @class BetaJS.Exceptions.ExceptionThrower\n         */\n        return {\n\n            /**\n             * Throws an exception.\n             * \n             * @param {exception} e exception to be thrown\n             */\n            throwException: function(e) {\n                this._throwException(e);\n                return this;\n            },\n\n            _throwException: function(e) {\n                throw e;\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Exceptions.NullExceptionThrower\", [\n    \"module:Exceptions.ExceptionThrower\"\n], function(ExceptionThrower, scoped) {\n    return ExceptionThrower.extend({\n        scoped: scoped\n    }, function(inherited) {\n        /**\n         * Silentely forgets about the exception.\n         * \n         * @class BetaJS.Exceptions.NullExceptionThrower\n         */\n        return {\n\n            /**\n             * @override\n             */\n            _throwException: function(e) {}\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Exceptions.AsyncExceptionThrower\", [\n    \"module:Exceptions.ExceptionThrower\",\n    \"module:Async\"\n], function(ExceptionThrower, Async, scoped) {\n    return ExceptionThrower.extend({\n        scoped: scoped\n    }, function(inherited) {\n        /**\n         * Throws an exception asynchronously.\n         * \n         * @class BetaJS.Exceptions.AsyncExceptionThrower\n         */\n        return {\n\n            /**\n             * @override\n             */\n            _throwException: function(e) {\n                Async.eventually(function() {\n                    throw e;\n                });\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Exceptions.ConsoleExceptionThrower\", [\n    \"module:Exceptions.ExceptionThrower\",\n    \"module:Exceptions.NativeException\"\n], function(ExceptionThrower, NativeException, scoped) {\n    return ExceptionThrower.extend({\n        scoped: scoped\n    }, function(inherited) {\n        /**\n         * Throws execption by console-logging it.\n         * \n         * @class BetaJS.Exceptions.ConsoleExceptionThrower\n         */\n        return {\n\n            /**\n             * @override\n             */\n            _throwException: function(e) {\n                console.warn(e.toString());\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Exceptions.EventExceptionThrower\", [\n    \"module:Exceptions.ExceptionThrower\",\n    \"module:Events.EventsMixin\"\n], function(ExceptionThrower, EventsMixin, scoped) {\n    return ExceptionThrower.extend({\n        scoped: scoped\n    }, [EventsMixin, function(inherited) {\n        /**\n         * Throws exception by triggering an exception event.\n         * \n         * @class BetaJS.Exceptions.EventExceptionThrower\n         */\n        return {\n\n            /**\n             * @override\n             * @fires BetaJS.Exceptions.EventExceptionThrower#exception\n             */\n            _throwException: function(e) {\n                /**\n                 * @event BetaJS.Exceptions.EventExceptionThrower#exception\n                 */\n                this.trigger(\"exception\", e);\n            }\n\n        };\n    }]);\n});\nScoped.define(\"module:Exceptions.Exception\", [\n    \"module:Class\",\n    \"module:Comparators\"\n], function(Class, Comparators, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Exception Class\n         * \n         * @class BetaJS.Exceptions.Exception\n         */\n        return {\n\n            /**\n             * Instantiates a new exception.\n             * \n             * @param {string} message Exception message\n             */\n            constructor: function(message) {\n                inherited.constructor.call(this);\n                this.__message = message;\n                try {\n                    throw new Error();\n                } catch (e) {\n                    this.__stack = e.stack;\n                }\n            },\n\n            /**\n             * Asserts to be a certain type of exception. Throws this as an exception of assertion fails.\n             * \n             * @param {object} exception_class Exception class to be asserted\n             * @return {object} this\n             */\n            assert: function(exception_class) {\n                if (!this.instance_of(exception_class))\n                    throw this;\n                return this;\n            },\n\n            /**\n             * Returns exception message string.\n             * \n             * @return {string} Exception message string\n             */\n            message: function() {\n                return this.__message;\n            },\n\n            /**\n             * Returns exception stack.\n             * \n             * @return Exception stack\n             */\n            stack: function() {\n                return this.__stack;\n            },\n\n            /**\n             * Format exception as string.\n             * \n             * @return {string} Exception string\n             */\n            toString: function() {\n                return this.message();\n            },\n\n            /**\n             * Format exception as string including the classname.\n             * \n             * @return {string} Exception string plus classname\n             */\n            format: function() {\n                return this.cls.classname + \": \" + this.toString();\n            },\n\n            /**\n             * Returns exception data as JSON.\n             * \n             * @return {object} exception data\n             */\n            json: function() {\n                return {\n                    classname: this.cls.classname,\n                    message: this.message(),\n                    stack: this.stack()\n                };\n            },\n\n            /**\n             * Determines whether this exception is equal to another.\n             * \n             * @param {object} other Other exception\n             * @return {boolean} True if equal\n             */\n            equals: function(other) {\n                return other && this.cls === other.cls && Comparators.deepEqual(this.json(), other.json(), -1);\n            }\n\n        };\n    }, {\n\n        /**\n         * Ensures that a given exception is an instance of an Exception class\n         * \n         * @param e Exception\n         * @return {object} Exception instance\n         */\n        ensure: function(e) {\n            if (!this.is_instance_of(e))\n                throw \"Unasserted Exception \" + e;\n            return e;\n        }\n\n    });\n});\n\n\nScoped.define(\"module:Exceptions.NativeException\", [\n    \"module:Types\",\n    \"module:Objs\",\n    \"module:Exceptions.Exception\"\n], function(Types, Objs, Exception, scoped) {\n\n    var NativeException = Exception.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Native Exception Wrapper Class\n         * \n         * @class BetaJS.Exceptions.NativeException\n         */\n        return {\n\n            /**\n             * Instantiates a native exception wrapper.\n             * \n             * @param {object} object Native exception object\n             */\n            constructor: function(object) {\n                var message = \"null\";\n                this.__data = {};\n                if (object) {\n                    [\"name\", \"message\", \"filename\", \"lineno\"].forEach(function(key) {\n                        if (key in object)\n                            this.__data[key] = object[key];\n                    }, this);\n                }\n                inherited.constructor.call(this, object ? Objs.values(this.__data).join(\"; \") : \"null\");\n                this.__object = object;\n            },\n\n            /**\n             * Returns the original native exception object.\n             * \n             * @return {object} Native exception object\n             */\n            object: function() {\n                return this.__object;\n            },\n\n            /**\n             * Returns the extracted data.\n             * \n             * @return {object} Extracted data\n             */\n            data: function() {\n                return this.__data;\n            },\n\n            /**\n             * Returns exception data as JSON.\n             * \n             * @return {object} exception data\n             */\n            json: function() {\n                var j = inherited.json.call(this);\n                j.data = this.data();\n                return j;\n            }\n\n        };\n    }, {\n\n        /**\n         * Ensures that a given exception is an instance of an Exception class\n         * \n         * @param e Exception\n         * @return {object} Exception instance, possibly wrapping e as a NativeException\n         */\n        ensure: function(e) {\n            return NativeException.is_instance_of(e) ? e : new NativeException(e);\n        }\n\n    });\n\n    return NativeException;\n});\nScoped.define(\"module:Async\", [\n    \"module:Types\",\n    \"module:Functions\",\n    \"module:Time\"\n], function(Types, Functions, Time) {\n\n    var clearTimeoutGlobal = function(h) {\n        return clearTimeout(h);\n    };\n\n    var clearImmediate =\n        Functions.global_method(\"clearImmediate\") ||\n        Functions.global_method(\"cancelAnimationFrame\") ||\n        Functions.global_method(\"webkitCancelAnimationFrame\") ||\n        Functions.global_method(\"mozCancelAnimationFrame\") ||\n        clearTimeoutGlobal;\n\n    var setImmediate =\n        Functions.global_method(\"setImmediate\") ||\n        Functions.global_method(\"requestAnimationFrame\") ||\n        Functions.global_method(\"webkitRequestAnimationFrame\") ||\n        Functions.global_method(\"mozRequestAnimationFrame\") ||\n        function(cb) {\n            return setTimeout(cb, 0);\n        };\n\n\n    var __eventuallyOnce = {};\n    var __eventuallyOnceIdx = 1;\n\n\n    /**\n     * Auxilary functions for asynchronous operations.\n     * \n     * @module BetaJS.Async\n     */\n    var Module = {\n\n\n        /**\n         * Wait asynchronously for a condition to be met.\n         * \n         * @param {function} condition condition function\n         * @param {object} conditionCtx condition context (optional)\n         * @param {function} callback callback function\n         * @param {object} callbackCtx callback context (optional)\n         * @param {int} interval interval time between checks (optional, default 1)\n         * @param {function} timeoutCallback timeout callback function (optional)\n         * @param {object} timeoutCallbackCtx timeout callback context (optional)\n         * @param {int} timeout timeout (optional, default unlimited)\n         *\n         * \n         */\n        waitFor: function() {\n            var args = Functions.matchArgs(arguments, {\n                condition: true,\n                conditionCtx: \"object\",\n                callback: true,\n                callbackCtx: \"object\",\n                interval: \"number\",\n                timeoutCallback: \"function\",\n                timeoutCallbackCtx: \"object\",\n                timeout: \"number\"\n            });\n            var h = function() {\n                try {\n                    return !!args.condition.apply(args.conditionCtx || args.callbackCtx || this);\n                } catch (e) {\n                    return false;\n                }\n            };\n            var t = Time.now();\n            if (h())\n                args.callback.apply(args.callbackCtx || this);\n            else {\n                var timer = setInterval(function() {\n                    if (h()) {\n                        clearInterval(timer);\n                        args.callback.apply(args.callbackCtx || this);\n                    } else if (args.timeout && Time.now() - t >= args.timeout) {\n                        clearInterval(timer);\n                        if (args.timeoutCallback)\n                            args.timeoutCallback.apply(args.timeoutCallbackCtx || args.callbackCtx || this);\n                    }\n                }, args.interval || 1);\n                return timer;\n            }\n        },\n\n        /**\n         * Creates a function that executes a function asynchronously.\n         *\n         * @param {function} f function to be executed asynchronously\n         * @returns {function} asynchronous function\n         */\n        asyncify: function(f) {\n            return function() {\n                Module.eventually(f, this);\n            };\n        },\n\n\n        /**\n         * Execute a function asynchronously eventually.\n         * \n         * @param {function} function function to be executed asynchronously\n         * @param {array} params optional list of parameters to be passed to the function\n         * @param {object} context optional context for the function execution\n         * @param {int} time time to wait until execution (default is 0)\n         * \n         * @return handle to the eventual call\n         */\n        eventually: function() {\n            var args = Functions.matchArgs(arguments, {\n                func: true,\n                params: \"array\",\n                context: \"object\",\n                time: \"number\"\n            });\n            args.time = args.time || 0;\n            var result = {};\n            var cb = function() {\n                result.clear(result.handle);\n                args.func.apply(args.context || this, args.params || []);\n            };\n            if (args.time > 0) {\n                result.clear = clearTimeoutGlobal;\n                result.handle = setTimeout(cb, args.time);\n            } else {\n                result.clear = clearImmediate;\n                result.handle = setImmediate(cb);\n            }\n            return result;\n        },\n\n\n        /**\n         * Clears a call scheduled for eventual execution.\n         * \n         * @param ev event handle\n         * \n         */\n        clearEventually: function(ev) {\n            if (ev && ev.clear && ev.handle)\n                ev.clear(ev.handle);\n        },\n\n\n        /**\n         * Executes a function asynchronously eventually, but only once.\n         * \n         * @param {function} function function to be executed asynchronously\n         * @param {array} params list of parameters to be passed to the function\n         * @param {object} context optional context for the function execution\n         * \n         */\n        eventuallyOnce: function(func, params, context) {\n            var data = {\n                func: func,\n                params: params,\n                context: context\n            };\n            for (var key in __eventuallyOnce) {\n                var record = __eventuallyOnce[key];\n                if (record.func === func && record.params === params && record.context === context)\n                    return;\n            }\n            __eventuallyOnceIdx++;\n            var index = __eventuallyOnceIdx;\n            __eventuallyOnce[index] = data;\n            return this.eventually(function() {\n                delete __eventuallyOnce[index];\n                func.apply(context || this, params || []);\n            }, this);\n        }\n\n    };\n\n    return Module;\n\n});\nScoped.define(\"module:Promise\", [\n    \"module:Types\",\n    \"module:Functions\",\n    \"module:Async\",\n    \"module:Objs\"\n], function(Types, Functions, Async, Objs) {\n\n    /**\n     * Promise Class\n     * \n     * @class BetaJS.Promise\n     */\n    var PromiseCls = {\n\n        /**\n         * Creates a new promise instance.\n         * \n         * @param value optional promise value\n         * @param error optional promise error\n         * @param {boolean} finished does this promise have its final value / error\n         */\n        Promise: function(value, error, finished) {\n            this.__value = error ? null : (value === undefined ? null : value);\n            this.__error = error ? error : null;\n            this.__isFinished = finished;\n            this.__hasError = !!error;\n            this.__resultPromise = null;\n            this.__callbacks = [];\n        },\n\n        fromNativePromise: function(nativePromise) {\n            var promise = this.create();\n            nativePromise.then(function(value) {\n                promise.asyncSuccess(value);\n            })['catch'](function(error) {\n                promise.asyncError(error);\n            });\n            return promise;\n        },\n\n        /**\n         * Create a new promise instance. (Simplified)\n         * \n         * @param value optional promise value\n         * @param error optional promise error\n         * \n         * @return {object} promise instance\n         */\n        create: function(value, error) {\n            return new this.Promise(value, error, arguments.length > 0);\n        },\n\n        /**\n         * Returns a promise instance for a value. The value might be a promise itself already.\n         * \n         * @param value promise value or promise\n         * @return {object} promise instance\n         */\n        value: function(value) {\n            return this.is(value) ? value : new this.Promise(value, null, true);\n        },\n\n        /**\n         * Returns a promise instance for a value, setting the value asynchronously.\n         * \n         * @param value promise value\n         * @return {object} promise instance\n         */\n        eventualValue: function(value) {\n            var promise = new this.Promise();\n            Async.eventually(function() {\n                promise.asyncSuccess(value);\n            });\n            return promise;\n        },\n\n        /**\n         * Returns a promise instance for an error. The error might be a promise itself already.\n         * \n         * @param error promise error or promise\n         * @return {object} promise instance\n         */\n        error: function(error) {\n            return this.is(error) ? error : new this.Promise(null, error, true);\n        },\n\n        /**\n         * Turns a function call or a native promise into a promise, mapping exceptions to errors.\n         * \n         * @param {function} f function or native promise\n         * @param {object} ctx optional function context\n         * @param {array} params optional function parameters\n         * \n         * @return {object} promise\n         */\n        box: function(f, ctx, params) {\n            if (f && 'then' in f && 'catch' in f) {\n                var promise = this.create();\n                f.then(promise.asyncSuccessFunc());\n                f['catch'](promise.asyncErrorFunc());\n                return promise;\n            } else {\n                try {\n                    var result = f.apply(ctx || this, params || []);\n                    return this.is(result) ? result : this.value(result);\n                } catch (e) {\n                    return this.error(e);\n                }\n            }\n        },\n\n        /**\n         * Try-Catch a function, wrapping it into a promise.\n         * \n         * @param {function} f function\n         * @param {object} ctx optional function context\n         * \n         * @return {object} promise\n         */\n        tryCatch: function(f, ctx) {\n            try {\n                return this.value(f.apply(ctx || this));\n            } catch (e) {\n                return this.error(e);\n            }\n        },\n\n        /**\n         * Turns a function accepting a callback function as last parameter into a promise.\n         * \n         * @param {object} optional function context\n         * @param {function} func function\n         * \n         * @return {object} promise\n         */\n        funcCallback: function(ctx, func) {\n            var args = [];\n            if (Types.is_function(ctx)) {\n                args = Functions.getArguments(arguments, 1);\n                func = ctx;\n                ctx = this;\n            } else\n                args = Functions.getArguments(arguments, 2);\n            var promise = this.create();\n            args.push(promise.asyncCallbackFunc());\n            func.apply(ctx, args);\n            return promise;\n        },\n\n        /**\n         * Takes a number of promises and creates a single new promise being successful if and only if all input promises are successful.\n         * \n         * @param {array} promises promises array\n         * \n         * @return {object} promise\n         */\n        and: function(promises) {\n            var promise = this.create();\n            promise.__promises = [];\n            promise.__successCount = 0;\n            promise.__values = [];\n            promise.__errorPromise = null;\n            promise.and = function(promises) {\n                promises = promises || [];\n                if (this.__ended)\n                    return this;\n                if (!Types.is_array(promises))\n                    promises = [promises];\n                var f = function(error, value) {\n                    if (error)\n                        this.promise.__errorPromise = this.promise.__promises[this.idx];\n                    else {\n                        this.promise.__successCount++;\n                        this.promise.__values[this.idx] = value;\n                    }\n                    this.promise.results();\n                };\n                for (var i = 0; i < promises.length; ++i) {\n                    var last = this.__promises.length;\n                    this.__promises.push(promises[i]);\n                    this.__values.push(null);\n                    if (promises[i].isFinished()) {\n                        if (promises[i].hasValue()) {\n                            this.__successCount++;\n                            this.__values[last] = promises[i].value();\n                        } else\n                            this.__errorPromise = promises[i];\n                    } else {\n                        promises[i].callback(f, {\n                            promise: this,\n                            idx: last\n                        });\n                    }\n                }\n                return this;\n            };\n            promise.end = function() {\n                if (this.__ended)\n                    return this;\n                this.__ended = true;\n                this.results();\n                return this;\n            };\n            promise.results = function() {\n                if (this.__ended && this.__errorPromise)\n                    this.asyncError(this.__errorPromise.err(), this.__errorPromise);\n                else if (this.__ended && this.__successCount == this.__promises.length)\n                    this.asyncSuccess(this.__values);\n                return this;\n            };\n            promise.successUnfold = function(f, context, options) {\n                return this.success(function() {\n                    return f.apply(context, arguments);\n                }, context, options);\n            };\n            promise.and(promises);\n            return promise;\n        },\n\n        /*\n         *\n         * Promise.conditional(BOOLEAN_CONDITION, function () {\n         *      return ... promise ....;\n         * }, DEFAULT_VALUE)\n         *\n         */\n        conditional: function(condition, promiseFactory, defaultValue) {\n            return condition ? promiseFactory() : this.value(defaultValue);\n        },\n\n        /**\n         * Takes a function and calls with a number of arguments, some of which might be promises and turns it into actual values.\n         * \n         * @param {function} func function\n         * \n         * @return {object} promise\n         */\n        func: function(func) {\n            var args = Functions.getArguments(arguments, 1);\n            var promises = [];\n            for (var i = 0; i < args.length; ++i) {\n                if (this.is(args[i]))\n                    promises.push(args[i]);\n            }\n            var promise = this.create();\n            this.and(promises).end().success(function(values) {\n                var params = [];\n                for (var i = 0; i < args.length; ++i)\n                    params[i] = this.is(args[i]) ? args[i].value() : args[i];\n                var result = func.apply(this, params);\n                if (this.is(result))\n                    result.forwardCallback(promise);\n                else\n                    promise.asyncSuccess(result);\n            }, this).forwardError(promise);\n            return promise;\n        },\n\n        /**\n         * Takes a method and calls with a number of arguments, some of which might be promises and turns it into actual values.\n         * \n         * @param {object} ctx function context\n         * @param {function} func function\n         * @param {array} params parameters\n         * \n         * @return {object} promise\n         */\n        methodArgs: function(ctx, func, params) {\n            params.unshift(function() {\n                return func.apply(ctx, arguments);\n            });\n            return this.func.apply(this, params);\n        },\n\n        /**\n         * Takes a method and calls with a number of arguments, some of which might be promises and turns it into actual values.\n         * \n         * @param {object} ctx function context\n         * @param {function} func function\n         * \n         * @return {object} promise\n         */\n        method: function(ctx, func) {\n            return this.methodArgs(ctx, func, Functions.getArguments(arguments, 2));\n        },\n\n        /**\n         * Takes a constructor and calls with a number of arguments, some of which might be promises and turns it into actual values.\n         * \n         * @param {object} cls constructor class\n         * \n         * @return {object} promise\n         */\n        newClass: function(cls) {\n            var params = Functions.getArguments(arguments, 1);\n            params.unshift(Functions.newClassFunc(cls));\n            return this.func.apply(this, params);\n        },\n\n        /**\n         * Determines whether some value is a promise object.\n         * \n         * @param obj value\n         * \n         * @return {boolean} true if obj is a promise object\n         */\n        is: function(obj) {\n            return obj && Types.is_object(obj) && obj.classGuid == this.Promise.prototype.classGuid;\n        },\n\n        /**\n         * Applies a method multiple times until it succeeds.\n         * \n         * @param {function} method method\n         * @param {object} context method context\n         * @param {int} resilience number of times to call\n         * @param {array} args arguments for method\n         * @param {int} delay optional delay in-between tries\n         * \n         * @return {object} promise\n         */\n        resilience: function(method, context, resilience, args, delay) {\n            if (delay)\n                method = this.delayPromiseMethod(method, delay);\n            return method.apply(context, args).mapError(function(error) {\n                return resilience === 0 ? error : this.resilience(method, context, resilience - 1, args);\n            }, this);\n        },\n\n        /**\n         * Creates a new method returning a promise based on a method returning a promise by delaying the underlying method.\n         *\n         * @param {function} method original method\n         * @param {int} delay delay time\n         * @returns {function} delayed method\n         */\n        delayPromiseMethod: function(method, delay) {\n            var self = this;\n            return function() {\n                var promise = self.create();\n                var args = Functions.getArguments(arguments);\n                Async.eventually(function() {\n                    method.apply(this, args).forwardCallback(promise);\n                }, this, delay);\n                return promise;\n            };\n        },\n\n        /**\n         * Wait asynchronously for a condition to be met.\n         *\n         * @param {function} condition condition function\n         * @param {object} conditionCtx condition context (optional)\n         * @param {int} interval interval time between checks (optional, default 1)\n         * @param {int} timeout optional timeout\n         *\n         * @return {object} promise\n         *\n         */\n        waitFor: function(condition, conditionCtx, interval, timeout) {\n            var promise = this.create();\n            var successTimer, errorTimer;\n            if (timeout) {\n                errorTimer = setTimeout(function() {\n                    if (successTimer)\n                        clearInterval(successTimer);\n                    promise.asyncError(true);\n                }, timeout);\n            }\n            successTimer = Async.waitFor(condition, conditionCtx, function() {\n                if (errorTimer)\n                    clearTimeout(errorTimer);\n                promise.asyncSuccess(true);\n            }, interval);\n            return promise;\n        },\n\n        /**\n         * Exclusively execute a promise-based function by postponing execution of further calls by waiting for the\n         * promise completion.\n         *\n         * @param {function} promiseFunc promise function\n         * @param {object} ctx function context (optional)\n         *\n         * @return {function} exclusive function\n         *\n         */\n        exclusiveExecution: function(promiseFunc, ctx) {\n            var currentPromise = null;\n            var promiseQueue = [];\n            return function() {\n                var args = arguments;\n                var resultPromise = null;\n                if (!currentPromise) {\n                    currentPromise = promiseFunc.apply(ctx, args);\n                    resultPromise = currentPromise;\n                } else {\n                    var promise = PromiseCls.create();\n                    promiseQueue.push(promise);\n                    resultPromise = promise.mapSuccess(function() {\n                        return promiseFunc.apply(this, args);\n                    }, ctx);\n                }\n                resultPromise.callback(function() {\n                    currentPromise = null;\n                    if (promiseQueue.length > 0) {\n                        currentPromise = promiseQueue.shift();\n                        currentPromise.asyncSuccess(true);\n                    }\n                });\n                return resultPromise;\n            };\n        },\n\n        aggregateExecution: function(promiseFunc, ctx, serializer, successCloner) {\n            var argMap = {};\n            return function() {\n                var args = arguments;\n                var serializedArgs = serializer ? serializer(args) : JSON.stringify(args);\n                var promise = argMap[serializedArgs];\n                if (!promise) {\n                    var keep = true;\n                    promise = promiseFunc.apply(ctx, args).callback(function() {\n                        keep = false;\n                        delete argMap[serializedArgs];\n                    }).mapSuccess(function(data) {\n                        return successCloner ? successCloner(data) : data;\n                    });\n                    if (keep)\n                        argMap[serializedArgs] = promise;\n                }\n                return promise;\n            };\n        }\n\n\n    };\n\n    Objs.extend(PromiseCls.Promise.prototype, {\n        classGuid: \"7e3ed52f-22da-4e9c-95a4-e9bb877a3935\",\n\n        /**\n         * Be notified when the promise is successful.\n         * \n         * @param {function} f callback function\n         * @param {object} context optional callback context\n         * @param {object} options optional options\n         */\n        success: function(f, context, options) {\n            return this.callback(f, context, options, \"success\");\n        },\n\n        /**\n         * Be notified when the promise is successful asynchronously.\n         *\n         * @param {function} f callback function\n         * @param {object} context optional callback context\n         * @param {object} options optional options\n         */\n        asuccess: function(f, context, options) {\n            return this.success(Async.asyncify(f), context, options);\n        },\n\n        /**\n         * Set an object value once value is known.\n         *\n         * @param {object} obj object\n         * @param {string} key key to set value for\n         */\n        valueify: function(obj, key) {\n            return this.success(function(value) {\n                obj[key] = value;\n            });\n        },\n\n        /**\n         * Be notified when the promise is unsuccessful.\n         * \n         * @param {function} f callback function\n         * @param {object} context optional callback context\n         * @param {object} options optional options\n         */\n        error: function(f, context, options) {\n            return this.callback(f, context, options, \"error\");\n        },\n\n        /**\n         * Be notified when the promise is finished..\n         * \n         * @param {function} f callback function\n         * @param {object} context callback context\n         * @param {object} options options\n         * @param {string} type type of callback like \"success\"\n         */\n        callback: function(f, context, options, type) {\n            if (\"end\" in this)\n                this.end();\n            var record = {\n                type: type || \"callback\",\n                func: f,\n                options: options || {},\n                context: context\n            };\n            if (this.__isFinished)\n                this.triggerResult(record);\n            else\n                this.__callbacks.push(record);\n            return this;\n        },\n\n        /**\n         * Be notified when the promise does not finish with a certain time.\n         *\n         * @param {int} delay delay timeout\n         * @param {function} f callback function\n         * @param {object} context callback context\n         */\n        timeout: function(delay, f, context) {\n            var ev = Async.eventually(f, context, delay);\n            return this.callback(function() {\n                Async.clearEventually(ev);\n            });\n        },\n\n        /**\n         * Timeout with an error.\n         *\n         * @param {int} delay delay timeout\n         * @param error error value\n         */\n        timeoutError: function(delay, error) {\n            if (!delay)\n                return this;\n            return this.timeout(delay, function() {\n                this.asyncError(error);\n            }, this);\n        },\n\n        /**\n         * Trigger the result.\n         * \n         * @param {object} record optional specific callback record\n         * \n         */\n        triggerResult: function(record) {\n            if (!this.__isFinished)\n                return this;\n            if (record) {\n                if (record.type == \"success\" && !this.__hasError)\n                    record.func.call(record.context || this, this.__value, this.__resultPromise || this);\n                else if (record.type == \"error\" && this.__hasError)\n                    record.func.call(record.context || this, this.__error, this.__resultPromise || this);\n                else if (record.type == \"callback\")\n                    record.func.call(record.context || this, this.__error, this.__value, this.__resultPromise || this);\n            } else {\n                var records = this.__callbacks;\n                this.__callbacks = [];\n                for (var i = 0; i < records.length; ++i)\n                    this.triggerResult(records[i]);\n            }\n            return this;\n        },\n\n        /**\n         * Returns the value of the promise.\n         * \n         * @return value of promise\n         */\n        value: function() {\n            return this.__value;\n        },\n\n        /**\n         * Returns the error of the promise.\n         * \n         * @return error of promise\n         */\n        err: function() {\n            return this.__error;\n        },\n\n        /**\n         * Determines whether the promise has a value or an error already.\n         * \n         * @return {boolean} true if value or error present\n         */\n        isFinished: function() {\n            return this.__isFinished;\n        },\n\n        /**\n         * Determines whether the promise has a value.\n         * \n         * @return {boolean} true if value present\n         */\n        hasValue: function() {\n            return this.__isFinished && !this.__hasError;\n        },\n\n        /**\n         * Determines whether the promise has an error.\n         * \n         * @return {boolean} true if error present\n         */\n        hasError: function() {\n            return this.__isFinished && this.__hasError;\n        },\n\n        /**\n         * Informs the promise of a successful value.\n         * \n         * @param value success value\n         * @param {object} promise optional success promise\n         */\n        asyncSuccess: function(value, promise) {\n            if (this.__isFinished)\n                return this;\n            this.__resultPromise = promise;\n            this.__error = null;\n            this.__isFinished = true;\n            this.__hasError = false;\n            this.__value = value;\n            return this.triggerResult();\n        },\n\n        /**\n         * Informs the promise of an error value.\n         * \n         * @param error error value\n         * @param {object} promise optional error promise\n         */\n        asyncError: function(error, promise) {\n            if (this.__isFinished)\n                return this;\n            this.__resultPromise = promise;\n            this.__isFinished = true;\n            this.__hasError = true;\n            this.__error = error;\n            this.__value = null;\n            return this.triggerResult();\n        },\n\n        /**\n         * Informs the promise of an error or success value.\n         * \n         * @param error optional error value\n         * @param value optional success value\n         * @param {object} promise optional callback promise\n         */\n        asyncCallback: function(error, value, promise) {\n            if (error)\n                return this.asyncError(error, promise);\n            else\n                return this.asyncSuccess(value, promise);\n        },\n\n        /**\n         * Forwards the success of this promise to another promise.\n         * \n         * @param {object} promise promise to which the success should be forwarded to\n         */\n        forwardSuccess: function(promise) {\n            this.success(promise.asyncSuccess, promise);\n            return this;\n        },\n\n        /**\n         * Forwards the error of this promise to another promise.\n         * \n         * @param {object} promise promise to which the error should be forwarded to\n         */\n        forwardError: function(promise) {\n            this.error(promise.asyncError, promise);\n            return this;\n        },\n\n        /**\n         * Forwards the callback of this promise to another promise.\n         * \n         * @param {object} promise promise to which the callback should be forwarded to\n         */\n        forwardCallback: function(promise) {\n            this.callback(promise.asyncCallback, promise);\n            return this;\n        },\n\n        /**\n         * Generates a context-less function for the asynchronous callback.\n         * \n         * @return {function} context-less function\n         */\n        asyncCallbackFunc: function() {\n            return Functions.as_method(this.asyncCallback, this);\n        },\n\n        /**\n         * Generates a context-less function for the asynchronous success.\n         *\n         * @return {function} context-less function\n         */\n        asyncSuccessFunc: function() {\n            return Functions.as_method(this.asyncSuccess, this);\n        },\n\n        /**\n         * Generates a context-less function for the asynchronous error.\n         *\n         * @return {function} context-less function\n         */\n        asyncErrorFunc: function() {\n            return Functions.as_method(this.asyncError, this);\n        },\n\n        /**\n         * Maps the success value of the promise to a function that might return another promise.\n         * \n         * @param {function} func success callback\n         * @param {object} ctx optional context\n         * \n         * @return {object} promise\n         */\n        mapSuccess: function(func, ctx) {\n            var promise = PromiseCls.create();\n            this.forwardError(promise).success(function(value, pr) {\n                try {\n                    var result = func.call(ctx || promise, value, pr);\n                    if (PromiseCls.is(result))\n                        result.forwardCallback(promise);\n                    else\n                        promise.asyncSuccess(result);\n                } catch (e) {\n                    if (this.__callbacks.every(function(cb) {\n                            return cb.type === \"success\";\n                        })) {\n                        console.warn(e);\n                    }\n                    promise.asyncError(e);\n                }\n            });\n            return promise;\n        },\n\n        /**\n         * Maps the success value of the promise asynchronously to a function that might return another promise.\n         *\n         * @param {function} func success callback\n         * @param {object} ctx optional context\n         *\n         * @return {object} promise\n         */\n        mapASuccess: function(func, ctx) {\n            return this.mapSuccess(function(result) {\n                var promise = PromiseCls.create();\n                Async.eventually(function() {\n                    PromiseCls.box(func, ctx, [result]).forwardCallback(promise);\n                });\n                return promise;\n            });\n        },\n\n        /**\n         * Maps the error value of the promise to a function that might return another promise.\n         * \n         * @param {function} func error callback\n         * @param {object} ctx optional context\n         * \n         * @return {object} promise\n         */\n        mapError: function(func, ctx) {\n            var promise = PromiseCls.create();\n            this.forwardSuccess(promise).error(function(err, pr) {\n                var result = func.call(ctx || promise, err, pr);\n                if (PromiseCls.is(result))\n                    result.forwardCallback(promise);\n                else\n                    promise.asyncError(result);\n            });\n            return promise;\n        },\n\n        /**\n         * Maps the error or success value of the promise to a function that might return another promise.\n         * \n         * @param {function} func callback function\n         * @param {object} ctx optional context\n         * \n         * @return {object} promise\n         */\n        mapCallback: function(func, ctx) {\n            var promise = PromiseCls.create();\n            this.callback(function(err, value, pr) {\n                var result = func.call(ctx || promise, err, value, pr);\n                if (PromiseCls.is(result))\n                    result.forwardCallback(promise);\n                else\n                    promise.asyncCallback(err ? result : err, err ? value : result, pr);\n            });\n            return promise;\n        },\n\n        /**\n         * Concatenates more promises to this promise\n         * \n         * @param {array} promises other promises\n         * \n         * @return {object} promise\n         */\n        and: function(promises) {\n            var result = PromiseCls.and(this);\n            return result.and(promises);\n        },\n\n        toNativePromise: function() {\n            var self = this;\n            return new Promise(function(resolve, reject) {\n                self.callback(function(error, value) {\n                    if (error)\n                        reject(error);\n                    else\n                        resolve(value);\n                });\n            });\n        }\n\n    });\n\n    return PromiseCls;\n});\nScoped.define(\"module:Timers.Timer\", [\n    \"module:Class\",\n    \"module:Objs\",\n    \"module:Time\"\n], function(Class, Objs, Time, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Timer Class\n         * \n         * @class BetaJS.Timers.Timer\n         */\n        return {\n\n            /**\n             * Create a new timer instance.\n             * \n             * @param {object} options, including\n             *   int delay (mandatory): number of milliseconds until it fires\n             *   bool once (optional, default false): should it fire infinitely often\n             *   func fire (optional): will be fired\n             *   object context (optional): for fire\n             *   bool start (optional, default true): should it start immediately\n             *   bool real_time (default false)\n             *   bool immediate (optional, default false): zero time until first fire\n             *   int duration (optional, default null)\n             *   int fire_max (optional, default null)\n             * \n             */\n            constructor: function(options) {\n                inherited.constructor.call(this);\n                options = Objs.extend({\n                    once: false,\n                    start: true,\n                    fire: null,\n                    context: this,\n                    destroy_on_fire: false,\n                    destroy_on_stop: false,\n                    real_time: false,\n                    duration: null,\n                    fire_max: null,\n                    immediate: false\n                }, options);\n                this.__immediate = options.immediate;\n                this.__delay = options.delay;\n                this.__destroy_on_fire = options.destroy_on_fire;\n                this.__destroy_on_stop = options.destroy_on_stop;\n                this.__once = options.once;\n                this.__fire = options.fire;\n                this.__context = options.context;\n                this.__started = false;\n                this.__real_time = options.real_time;\n                this.__end_time = options.duration !== null ? Time.now() + options.duration : null;\n                this.__fire_max = options.fire_max;\n                if (options.start)\n                    this.start();\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                this.stop();\n                inherited.destroy.call(this);\n            },\n\n            /**\n             * Returns the number of times the timer has fired.\n             * \n             * @return {int} fire count\n             */\n            fire_count: function() {\n                return this.__fire_count;\n            },\n\n            /**\n             * Returns the current duration of timer.\n             * \n             * @return {int} duration in milliseconds\n             */\n            duration: function() {\n                return Time.now() - this.__start_time;\n            },\n\n            /**\n             * Fired when the timer fires.\n             */\n            fire: function() {\n                if (this.__once)\n                    this.__started = false;\n                if (this.__fire) {\n                    this.__fire.call(this.__context, this);\n                    this.__fire_count++;\n                    if (this.__real_time && !this.__destroy_on_fire && !this.__once) {\n                        while ((this.__fire_count + 1) * this.__delay <= Time.now() - this.__start_time) {\n                            this.__fire.call(this.__context, this);\n                            this.__fire_count++;\n                        }\n                    }\n                }\n                if ((this.__end_time !== null && Time.now() + this.__delay > this.__end_time) ||\n                    (this.__fire_max !== null && this.__fire_max <= this.__fire_count))\n                    this.stop();\n                if (this.__destroy_on_fire)\n                    this.weakDestroy();\n            },\n\n            /**\n             * Stops the timer.\n             * \n             * @return {object}\n             */\n            stop: function() {\n                if (!this.__started)\n                    return this;\n                if (this.__once)\n                    clearTimeout(this.__timer);\n                else\n                    clearInterval(this.__timer);\n                this.__started = false;\n                if (this.__destroy_on_stop)\n                    this.weakDestroy();\n                return this;\n            },\n\n            /**\n             * Starts the timer.\n             * \n             * @return {object} this\n             */\n            start: function() {\n                if (this.__started)\n                    return this;\n                var self = this;\n                this.__start_time = Time.now();\n                this.__fire_count = 0;\n                if (this.__once)\n                    this.__timer = setTimeout(function() {\n                        self.fire();\n                    }, this.__delay);\n                else\n                    this.__timer = setInterval(function() {\n                        self.fire();\n                    }, this.__delay);\n                this.__started = true;\n                if (this.__immediate)\n                    this.fire();\n                return this;\n            },\n\n            /**\n             * Restarts the timer.\n             * \n             * @return {object} this\n             */\n            restart: function() {\n                this.stop();\n                this.start();\n                return this;\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Iterators.ArrayIterator\", [\"module:Iterators.Iterator\"], function(Iterator, scoped) {\n    return Iterator.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * ArrayIterator Class\n         * \n         * @class BetaJS.Iterators.ArrayIterator\n         */\n        return {\n\n            /**\n             * Creates an Array Iterator\n             * \n             * @param {array} arr array\n             */\n            constructor: function(arr) {\n                inherited.constructor.call(this);\n                this.__array = arr;\n                this.__i = 0;\n            },\n\n            /**\n             * @override\n             */\n            hasNext: function() {\n                return this.__i < this.__array.length;\n            },\n\n            /**\n             * @override\n             */\n            next: function() {\n                var ret = this.__array[this.__i];\n                this.__i++;\n                return ret;\n            }\n\n        };\n    }, {\n\n        /**\n         * Creates an Array Iterator by an iteration function\n         * \n         * @param {function} iterate_func Iteration function\n         * @param {object} iterate_func_ctx Optional context\n         * \n         * @return {object} Array Iterator instance\n         */\n        byIterate: function(iterate_func, iterate_func_ctx) {\n            var result = [];\n            iterate_func.call(iterate_func_ctx || this, function(item) {\n                result.push(item);\n            }, this);\n            return new this(result);\n        }\n    });\n});\n\n\nScoped.define(\"module:Iterators.NativeMapIterator\", [\"module:Iterators.Iterator\"], function(Iterator, scoped) {\n    return Iterator.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * NativeMapIterator Class\n         * \n         * @class BetaJS.Iterators.NativeMapIterator\n         */\n        return {\n\n            /**\n             * Creates a Native Map Iterator\n             * \n             * @param {Map} map Iterator based on the values of this native map\n             */\n            constructor: function(map) {\n                inherited.constructor.call(this);\n                this.__iter = map.values();\n                this.__next = this.__iter.next();\n            },\n\n            /**\n             * @override\n             */\n            hasNext: function() {\n                return !this.__next.done;\n            },\n\n            /**\n             * @override\n             */\n            next: function() {\n                var value = this.__next.value;\n                this.__next = this.__iter.next();\n                return value;\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Iterators.ObjectKeysIterator\", [\"module:Iterators.ArrayIterator\"], function(ArrayIterator, scoped) {\n    return ArrayIterator.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * ObjectKeysIterator Class\n         * \n         * @class BetaJS.Iterators.ObjectKeysIterator\n         */\n        return {\n\n            /**\n             * Creates an Object Keys Iterator\n             * \n             * @param {object} obj Object to create iterator from\n             */\n            constructor: function(obj) {\n                inherited.constructor.call(this, Object.keys(obj));\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Iterators.ObjectValuesIterator\", [\"module:Iterators.ArrayIterator\", \"module:Objs\"], function(ArrayIterator, Objs, scoped) {\n    return ArrayIterator.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * ObjectValuesIterator Class\n         * \n         * @class BetaJS.Iterators.ObjectValuesIterator\n         */\n        return {\n\n            /**\n             * Creates an Object Values Iterator\n             * \n             * @param {object} obj Object to create iterator from\n             */\n            constructor: function(obj) {\n                inherited.constructor.call(this, Objs.values(obj));\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Iterators.LazyMultiArrayIterator\", [\"module:Iterators.LazyIterator\"], function(Iterator, scoped) {\n    return Iterator.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * LazyMultiArrayIterator Class\n         * \n         * @class BetaJS.Iterators.LazyMultiArrayIterator\n         */\n        return {\n\n            /**\n             * Creates a Lazy Multi Array Iterator\n             * \n             * @param {function} next_callback Function returning the next array\n             * @param {object} next_context Context for next function\n             */\n            constructor: function(next_callback, next_context) {\n                inherited.constructor.call(this);\n                this.__next_callback = next_callback;\n                this.__next_context = next_context;\n                this.__array = null;\n                this.__i = 0;\n            },\n\n            /**\n             * @override\n             */\n            _next: function() {\n                if (this.__array === null || this.__i >= this.__array.length) {\n                    this.__array = this.__next_callback.apply(this.__next_context);\n                    this.__i = 0;\n                }\n                if (this.__array !== null) {\n                    var ret = this.__array[this.__i];\n                    this.__i++;\n                    return ret;\n                } else\n                    this._finished();\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Iterators.MappedIterator\", [\"module:Iterators.Iterator\"], function(Iterator, scoped) {\n    return Iterator.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * A delegated iterator class, mapping each object using a function.\n         * \n         * @class BetaJS.Iterators.MappedIterator\n         */\n        return {\n\n            /**\n             * Create a new instance.\n             * \n             * @param {object} iterator Source iterator\n             * @param {function} map Function mapping source objects to target objects\n             * @param {object} context Context for the map function\n             */\n            constructor: function(iterator, map, context) {\n                inherited.constructor.call(this);\n                this.__iterator = iterator;\n                this.__map = map;\n                this.__context = context || this;\n            },\n\n            /**\n             * @override\n             */\n            hasNext: function() {\n                return this.__iterator.hasNext();\n            },\n\n            /**\n             * @override\n             */\n            next: function() {\n                return this.hasNext() ? this.__map.call(this.__context, this.__iterator.next()) : null;\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Iterators.FilteredIterator\", [\"module:Iterators.Iterator\"], function(Iterator, scoped) {\n    return Iterator.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * A delegated iterator class, filtering single objects by a function.\n         * \n         * @class BetaJS.Iterators.FilteredIterator\n         */\n        return {\n\n            /**\n             * Create a new instance.\n             * \n             * @param {object} iterator Source iterator\n             * @param {function} filter Filter function\n             * @param {object} context Context for the filter function\n             */\n            constructor: function(iterator, filter, context) {\n                inherited.constructor.call(this);\n                this.__iterator = iterator;\n                this.__filter = filter;\n                this.__context = context || this;\n                this.__next = null;\n            },\n\n            /**\n             * @override\n             */\n            hasNext: function() {\n                this.__crawl();\n                return this.__next !== null;\n            },\n\n            /**\n             * @override\n             */\n            next: function() {\n                this.__crawl();\n                var item = this.__next;\n                this.__next = null;\n                return item;\n            },\n\n            __crawl: function() {\n                while (!this.__next && this.__iterator.hasNext()) {\n                    var item = this.__iterator.next();\n                    if (this.__filter_func(item))\n                        this.__next = item;\n                }\n            },\n\n            __filter_func: function(item) {\n                return this.__filter.apply(this.__context, [item]);\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Iterators.SkipIterator\", [\"module:Iterators.Iterator\"], function(Iterator, scoped) {\n    return Iterator.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * A delegated iterator class, skipping some elements.\n         * \n         * @class BetaJS.Iterators.SkipIterator\n         */\n        return {\n\n            /**\n             * Create an instance.\n             * \n             * @param {object} iterator Source iterator\n             * @param {int} skip How many elements should be skipped\n             */\n            constructor: function(iterator, skip) {\n                inherited.constructor.call(this);\n                this.__iterator = iterator;\n                while (skip > 0) {\n                    iterator.next();\n                    skip--;\n                }\n            },\n\n            /**\n             * @override\n             */\n            hasNext: function() {\n                return this.__iterator.hasNext();\n            },\n\n            /**\n             * @override\n             */\n            next: function() {\n                return this.__iterator.next();\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Iterators.LimitIterator\", [\"module:Iterators.Iterator\"], function(Iterator, scoped) {\n    return Iterator.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * A delegated iterator class, limiting the number of elements iterated.\n         * \n         * @class BetaJS.Iterators.LimitIterator\n         */\n        return {\n\n            /**\n             * Creates an instance.\n             * \n             * @param {object} iterator Source iterator\n             * @param {int} limit What should be the maximum number of elements\n             */\n            constructor: function(iterator, limit) {\n                inherited.constructor.call(this);\n                this.__iterator = iterator;\n                this.__limit = limit;\n            },\n\n\n            /**\n             * @override\n             */\n            hasNext: function() {\n                return this.__limit > 0 && this.__iterator.hasNext();\n            },\n\n            /**\n             * @override\n             */\n            next: function() {\n                if (this.__limit <= 0)\n                    return null;\n                this.__limit--;\n                return this.__iterator.next();\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Iterators.SortedIterator\", [\"module:Iterators.Iterator\"], function(Iterator, scoped) {\n    return Iterator.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * A delegated iterator class, sorting the source objects by a comparator.\n         * \n         * @class BetaJS.Iterators.SortedIterator\n         */\n        return {\n\n            /**\n             * Create an instance.\n             * \n             * @param {object} iterator Source iterator\n             * @param {function} compare Function comparing two elements of the source iterator\n             */\n            constructor: function(iterator, compare) {\n                inherited.constructor.call(this);\n                this.__array = iterator.asArray();\n                this.__array.sort(compare);\n                this.__i = 0;\n            },\n\n            /**\n             * @override\n             */\n            hasNext: function() {\n                return this.__i < this.__array.length;\n            },\n\n            /**\n             * @override\n             */\n            next: function() {\n                var ret = this.__array[this.__i];\n                this.__i++;\n                return ret;\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Iterators.LazyIterator\", [\"module:Iterators.Iterator\"], function(Iterator, scoped) {\n    return Iterator.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Lazy Iterator Class that is based on only getting next elements without an internal hasNext.\n         * \n         * @class BetaJS.Iterators.LazyIterator\n         */\n        return {\n\n            /**\n             * Create an instance.\n             * \n             */\n            constructor: function() {\n                inherited.constructor.call(this);\n                this.__finished = false;\n                this.__initialized = false;\n                this.__current = null;\n                this.__has_current = false;\n            },\n\n            /**\n             * Initialize lazy iterator.\n             */\n            _initialize: function() {},\n\n            /**\n             * Get next element.\n             * \n             * @return next element\n             */\n            _next: function() {},\n\n            /**\n             * The lazy iterator is finished.\n             */\n            _finished: function() {\n                this.__finished = true;\n            },\n\n            /**\n             * Set current element of lazy iterator.\n             * \n             * @param result current element\n             */\n            _current: function(result) {\n                this.__current = result;\n                this.__has_current = true;\n            },\n\n            __touch: function() {\n                if (!this.__initialized)\n                    this._initialize();\n                this.__initialized = true;\n                if (!this.__has_current && !this.__finished)\n                    this._next();\n            },\n\n            /**\n             * @override\n             */\n            hasNext: function() {\n                this.__touch();\n                return this.__has_current;\n            },\n\n            /**\n             * @override\n             */\n            next: function() {\n                this.__touch();\n                this.__has_current = false;\n                return this.__current;\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Iterators.SortedOrIterator\", [\"module:Iterators.LazyIterator\", \"module:Structures.TreeMap\", \"module:Objs\"], function(Iterator, TreeMap, Objs, scoped) {\n    return Iterator.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Iterator Class, iterating over an array of source iterator and returning each element by sorting lazily over all source iterators.\n         * \n         * @class BetaJS.Iterators.SortedOrIterator\n         */\n        return {\n\n            /**\n             * Create an instance.\n             * \n             * @param {array} iterators Array of source iterators\n             * @param {function} compare Function comparing two elements of the source iterator\n             */\n            constructor: function(iterators, compare) {\n                this.__iterators = iterators;\n                this.__map = TreeMap.empty(compare);\n                inherited.constructor.call(this);\n            },\n\n            __process: function(iter) {\n                if (iter.hasNext()) {\n                    var n = iter.next();\n                    var value = TreeMap.find(n, this.__map);\n                    if (value)\n                        value.push(iter);\n                    else\n                        this.__map = TreeMap.add(n, [iter], this.__map);\n                }\n            },\n\n            /**\n             * @override\n             */\n            _initialize: function() {\n                Objs.iter(this.__iterators, this.__process, this);\n                if (TreeMap.is_empty(this.__map))\n                    this._finished();\n            },\n\n            /**\n             * @override\n             */\n            _next: function() {\n                var ret = TreeMap.take_min(this.__map);\n                this._current(ret[0].key);\n                this.__map = ret[1];\n                Objs.iter(ret[0].value, this.__process, this);\n                if (TreeMap.is_empty(this.__map))\n                    this._finished();\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Iterators.PartiallySortedIterator\", [\"module:Iterators.Iterator\"], function(Iterator, scoped) {\n    return Iterator.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * A delegated iterator class, by sorting its elements in a partially sorted iterator.\n         * \n         * @class BetaJS.Iterators.PartiallySortedIterator\n         */\n        return {\n\n            /**\n             * Creates an instance.\n             * \n             * @param {object} iterator Source iterator\n             * @param {function} compare Function comparing two elements of the source iterator\n             * @param {function} partial_same Function determining whether two objects are partially the same\n             */\n            constructor: function(iterator, compare, partial_same) {\n                inherited.constructor.call(this);\n                this.__compare = compare;\n                this.__partial_same = partial_same;\n                this.__iterator = iterator;\n                this.__head = [];\n                this.__tail = [];\n            },\n\n            __cache: function() {\n                if (this.__head.length > 0)\n                    return;\n                this.__head = this.__tail;\n                this.__tail = [];\n                if (!this.__iterator.hasNext())\n                    return;\n                if (this.__head.length === 0)\n                    this.__head.push(this.__iterator.next());\n                while (this.__iterator.hasNext()) {\n                    var n = this.__iterator.next();\n                    if (!this.__partial_same(this.__head[0], n)) {\n                        this.__tail.push(n);\n                        break;\n                    }\n                    this.__head.push(n);\n                }\n                this.__head.sort(this.__compare);\n            },\n\n            /**\n             * @override\n             */\n            hasNext: function() {\n                this.__cache();\n                return this.__head.length > 0;\n            },\n\n            /**\n             * @override\n             */\n            next: function() {\n                this.__cache();\n                return this.__head.shift();\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Iterators.ConcatIterator\", [\"module:Iterators.Iterator\"], function(Iterator, scoped) {\n    return Iterator.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * ConcatIterator Class\n         *\n         * @class BetaJS.Iterators.ConcatIterator\n         */\n        return {\n\n            /**\n             * Creates an Iterator of an iterator of iterators\n             *\n             * @param {object} iterators iterators\n             */\n            constructor: function(iterators) {\n                inherited.constructor.call(this);\n                this.__iterators = iterators;\n                this.__current = null;\n            },\n\n            __ensure: function() {\n                while ((!this.__current || !this.__current.hasNext()) && this.__iterators.hasNext())\n                    this.__current = this.__iterators.next();\n                return this.__current;\n            },\n\n            /**\n             * @override\n             */\n            hasNext: function() {\n                var iterator = this.__ensure();\n                return iterator && iterator.hasNext();\n            },\n\n            /**\n             * @override\n             */\n            next: function() {\n                return this.__ensure().next();\n            }\n\n        };\n\n    });\n});\nScoped.extend(\"module:Iterators\", [\r\n    \"module:Types\",\r\n    \"module:Iterators.Iterator\",\r\n    \"module:Iterators.ArrayIterator\"\r\n], function(Types, Iterator, ArrayIterator) {\r\n    return {\r\n\r\n        /**\r\n         * Ensure that something is an iterator and if it is not and iterator is created from the data.\r\n         * \r\n         * @param mixed mixed type variable\r\n         * \r\n         * @return {object} iterator\r\n         */\r\n        ensure: function(mixed) {\r\n            if (mixed === null)\r\n                return new ArrayIterator([]);\r\n            if (mixed.instance_of(Iterator))\r\n                return mixed;\r\n            if (Types.is_array(mixed))\r\n                return new ArrayIterator(mixed);\r\n            return new ArrayIterator([mixed]);\r\n        }\r\n\r\n    };\r\n});\r\n\r\n\r\nScoped.define(\"module:Iterators.Iterator\", [\r\n    \"module:Class\",\r\n    \"module:Functions\",\r\n    \"module:Async\",\r\n    \"module:Promise\"\r\n], function(Class, Functions, Async, Promise, scoped) {\r\n    return Class.extend({\r\n        scoped: scoped\r\n    }, function(inherited) {\r\n\r\n        /**\r\n         * Abstract Iterator Class\r\n         * \r\n         * @class BetaJS.Iterators.Iterator\r\n         */\r\n        return {\r\n\r\n            /**\r\n             * Determines whether there are more elements in the iterator.\r\n             * Should be overwritten by subclass.\r\n             *\r\n             * @return {boolean} true if more elements present\r\n             */\r\n            hasNext: function() {\r\n                return false;\r\n            },\r\n\r\n            /**\r\n             * Returns the next element in the iterator.\r\n             * Should be overwritten by subclass.\r\n             * \r\n             * @return next element in iterator\r\n             */\r\n            next: function() {\r\n                return null;\r\n            },\r\n\r\n            /**\r\n             * Returns the next element if present or null otherwise.\r\n             * \r\n             * @return next element in iterator or null\r\n             */\r\n            nextOrNull: function() {\r\n                return this.hasNext() ? this.next() : null;\r\n            },\r\n\r\n            /**\r\n             * Materializes the iterator as an array.\r\n             *\r\n             * @param {boolean} keep do not destroy iterator\r\n             * @return {array} array of elements in iterator\r\n             */\r\n            asArray: function(keep) {\r\n                var arr = [];\r\n                while (this.hasNext())\r\n                    arr.push(this.next());\r\n                if (!keep)\r\n                    this.weakDestroy();\r\n                return arr;\r\n            },\r\n\r\n            /**\r\n             * Iterate over the iterator, calling a callback function for every element.\r\n             * \r\n             * @param {function} cb callback function\r\n             * @param {object} ctx optional callback context\r\n             * @param {boolean} keep do not destroy iterator\r\n             */\r\n            iterate: function(cb, ctx, keep) {\r\n                while (this.hasNext()) {\r\n                    var result = cb.call(ctx || this, this.next());\r\n                    if (result === false)\r\n                        break;\r\n                }\r\n                if (!keep)\r\n                    this.weakDestroy();\r\n            },\r\n\r\n            /**\r\n             * Asynchronously iterate over the iterator, calling a callback function for every element.\r\n             * \r\n             * @param {function} cb callback function\r\n             * @param {object} ctx optional callback context\r\n             * @param {int} time optional time between calls\r\n             * \r\n             * @return {object} finish promise\r\n             */\r\n            asyncIterate: function(cb, ctx, time) {\r\n                if (!this.hasNext()) {\r\n                    this.destroy();\r\n                    return Promise.value(true);\r\n                }\r\n                var result = cb.call(ctx || this, this.next());\r\n                if (result === false)\r\n                    return Promise.value(true);\r\n                var promise = Promise.create();\r\n                Async.eventually(function() {\r\n                    this.asyncIterate(cb, ctx, time).forwardCallback(promise);\r\n                }, this, time);\r\n                return promise;\r\n            }\r\n\r\n        };\r\n    });\r\n});\nScoped.define(\"module:Loggers.CallOriginLogAugment\", [\n    \"module:Loggers.AbstractLogAugment\",\n    \"module:Functions\"\n], function(AbstractLogAugment, Functions, scoped) {\n    return AbstractLogAugment.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Call Origin Log Augment Class\n         * \n         * @class BetaJS.Loggers.CallOriginLogAugment\n         */\n        return {\n\n            /**\n             * @override\n             */\n            augmentMessage: function(source, msg, depth) {\n                var stack = Functions.getStackTrace(depth * 3 + 6);\n                return stack[0].trim();\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Loggers.ConsoleLogListener\", [\n    \"module:Loggers.LogListener\"\n], function(LogListener, scoped) {\n    return LogListener.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Console Log Listener Class\n         * \n         * @class BetaJS.Loggers.ConsoleLogListener\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             *\n             * @param {object} options options argument\n             */\n            constructor: function(options) {\n                inherited.constructor.call(this);\n                this._options = options || {};\n            },\n\n            /**\n             * @override\n             */\n            message: function(source, msg) {\n                var args = msg.args.concat(msg.augments);\n                if (this._options.single)\n                    args = [args.join(\" | \")];\n                console[msg.type].apply(console, args);\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Loggers.AbstractLogAugment\", [\n    \"module:Class\"\n], function(Class, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Abstract Log Augment Class, augmenting logs\n         * \n         * @class BetaJS.Loggers.AbstractLogAugment\n         */\n        return {\n\n            /**\n             * Called when a log message is created.\n             * \n             * @param {object} source logger source\n             * @param {object} msg message object\n             * @param {int} depth call depth (internal use)\n             * @return augmentation\n             */\n            augmentMessage: function(source, msg, depth) {}\n\n        };\n    });\n});\nScoped.define(\"module:Loggers.LogListenerFilter\", [\n    \"module:Loggers.LogListener\",\n    \"module:Objs\",\n    \"module:Types\"\n], function(LogListener, Objs, Types, scoped) {\n    return LogListener.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Log Listener Filter Class\n         * \n         * @class BetaJS.Loggers.LogListenerFilter\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {object} target target log listener that should be filtered for\n             * @param {array} tags tags that should be filtered by\n             */\n            constructor: function(target, tags) {\n                inherited.constructor.call(this);\n                this.__target = target;\n                this.__tags = tags;\n            },\n\n            /**\n             * @override\n             */\n            message: function(source, msg) {\n                var tags = Objs.objectify(msg.tags);\n                var result = false;\n                if (Types.is_array(this.__tags[0])) {\n                    result = this.__tags.some(function(sub) {\n                        return sub.every(function(tag) {\n                            return tags[tag];\n                        });\n                    });\n                } else {\n                    result = this.__tags.every(function(tag) {\n                        return tags[tag];\n                    });\n                }\n                if (result)\n                    this.__target.message(source, msg);\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Loggers.LogListener\", [\n    \"module:Class\"\n], function(Class, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Abstract Log Listener Class, reacting to logging calls\n         * \n         * @class BetaJS.Loggers.LogListener\n         */\n        return {\n\n            /**\n             * Called when a log message is created.\n             * \n             * @param {object} source logger source\n             * @param {object} msg message object\n             */\n            message: function(source, msg) {}\n\n        };\n    });\n});\nScoped.define(\"module:Loggers.LoggableMixin\", [\n    \"module:Loggers.Logger\",\n    \"module:Objs\",\n    \"module:Functions\"\n], function(Logger) {\n\n    /**\n     * LoggableMixin Mixin\n     *\n     * @mixin BetaJS.Loggers.LoggableMixin\n     */\n    return {\n\n        /**\n         * Returns the base logger.\n         *\n         * @returns {object} base logger\n         */\n        baseLogger: function() {\n            if (!this._baseLogger)\n                this._baseLogger = Logger.global();\n            return this._baseLogger;\n        },\n\n        /**\n         * Returns the logger.\n         *\n         * @returns {object} logger\n         */\n        logger: function() {\n            if (!this._logger)\n                this._logger = this.baseLogger().tag(this.cls.classname, this.cid());\n            return this._logger;\n        }\n\n    };\n});\nScoped.define(\"module:Loggers.Logger\", [\n    \"module:Class\",\n    \"module:Objs\",\n    \"module:Functions\"\n], function(Class, Objs, Functions, scoped) {\n    var Cls = Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Logger Class\n         * \n         * @class BetaJS.Loggers.Logger\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {object} options options for the logger\n             */\n            constructor: function(options) {\n                inherited.constructor.call(this);\n                options = options || {};\n                this.__listeners = {};\n                this.__augments = {};\n                this.__tags = options.tags || [];\n                Objs.iter(options.listeners, this.addListener, this);\n            },\n\n            /**\n             * Adds a new augment to the logger.\n             * \n             * @param {object} augment augment to be added\n             * @param {string} prefix optional prefix\n             */\n            addAugment: function(augment, prefix) {\n                this.__augments[augment.cid()] = {\n                    augment: augment,\n                    prefix: prefix\n                };\n                return this;\n            },\n\n            /**\n             * Remove an existing augment from the logger.\n             * \n             * @param {object} augment augment to be removed\n             */\n            removeAugment: function(augment) {\n                delete this.__augments[augment.cid()];\n                return this;\n            },\n\n            /**\n             * Adds a new listener to the logger.\n             * \n             * @param {object} listener listener to be added\n             */\n            addListener: function(listener) {\n                this.__listeners[listener.cid()] = listener;\n                return this;\n            },\n\n            /**\n             * Remove an existing listener from the logger.\n             * \n             * @param {object} listener listener to be removed\n             */\n            removeListener: function(listener) {\n                delete this.__listeners[listener.cid()];\n                return this;\n            },\n\n            /**\n             * Create a new log message.\n             */\n            log: function() {\n                return this.message(this, {\n                    type: \"log\",\n                    args: Functions.getArguments(arguments, 0)\n                });\n            },\n\n            /**\n             * Creates a log function calling the logger.\n             */\n            logf: function() {\n                return Functions.as_method(this.log, this);\n            },\n\n            /**\n             * Create a new warn message.\n             */\n            warn: function() {\n                return this.message(this, {\n                    type: \"warn\",\n                    args: Functions.getArguments(arguments, 0)\n                });\n            },\n\n            /**\n             * Create a new error message.\n             */\n            error: function() {\n                return this.message(this, {\n                    type: \"error\",\n                    args: Functions.getArguments(arguments, 0)\n                });\n            },\n\n            /**\n             * Create a new tagged log message.\n             * \n             * @param {array} tags tags for the message\n             */\n            taggedlog: function(tags) {\n                return this.message(this, {\n                    type: \"log\",\n                    tags: tags,\n                    args: Functions.getArguments(arguments, 1)\n                });\n            },\n\n            /**\n             * Create a new tagged warn message.\n             * \n             * @param {array} tags tags for the message\n             */\n            taggedwarn: function(tags) {\n                return this.message(this, {\n                    type: \"warn\",\n                    tags: tags,\n                    args: Functions.getArguments(arguments, 1)\n                });\n            },\n\n            /**\n             * Create a new tagged error message.\n             * \n             * @param {array} tags tags for the message\n             */\n            taggederror: function(tags) {\n                return this.message(this, {\n                    type: \"error\",\n                    tags: tags,\n                    args: Functions.getArguments(arguments, 1)\n                });\n            },\n\n            /**\n             * Create a new log message.\n             * \n             * @param {object} source logger source for message\n             * @param {object} msg log message\n             * @param {int} depth call depth (internal use)\n             */\n            message: function(source, msg, depth) {\n                depth = depth || 0;\n                msg.tags = this.__tags.concat(msg.tags || []);\n                msg.augments = msg.augments || [];\n                Objs.iter(this.__augments, function(augment) {\n                    msg.augments.push((augment.prefix ? augment.prefix + \":\" : \"\") + augment.augment.augmentMessage(source, msg, depth));\n                }, this);\n                Objs.iter(this.__listeners, function(listener) {\n                    listener.message(this, msg, depth + 1);\n                }, this);\n                return this;\n            },\n\n            /**\n             * Create a new sub logger by tags.\n             *\n             * @return {object} sub logger\n             */\n            tag: function() {\n                return new Cls({\n                    tags: Functions.getArguments(arguments),\n                    listeners: [this]\n                });\n            }\n\n        };\n    }, {\n\n        /**\n         * Return global singleton logger instance.\n         * \n         * @return {object} singleton logger\n         */\n        global: function() {\n            if (!this.__global)\n                this.__global = new Cls();\n            return this.__global;\n        }\n\n    });\n\n    return Cls;\n});\nScoped.define(\"module:Loggers.StaticLogAugment\", [\n    \"module:Loggers.AbstractLogAugment\"\n], function(AbstractLogAugment, scoped) {\n    return AbstractLogAugment.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Static Log Augment Class\n         * \n         * @class BetaJS.Loggers.StaticLogAugment\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             *\n             * @param value value\n             */\n            constructor: function(value) {\n                inherited.constructor.call(this);\n                this.__value = value;\n            },\n\n            /**\n             * Returns current value.\n             *\n             * @return value\n             */\n            getValue: function() {\n                return this.__value;\n            },\n\n            /**\n             * Set current value.\n             *\n             * @param value current value\n             */\n            setValue: function(value) {\n                this.__value = value;\n                return this;\n            },\n\n            /**\n             * @override\n             */\n            augmentMessage: function(source, msg, depth) {\n                return this.__value;\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Loggers.TagLogAugment\", [\n    \"module:Loggers.AbstractLogAugment\"\n], function(AbstractLogAugment, scoped) {\n    return AbstractLogAugment.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Tag Log Augment Class\n         * \n         * @class BetaJS.Loggers.TagLogAugment\n         */\n        return {\n\n            /**\n             * @override\n             */\n            augmentMessage: function(source, msg, depth) {\n                return msg.tags.join(\",\");\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Loggers.TimeLogAugment\", [\n    \"module:Loggers.AbstractLogAugment\",\n    \"module:Time\",\n    \"module:TimeFormat\"\n], function(AbstractLogAugment, Time, TimeFormat, scoped) {\n    return AbstractLogAugment.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Time Log Augment Class\n         * \n         * @class BetaJS.Loggers.TimeLogAugment\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             *\n             * @param {object} options options argument\n             */\n            constructor: function(options) {\n                inherited.constructor.call(this);\n                this._options = options || {};\n                this.__last = Time.now();\n            },\n\n            /**\n             * @override\n             */\n            augmentMessage: function(source, msg, depth) {\n                var now = Time.now();\n                var delta = now - this.__last;\n                this.__last = now;\n                return (this._options.time_format ? TimeFormat.format(this._options.time_format, now) : now) + (this._options.delta ? \" (+\" + delta + \"ms)\" : \"\");\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Net.SocketSenderChannel\", [\n    \"module:Channels.Sender\"\n], function(Sender, scoped) {\n    return Sender.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Socket Sender Channel Class\n         * \n         * @class BetaJS.Net.SocketSenderChannel\n         */\n        return {\n\n            /**\n             * Instantiates Socket Sender Channel\n             * \n             * @param {object} socket initial socket\n             * @param {string} message message string to be used on the socket\n             */\n            constructor: function(socket, message) {\n                inherited.constructor.call(this);\n                this.__socket = socket;\n                this.__message = message;\n            },\n\n            _send: function(message, data) {\n                this.__socket.emit(this.__message, {\n                    message: message,\n                    data: data\n                });\n            },\n\n            /**\n             * Returns current socket or sets currents socket.\n             * \n             * @param {object} socket new socket (optional)\n             * \n             * @return {object} current socket\n             */\n            socket: function() {\n                if (arguments.length > 0)\n                    this.__socket = arguments[0];\n                return this.__socket;\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Net.SocketReceiverChannel\", [\"module:Channels.Receiver\"], function(Receiver, scoped) {\n    return Receiver.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Socket Receiver Channel Class\n         * \n         * @class BetaJS.Net.SocketReceiverChannel\n         */\n        return {\n\n            /**\n             * Instantiates Socket Receiver Channel\n             * \n             * @param {object} socket initial socket\n             * @param {string} message message string to be used on the socket\n             */\n            constructor: function(socket, message) {\n                inherited.constructor.call(this);\n                this.__message = message;\n                this.socket(socket);\n            },\n\n            /**\n             * Returns current socket or sets currents socket.\n             * \n             * @param {object} socket new socket (optional)\n             * \n             * @return {object} current socket\n             */\n            socket: function() {\n                if (arguments.length > 0) {\n                    this.__socket = arguments[0];\n                    if (this.__socket) {\n                        var self = this;\n                        this.__socket.on(this.__message, function(data) {\n                            self._receive(data.message, data.data);\n                        });\n                    }\n                }\n                return this.__socket;\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Net.Cookies\", [\"module:Objs\", \"module:Types\"], function(Objs, Types) {\n    return {\n\n        getCookielikeValue: function(cookies, key) {\n            cookies = cookies || \"\";\n            return decodeURIComponent(cookies.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null;\n        },\n\n        /**\n         *\n         * @param {string} key\n         * @param {string} value\n         * @param {Date} end\n         * @param {string} path\n         * @param {string} domain\n         * @param {boolean} secure\n         * @param {string} sameSite\n         * @return {null|*}\n         */\n        createCookielikeValue: function(key, value, end, path, domain, secure, sameSite) {\n            if (!key || /^(?:expires|max\\-age|path|domain|secure)$/i.test(key))\n                return null;\n            var components = [];\n            components.push([encodeURIComponent(key), encodeURIComponent(value)]);\n            if (end) {\n                if (end === Infinity)\n                    components.push([\"expires\", \"Fri, 31 Dec 9999 23:59:59 GMT\"]);\n                else if (typeof end === \"number\")\n                    components.push([\"max-age\", end]);\n                else if (typeof end === \"object\")\n                    components.push([\"expires\", end.toUTCString()]);\n                else\n                    components.push([\"expires\", end]);\n            }\n            if (domain)\n                components.push([\"domain\", domain]);\n            if (path)\n                components.push([\"path\", path]);\n            if (secure)\n                components.push(\"secure\");\n            // Any cookie that requests SameSite=None but is not marked Secure will be rejected.\n            sameSite = sameSite || 'None';\n            components.push(\"SameSite\", sameSite);\n            return Objs.map(components, function(component) {\n                return Types.is_array(component) ? component.join(\"=\") : component;\n            }).join(\"; \");\n        },\n\n        removeCookielikeValue: function(key, value, path, domain) {\n            return this.createCookielikeValue(key, value, new Date(0), path, domain);\n        },\n\n        hasCookielikeValue: function(cookies, key) {\n            return (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(cookies);\n        },\n\n        keysCookielike: function(cookies) {\n            var base = cookies.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n            return Objs.map(base, decodeURIComponent);\n        }\n\n    };\n});\nScoped.define(\"module:Net.HttpHeader\", function() {\n    /**\n     * Http Header Codes and Functions\n     * \n     * @module BetaJS.Net.HttpHeader\n     */\n    return {\n\n        HTTP_STATUS_OK: 200,\n        HTTP_STATUS_CREATED: 201,\n        HTTP_STATUS_BAD_REQUEST: 400,\n        HTTP_STATUS_UNAUTHORIZED: 401,\n        HTTP_STATUS_PAYMENT_REQUIRED: 402,\n        HTTP_STATUS_FORBIDDEN: 403,\n        HTTP_STATUS_NOT_FOUND: 404,\n        HTTP_STATUS_PRECONDITION_FAILED: 412,\n        HTTP_STATUS_INTERNAL_SERVER_ERROR: 500,\n        HTTP_STATUS_GATEWAY_TIMEOUT: 504,\n\n        STRINGS: {\n            0: \"Unknown Error\",\n            200: \"OK\",\n            201: \"Created\",\n            400: \"Bad Request\",\n            401: \"Unauthorized\",\n            402: \"Payment Required\",\n            403: \"Forbidden\",\n            404: \"Not found\",\n            412: \"Precondition Failed\",\n            500: \"Internal Server Error\",\n            504: \"Gateway timeout\"\n        },\n\n\n        /**\n         * Formats a HTTP status code to a string.\n         * \n         * @param {integer} code the http status code\n         * @param {boolean} prepend_code should the integer status code be prepended (default false)\n         * \n         * @return HTTP status code as a string.\n         */\n        format: function(code, prepend_code) {\n            var ret = this.STRINGS[code in this.STRINGS ? code : 0];\n            return prepend_code ? (code + \" \" + ret) : ret;\n        },\n\n        /**\n         * Returns true if a status code is in the 200 region.\n         * \n         * @param {int} code status code\n         * \n         * @return {boolean} true if code in the 200 region\n         */\n        isSuccessStatus: function(code) {\n            return code >= this.HTTP_STATUS_OK && code < 300;\n        }\n\n    };\n});\nScoped.define(\"module:Net.Uri\", [\n    \"module:Objs\",\n    \"module:Types\",\n    \"module:Strings\",\n    \"module:Sort\"\n], function(Objs, Types, Strings, Sort) {\n\n    var parse_strict_regex = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n    var parse_loose_regex = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n    var parse_key = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\n    var parse_key_parser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n\n    /**\n     * Uri Auxilary Functions\n     * \n     * @module BetaJS.Net.Uri\n     */\n    return {\n\n        /**\n         * Create a URI string from a set of parameters.\n         * \n         * @param {object} obj parameters\n         * \n         * @return {string} uri\n         */\n        build: function(obj) {\n            var s = \"\";\n            if (obj.protocol)\n                s += obj.protocol + \"://\";\n            if (obj.username)\n                s += obj.username + \":\";\n            if (obj.password)\n                s += obj.password + \"@\";\n            s += obj.server;\n            if (obj.port)\n                s += \":\" + obj.port;\n            if (obj.path)\n                s += \"/\" + obj.path;\n            return s;\n        },\n\n\n        /**\n         * Encode a set of uri query parameters.\n         * \n         * @param {object} arr a key-value set of query parameters\n         * @param {string} prefix an optional prefix to be used for generating the keys\n         * @param {boolean} flatten flatten the components first\n         * \n         * @return {string} encoded query parameters\n         */\n        encodeUriParams: function(arr, prefix, flatten) {\n            prefix = prefix || \"\";\n            var res = [];\n            if (flatten) {\n                Objs.iter(Objs.serializeFlatJSON(arr), function(kv) {\n                    res.push(prefix + kv.key + \"=\" + encodeURIComponent(kv.value));\n                }, this);\n            } else {\n                Objs.iter(arr, function(value, key) {\n                    if (Types.is_object(value))\n                        res = res.concat(this.encodeUriParams(value, prefix + key + \"_\"));\n                    else\n                        res.push(prefix + key + \"=\" + encodeURIComponent(value));\n                }, this);\n            }\n            return res.join(\"&\");\n        },\n\n\n        /**\n         * Decode a uri query parameter string\n         * \n         * @param {string} res encoded query parameters\n         * \n         * @return {object} key-value set of query parameters\n         */\n        decodeUriParams: function(res) {\n            var arr = {};\n            res.split(\"&\").forEach(function(kv) {\n                var kvsplit = Strings.splitFirst(kv, \"=\");\n                arr[kvsplit.head] = decodeURIComponent(kvsplit.tail);\n            });\n            return arr;\n        },\n\n\n        /**\n         * Append a set of uri query parameters to a URI.\n         * \n         * @param {string} uri a uri\n         * @param {object} arr a key-value set of query parameters\n         * @param {string} prefix an optional prefix to be used for generating the keys\n         * \n         * @return {string} uri with the encoded query parameters attached\n         */\n        appendUriParams: function(uri, arr, prefix) {\n            return Types.is_empty(arr) ? uri : (uri + (uri.indexOf(\"?\") != -1 ? \"&\" : \"?\") + this.encodeUriParams(arr, prefix));\n        },\n\n        upsertUriParams: function(uri, strongOverwrite, weakOverwrite) {\n            return this.mapUriQuery(uri, function(params) {\n                return Objs.weak_extend(Objs.extend(params, strongOverwrite), weakOverwrite);\n            });\n        },\n\n        /**\n         * Parses a given uri into decomposes it into its components.\n         * \n         * @thanks parseUri 1.2.2, (c) Steven Levithan <stevenlevithan.com>, MIT License\n         * \n         * @param {string} str uri to be parsed\n         * @param {boolean} strict use strict parsing (default false)\n         * \n         * @return {object} decomposed uri\n         */\n        parse: function(str, strict) {\n            var parser = strict ? parse_strict_regex : parse_loose_regex;\n            var m = parser.exec(str);\n            var uri = {};\n            for (var i = 0; i < parse_key.length; ++i)\n                uri[parse_key[i]] = m[i] || \"\";\n            uri.queryKey = {};\n            uri[parse_key[12]].replace(parse_key_parser, function($0, $1, $2) {\n                if ($1) uri.queryKey[$1] = $2;\n            });\n            return uri;\n        },\n\n        /**\n         * Determines whether a target URI is considered cross-domain with respect to a source URI.\n         * \n         * @param {string} source source URI\n         * @param {string} target target URI\n         * \n         * @return {boolean} true if target is cross-domain w.r.t. source\n         */\n        isCrossDomainUri: function(source, target) {\n            // If target has no protocol delimiter, there is no domain given, hence source domain is used\n            if (target.indexOf(\"//\") < 0)\n                return false;\n            // If source has no protocol delimiter but target has, it is cross-domain.\n            if (source.indexOf(\"//\") < 0)\n                return true;\n            source = this.parse(source.toLowerCase());\n            target = this.parse(target.toLowerCase());\n            // Terminate if one of protocols is the file protocol.\n            if (source.protocol === \"file\" || target.protocol === \"file\")\n                return source.protocol === target.protocol;\n            return source.host !== target.host || source.port !== target.port;\n        },\n\n        mapUriQuery: function(uri, f, ctx) {\n            var q = uri.indexOf(\"?\");\n            var params = f.call(ctx || this, q >= 0 ? this.decodeUriParams(uri.substring(q + 1)) : {});\n            return (q >= 0 ? uri.substring(0, q) : uri) + (!Types.is_empty(params) ? (\"?\" + this.encodeUriParams(params)) : \"\");\n        },\n\n        /**\n         * Normalizes the query of a uri by sorting keys alphabetically.\n         *\n         * @param {string} uri source URI\n         *\n         * @return {string} normalized uri\n         */\n        normalizeUri: function(uri) {\n            return this.mapUriQuery(uri, function(params) {\n                return Sort.sort_object(params, function(x, y) {\n                    return x.localeCompare(y);\n                });\n            });\n        }\n\n    };\n});\nScoped.define(\"module:RMI.Client\", [\n    \"module:Class\",\n    \"module:Objs\",\n    \"module:Channels.TransportChannel\",\n    \"module:Ids\",\n    \"module:RMI.Skeleton\",\n    \"module:Types\",\n    \"module:RMI.Stub\"\n], function(Class, Objs, TransportChannel, Ids, Skeleton, Types, Stub, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * RMI Client Class\n         * \n         * @class BetaJS.RMI.Client\n         */\n        return {\n\n            /**\n             * Creates a new instance of an RMI client.\n             * \n             * @param {object} sender_or_channel_or_null a channel or sender that should be connected to\n             * @param {object} receiver_or_null a receiver that should be connected to\n             */\n            constructor: function(sender_or_channel_or_null, receiver_or_null) {\n                inherited.constructor.call(this);\n                this.__channel = null;\n                this.__instances = {};\n                if (sender_or_channel_or_null) {\n                    var channel = sender_or_channel_or_null;\n                    if (receiver_or_null)\n                        channel = this._auto_destroy(new TransportChannel(sender_or_channel_or_null, receiver_or_null));\n                    this.__channel = channel;\n                }\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                if (this.__channel)\n                    this.disconnect();\n                inherited.destroy.call(this);\n            },\n\n            /**\n             * Connect to a channel.\n             * \n             * @param {object} channel channel to be connected to\n             */\n            connect: function(channel) {\n                if (this.__channel)\n                    return;\n                this.__channel = channel;\n                return this;\n            },\n\n            /**\n             * Connect to a channel using sender and receiver.\n             * \n             * @param {object} sender sender channel to be connected to\n             * @param {object} receiver receiver channel to be connected to\n             * @param {object} options options for transport channel\n             */\n            connectTransport: function(sender, receiver, options) {\n                return this.connect(this.auto_destroy(new TransportChannel(sender, receiver, options)));\n            },\n\n            /**\n             * Disconnect from channel.\n             * \n             */\n            disconnect: function() {\n                if (!this.__channel)\n                    return;\n                this.__channel = null;\n                Objs.iter(this.__instances, function(inst) {\n                    this.release(inst);\n                }, this);\n                return this;\n            },\n\n            /**\n             * Serialize a value.\n             * \n             * @param value value to be serialized.\n             * \n             * @return Serialized value\n             */\n            _serializeValue: function(value) {\n                if (Skeleton.is_instance_of(value)) {\n                    var registry = this.server;\n                    registry.registerInstance(value);\n                    return {\n                        __rmi_meta: true,\n                        __rmi_stub: value.stub(),\n                        __rmi_stub_id: Ids.objectId(value)\n                    };\n                } else\n                    return value;\n            },\n\n            /**\n             * Unserialize a value.\n             * \n             * @param value value to be unserialized.\n             * \n             * @return unserialized value\n             */\n            _unserializeValue: function(value) {\n                if (value && value.__rmi_meta) {\n                    var receiver = this;\n                    return receiver.acquire(value.__rmi_stub, value.__rmi_stub_id);\n                } else\n                    return value;\n            },\n\n            /**\n             * Acquires an object instance.\n             * \n             * @param {string} class_type class type of object instance\n             * @param {string} instance_name registered name of instance\n             * \n             * @return {object} object instance\n             */\n            acquire: function(class_type, instance_name) {\n                if (this.__instances[instance_name])\n                    return this.__instances[instance_name];\n                if (Types.is_string(class_type))\n                    class_type = Scoped.getGlobal(class_type);\n                if (!class_type || !class_type.ancestor_of(Stub))\n                    return null;\n                var instance = new class_type();\n                this.__instances[Ids.objectId(instance, instance_name)] = instance;\n                var self = this;\n                instance.__send = function(message, data, serializes) {\n                    if (!self.__channel)\n                        return;\n                    data = Objs.map(data, self._serializeValue, self);\n                    return self.__channel.send(instance_name + \":\" + message, data, {\n                        serializerInfo: serializes\n                    }).mapSuccess(function(result) {\n                        return this._unserializeValue(result);\n                    }, self);\n                };\n                return instance;\n            },\n\n            /**\n             * Releases an acquired instance.\n             * \n             * @param {object} instance instance to be released\n             * \n             */\n            release: function(instance) {\n                var instance_name = Ids.objectId(instance);\n                if (this.__instances[instance_name]) {\n                    instance.weakDestroy();\n                    delete this.__instances[instance_name];\n                }\n                return this;\n            }\n\n        };\n    });\n});\nScoped.define(\"module:RMI.Peer\", [\n    \"module:Class\",\n    \"module:Channels.SenderMultiplexer\",\n    \"module:Channels.ReceiverMultiplexer\",\n    \"module:RMI.Client\",\n    \"module:RMI.Server\"\n], function(Class, SenderMultiplexer, ReceiverMultiplexer, Client, Server, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * RMI Peer Class, combining Sender and Receiver into bidirectional Client and Server\n         * \n         * @class BetaJS.RMI.Peer\n         */\n        return {\n\n            /**\n             * Instantiates Peer Class\n             * \n             * @param {object} sender Sender Channel\n             * @param {object} receiver Receiver Channel\n             */\n            constructor: function(sender, receiver) {\n                inherited.constructor.call(this);\n                this.__sender = sender;\n                this.__receiver = receiver;\n                this.__client_sender = this._auto_destroy(new SenderMultiplexer(sender, \"client\"));\n                this.__server_sender = this._auto_destroy(new SenderMultiplexer(sender, \"server\"));\n                this.__client_receiver = this._auto_destroy(new ReceiverMultiplexer(receiver, \"server\"));\n                this.__server_receiver = this._auto_destroy(new ReceiverMultiplexer(receiver, \"client\"));\n                this.client = this._auto_destroy(new Client(this.__client_sender, this.__client_receiver));\n                this.server = this._auto_destroy(new Server(this.__server_sender, this.__server_receiver));\n                this.client.server = this.server;\n                this.server.client = this.client;\n            },\n\n            /**\n             * Acquires an instance.\n             * \n             * @param {string} class_type Type of Class\n             * @param {string} instance_name Name of Instance\n             * \n             * @return {object} acquired instance\n             */\n            acquire: function(class_type, instance_name) {\n                return this.client.acquire(class_type, instance_name);\n            },\n\n            /**\n             * Releases an instance.\n             * \n             * @param {object} instance Previously acquired instance\n             */\n            release: function(instance) {\n                this.client.release(instance);\n            },\n\n            /**\n             * Register an instance.\n             * \n             * @param {object} instance Object instance\n             * @param {object} options Registration options\n             * \n             * @return {object} Registered instance\n             */\n            registerInstance: function(instance, options) {\n                return this.server.registerInstance(instance, options);\n            },\n\n            /**\n             * Unregister an instance.\n             * \n             * @param {object} instance Previously registered instance\n             */\n            unregisterInstance: function(instance) {\n                this.server.unregisterInstance(instance);\n            }\n\n        };\n    });\n});\nScoped.define(\"module:RMI.Server\", [\n    \"module:Class\",\n    \"module:Events.EventsMixin\",\n    \"module:Objs\",\n    \"module:Channels.TransportChannel\",\n    \"module:Lists.ObjectIdList\",\n    \"module:Ids\",\n    \"module:RMI.Skeleton\",\n    \"module:Promise\"\n], function(Class, EventsMixin, Objs, TransportChannel, ObjectIdList, Ids, Skeleton, Promise, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [EventsMixin, function(inherited) {\n\n        /**\n         * @class BetaJS.RMI.Server\n         */\n        return {\n\n            /**\n             * Creates an RMI Server instance\n             * \n             * @param {object} sender_or_channel_or_null a channel or sender that should be connected to\n             * @param {object} receiver_or_null a receiver that should be connected to\n             */\n            constructor: function(sender_or_channel_or_null, receiver_or_null) {\n                inherited.constructor.call(this);\n                this.__channels = new ObjectIdList();\n                this.__instances = {};\n                if (sender_or_channel_or_null) {\n                    var channel = sender_or_channel_or_null;\n                    if (receiver_or_null)\n                        channel = this._auto_destroy(new TransportChannel(sender_or_channel_or_null, receiver_or_null));\n                    this.registerClient(channel);\n                }\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                this.__channels.iterate(this.unregisterClient, this);\n                Objs.iter(this.__instances, function(inst) {\n                    this.unregisterInstance(inst.instance);\n                }, this);\n                this.__channels.destroy();\n                inherited.destroy.call(this);\n            },\n\n            /**\n             * Registers an RMI skeleton instance.\n             * \n             * @param {object} instance skeleton instance\n             * @param {object} options Options like name of instance\n             * \n             * @return {object} Instance\n             */\n            registerInstance: function(instance, options) {\n                options = options || {};\n                this.__instances[Ids.objectId(instance, options.name)] = {\n                    instance: instance,\n                    options: options\n                };\n                if (options.auto_destroy)\n                    this.auto_destroy(instance);\n                return instance;\n            },\n\n            /**\n             * Unregisters a RMI skeleton instance\n             * \n             * @param {object} instance skeleton instance\n             */\n            unregisterInstance: function(instance) {\n                delete this.__instances[Ids.objectId(instance)];\n                instance.weakDestroy();\n                return this;\n            },\n\n            /**\n             * Register a client channel\n             * \n             * @param {object} channel Client channel\n             * @param {object} options Options\n             */\n            registerClient: function(channel, options) {\n                options = options || {};\n                var self = this;\n                this.__channels.add(channel);\n                channel._reply = function(message, data) {\n                    var components = message.split(\":\");\n                    if (components.length == 2)\n                        return self._invoke(channel, components[0], components[1], data);\n                    else\n                        return Promise.error(true);\n                };\n                if (options.auto_destroy)\n                    this.auto_destroy(channel);\n                return this;\n            },\n\n            /**\n             * Register a client by sender and receiver channel\n             * \n             * @param {object} sender Sender channel\n             * @param {object} receiver Receiver channel\n             * @param {object} options Options\n             */\n            registerTransportClient: function(sender, receiver, options) {\n                return this.registerClient(this.auto_destroy(new TransportChannel(sender, receiver, options)));\n            },\n\n            /**\n             * Unregister a client channel\n             * \n             * @param {object} channel Client channel\n             */\n            unregisterClient: function(channel) {\n                this.__channels.remove(channel);\n                channel._reply = null;\n                return this;\n            },\n\n            /**\n             * Serialize a value.\n             * \n             * @param value value to be serialized.\n             * \n             * @return Serialized value\n             */\n            _serializeValue: function(value) {\n                if (Skeleton.is_instance_of(value)) {\n                    var registry = this;\n                    registry.registerInstance(value);\n                    return {\n                        __rmi_meta: true,\n                        __rmi_stub: value.stub(),\n                        __rmi_stub_id: Ids.objectId(value)\n                    };\n                } else\n                    return value;\n            },\n\n            /**\n             * Unserialize a value.\n             * \n             * @param value value to be unserialized.\n             * \n             * @return unserialized value\n             */\n            _unserializeValue: function(value) {\n                if (value && value.__rmi_meta) {\n                    var receiver = this.client;\n                    return receiver.acquire(value.__rmi_stub, value.__rmi_stub_id);\n                } else\n                    return value;\n            },\n\n            /**\n             * Invokes an instance method on a channel.\n             * \n             * @param {object} channel Channel to be used for invokation\n             * @param {string} instance_id Id of instance to be used as context\n             * @param {string} method Method to be called\n             * @param data Data to be passed to method\n             * \n             * @return Return value of method as promise. \n             * \n             * @fires BetaJS.RMI.Server#loadInstance\n             */\n            _invoke: function(channel, instance_id, method, data) {\n                var instance = this.__instances[instance_id];\n                if (!instance) {\n                    /**\n                     * @event BetaJS.RMI.Server#loadInstance\n                     */\n                    this.trigger(\"loadInstance\", channel, instance_id);\n                    instance = this.__instances[instance_id];\n                }\n                if (!instance)\n                    return Promise.error(instance_id);\n                instance = instance.instance;\n                data = Objs.map(data, this._unserializeValue, this);\n                return instance.invoke(method, data, channel).mapSuccess(function(result) {\n                    return this._serializeValue(result);\n                }, this);\n            }\n\n        };\n    }]);\n});\nScoped.define(\"module:RMI.Skeleton\", [\n    \"module:Class\",\n    \"module:Objs\",\n    \"module:Promise\"\n], function(Class, Objs, Promise, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Rmi Skeleton Class containing the server-side implementation.\n         * \n         * @class BetaJS.RMI.Skeleton\n         */\n        return {\n\n            /**\n             * @member {array} intf List of exported functions\n             */\n            intf: [],\n\n            _stub: null,\n            _intf: {},\n            __superIntf: [\"_destroy\"],\n\n            /**\n             * Instantiates a skeleton instance.\n             * \n             * @param {object} options Options, currently supported destroyable.\n             */\n            constructor: function(options) {\n                this._options = Objs.extend({\n                    destroyable: false\n                }, options);\n                inherited.constructor.call(this);\n                this.intf = this.intf.concat(this.__superIntf);\n                for (var i = 0; i < this.intf.length; ++i)\n                    this._intf[this.intf[i]] = true;\n            },\n\n            /**\n             * (Remotely) destroy the skeleton if supported.\n             * \n             * @protected\n             */\n            _destroy: function() {\n                if (this._options.destroyable)\n                    this.destroy();\n            },\n\n            /**\n             * Invoke an exported function.\n             * \n             * @param {string} message name of exported function\n             * @param {array} data custom data array\n             * \n             * @return {object} execution promise\n             */\n            invoke: function(message, data) {\n                if (!(this._intf[message]))\n                    return Promise.error(message);\n                try {\n                    var result = this[message].apply(this, data);\n                    return Promise.is(result) ? result : Promise.value(result);\n                } catch (e) {\n                    return Promise.error(e);\n                }\n            },\n\n            /**\n             * Returns a success promise for an exported call.\n             * \n             * @param result Success value\n             * \n             * @return {object} success promise\n             * \n             * @protected\n             */\n            _success: function(result) {\n                return Promise.value(result);\n            },\n\n            /**\n             * Returns an error promise for an exported call.\n             * \n             * @param result Error value\n             * \n             * @return {object} error promise\n             * \n             * @protected\n             */\n            _error: function(result) {\n                return Promise.error(result);\n            },\n\n            /**\n             * Returns the name of the corresponding Stub.\n             * \n             * @return {string} corresponding Stub name\n             */\n            stub: function() {\n                if (this._stub)\n                    return this._stub;\n                var stub = this.cls.classname;\n                return stub.indexOf(\"Skeleton\") >= 0 ? stub.replace(\"Skeleton\", \"Stub\") : stub;\n            }\n\n        };\n    });\n});\nScoped.define(\"module:RMI.Stub\", [\n    \"module:Class\",\n    \"module:Classes.InvokerMixin\",\n    \"module:Functions\"\n], function(Class, InvokerMixin, Functions, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [InvokerMixin, function(inherited) {\n\n        /**\n         * Abstract Stub Class\n         * \n         * @class BetaJS.RMI.Stub\n         */\n        return {\n\n            /**\n             * \n             * @member {array} intf abstract interface list, needs to be overwritten in subclasses\n             */\n            intf: [],\n\n            /**\n             * \n             * @member {object} serializes list of serialization information\n             */\n            serializes: {},\n\n            /**\n             * Instantiates the stub.\n             * \n             */\n            constructor: function() {\n                inherited.constructor.call(this);\n                this.invoke_delegate(\"invoke\", this.intf);\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                this.invoke(\"_destroy\");\n                inherited.destroy.call(this);\n            },\n\n            /**\n             * @override\n             */\n            invoke: function(message) {\n                return this.__send(message, Functions.getArguments(arguments, 1), this.serializes[message]);\n            }\n\n        };\n    }]);\n});\n\n\nScoped.define(\"module:RMI.StubSyncer\", [\n    \"module:Class\",\n    \"module:Classes.InvokerMixin\",\n    \"module:Functions\",\n    \"module:Promise\"\n], function(Class, InvokerMixin, Functions, Promise, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [InvokerMixin, function(inherited) {\n\n        /**\n         * Stub Syncer class for executing RMI methods one after the other.\n         * \n         * @class BetaJS.RMI.StubSyncer\n         */\n        return {\n\n            /**\n             * Instantiates the stub syncer.\n             * \n             * @param {object} stub stub object\n             */\n            constructor: function(stub) {\n                inherited.constructor.call(this);\n                this.__stub = stub;\n                this.__current = null;\n                this.__queue = [];\n                this.invoke_delegate(\"invoke\", this.__stub.intf);\n            },\n\n            /**\n             * @override\n             */\n            invoke: function() {\n                var object = {\n                    args: Functions.getArguments(arguments),\n                    promise: Promise.create()\n                };\n                this.__queue.push(object);\n                if (!this.__current)\n                    this.__next();\n                return object.promise;\n            },\n\n            /**\n             * @private\n             */\n            __next: function() {\n                if (this.__queue.length === 0)\n                    return;\n                this.__current = this.__queue.shift();\n                this.__stub.invoke.apply(this.__stub, this.__current.args).forwardCallback(this.__current.promise).callback(this.__next, this);\n            }\n\n        };\n    }]);\n});\nScoped.define(\"module:Scheduling.GarbageCollector\", [\n    \"module:Class\",\n    \"module:Scheduling.SchedulableMixin\"\n], function(Class, SchedulableMixin, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [SchedulableMixin, function(inherited) {\n        /**\n         * Garbage Collector\n         * \n         * @class BetaJS.Scheduling.GarbageCollector\n         */\n        return {\n\n            /**\n             * Instantiate garbage collector.\n             * \n             */\n            constructor: function() {\n                inherited.constructor.call(this);\n                this.__classes = {};\n            },\n\n            /**\n             * Add an object to the garbage collection queue.\n             * \n             * @param {object} obj object to be destroyed\n             */\n            queue: function(obj) {\n                if (!obj || obj.destroyed() || this.__classes[obj.cid()])\n                    return this;\n                var cid = obj.cid();\n                this.__classes[cid] = true;\n                this.schedulable(function() {\n                    delete this.__classes[cid];\n                    if (!obj.destroyed())\n                        obj.destroy();\n                    delete obj.__gc;\n                });\n                return this;\n            }\n\n        };\n    }]);\n});\nScoped.define(\"module:Scheduling.SchedulableMixin\", [], function() {\n    return {\n\n        schedulable: function(callback, initialSteps) {\n            if (this.scheduler)\n                this.scheduler.schedulable(this, callback, initialSteps);\n            else\n                callback.call(this, Infinity);\n        }\n\n    };\n});\n\n\nScoped.define(\"module:Scheduling.Helper\", [], function() {\n    return {\n\n        schedulable: function(callback, initialSteps, scheduler, context) {\n            if (scheduler)\n                scheduler.schedulable(context || this, callback, initialSteps);\n            else\n                callback.call(context || this, Infinity);\n        }\n\n    };\n});\n\n\nScoped.define(\"module:Scheduling.AbstractScheduler\", [\n    \"module:Class\"\n], function(Class, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n        return {\n\n            _schedulable: function(context, callback, initialSteps) {},\n\n            _register: function(context, options) {},\n\n            _unregister: function(context, options) {},\n\n            schedulable: function(context, callback, initialSteps) {\n                this._schedulable(context, callback, initialSteps || 1);\n            },\n\n            register: function(context, options) {\n                context.scheduler = this;\n                this._register(context, options);\n            },\n\n            unregister: function(context, options) {\n                if (context.scheduler === this)\n                    context.scheduler = null;\n                this._unregister(context, options);\n            }\n\n        };\n    });\n});\nScoped.define(\"module:Scheduling.DefaultScheduler\", [\n    \"module:Scheduling.AbstractScheduler\",\n    \"module:Time\",\n    \"module:Objs\",\n    \"module:Timers.Timer\"\n], function(AbstractScheduler, Time, Objs, Timer, scoped) {\n    return AbstractScheduler.extend({\n        scoped: scoped\n    }, function(inherited) {\n        return {\n\n            constructor: function(options) {\n                inherited.constructor.call(this);\n                this._current = null;\n                this._last = null;\n                this._first = null;\n                this._map = {};\n                this._resources = 0;\n                this._options = Objs.extend({\n                    penaltyFactor: 0.5,\n                    rewardFactor: 0.5,\n                    defaultResources: 10,\n                    defaultLimit: 10,\n                    autoTimer: null\n                }, options);\n                if (this._options.autoTimer) {\n                    this.auto_destroy(new Timer({\n                        start: true,\n                        delay: this._options.autoTimer,\n                        context: this,\n                        fire: this.run\n                    }));\n                }\n            },\n\n            _register: function(context, options) {\n                var id = context.cid();\n                if (!this._map[id]) {\n                    options = options || {};\n                    var entry = {\n                        context: context,\n                        resources: options.resources || this._options.defaultResources,\n                        scheduled: [],\n                        allocatedTime: 0,\n                        usedTime: 0,\n                        prev: this._last,\n                        next: null\n                    };\n                    this._map[id] = entry;\n                    this._last = entry;\n                    if (!this._first)\n                        this._first = entry;\n                }\n            },\n\n            _unregister: function(ctx) {\n                var id = context.cid();\n                if (this._map[id]) {\n                    var entry = this._map[id];\n                    if (this._current === entry)\n                        this._current = entry.next;\n                    if (entry.prev)\n                        entry.prev.next = entry.next;\n                    else\n                        this._first = entry.next;\n                    if (entry.next)\n                        entry.next.prev = entry.prev;\n                    else\n                        this._last = entry.prev;\n                    if (entry.scheduled)\n                        this._resources -= entry.resources;\n                    delete this._map[id];\n                }\n            },\n\n            _schedulable: function(context, callback, initialSteps) {\n                var id = context.cid();\n                var obj = this._map[id];\n                if (obj) {\n                    obj.scheduled.push({\n                        callback: callback,\n                        initialSteps: initialSteps,\n                        totalTime: 0,\n                        totalSteps: 0\n                    });\n                    if (obj.scheduled.length === 1)\n                        this._resources += obj.resources;\n                }\n            },\n\n            run: function(limit) {\n                limit = limit || this._options.defaultLimit;\n                var endTime = Time.perfNow() + limit;\n                while (this._resources > 0 && this._first) {\n                    var nowTime = Time.perfNow();\n                    var timeLeft = endTime - nowTime;\n                    if (timeLeft <= 0)\n                        break;\n                    var current = this._current || this._first;\n                    if (current.scheduled.length > 0) {\n                        var resources = current.resources;\n                        if (current.allocatedTime > current.usedTime)\n                            resources += current.usedTime / current.allocatedTime * this._options.rewardFactor;\n                        if (current.allocatedTime < current.usedTime)\n                            resources -= current.allocatedTime / current.usedTime * this._options.penaltyFactor;\n                        var currentEndTime = Math.min(nowTime + limit * resources / this._resources, endTime);\n                        do {\n                            var deltaTime = currentEndTime - nowTime;\n                            var head = current.scheduled.shift();\n                            var steps = Math.max(1, head.totalSteps > 0 ? head.totalSteps / (head.totalTime || 1) * deltaTime : head.initialSteps);\n                            var result = head.callback.call(current.context, steps);\n                            if (result === false)\n                                current.scheduled.unshift(head);\n                            else if (current.scheduled.length === 0)\n                                this._resources -= current.resources;\n                            var nextTime = Time.perfNow();\n                            current.allocatedTime += deltaTime;\n                            current.usedTime += nextTime - nowTime;\n                            nowTime = nextTime;\n                        } while (nowTime < currentEndTime && current.scheduled.length > 0);\n                    }\n                    this._current = current.next;\n                }\n            }\n\n        };\n    });\n});\nScoped.define(\"module:States.CompetingComposite\", [\n    \"module:Class\",\n    \"module:Objs\"\n], function(Class, Objs, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Competing Composite Class\n         * \n         * @class BetaJS.States.CompetingComposite\n         */\n        return {\n\n            /**\n             * Register a competing host\n             * \n             * @param {object} competing_host Competing host\n             */\n            _register_host: function(competing_host) {\n                this._hosts = this._hosts || [];\n                this._hosts.push(this._auto_destroy(competing_host));\n            },\n\n            /**\n             * Returns all other hosts of a competing host\n             * \n             * @param {object} competing_host competing hosts in question\n             * @return {array} other hosts\n             */\n            other_hosts: function(competing_host) {\n                return Objs.filter(this._hosts || [], function(other) {\n                    return other != competing_host;\n                }, this);\n            },\n\n            /**\n             * Transcend to another state of a competing host\n             * \n             * @param {object} competing_host Competing host\n             * @param {object} state State\n             */\n            _next: function(competing_host, state) {\n                var others = this.other_hosts(competing_host);\n                for (var i = 0; i < others.length; ++i) {\n                    var other = others[i];\n                    var other_state = other.state();\n                    if (!other_state.can_coexist_with(state))\n                        other_state.retreat_against(state);\n                }\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:States.CompetingHost\", [\"module:States.Host\"], function(Host, scoped) {\n    return Host.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * CompetingHost Class\n         * \n         * @class BetaJS.States.CompetingHost\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {object} composite Associated composite object\n             * @param {object} options Host options\n             */\n            constructor: function(composite, options) {\n                inherited.constructor.call(this, options);\n                this._composite = composite;\n                if (composite)\n                    composite._register_host(this);\n            },\n\n            /**\n             * Returns the associated composite.\n             * \n             * @return {object} Composite\n             */\n            composite: function() {\n                return this._composite;\n            },\n\n            /**\n             * @override\n             */\n            _can_transition_to: function(state) {\n                if (!inherited._can_transition_to.call(this, state))\n                    return false;\n                if (!this._composite)\n                    return true;\n                var others = this._composite.other_hosts(this);\n                for (var i = 0; i < others.length; ++i) {\n                    var other = others[i];\n                    var other_state = other.state();\n                    if (!state.can_coexist_with(other_state) && !state.can_prevail_against(other_state))\n                        return false;\n                }\n                return true;\n            },\n\n            /**\n             * @override\n             */\n            _next: function(state) {\n                if (this._composite)\n                    this._composite._next(this, state);\n                inherited._next.call(this, state);\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:States.CompetingState\", [\"module:States.State\"], function(State, scoped) {\n    return State.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * ComponentState Class\n         * \n         * @class BetaJS.States.CompetingState\n         */\n        return {\n\n            /**\n             * Determines whether this state can coexist with a foreign state\n             * \n             * @param {object} foreign_state Foreign state\n             * @return {boolean} true if it can coexist\n             */\n            can_coexist_with: function(foreign_state) {\n                return true;\n            },\n\n            /**\n             * Determines whether this state can prevail against a foreign state\n             * \n             * @param {object} foreign_state Foreign state\n             * @return {boolean} true if it can prevail\n             */\n            can_prevail_against: function(foreign_state) {\n                return false;\n            },\n\n            /**\n             * Retreat against foreign state\n             * \n             * @param {object} foreign_state Foreign state\n             */\n            retreat_against: function(foreign_state) {}\n\n        };\n    });\n});\nScoped.define(\"module:Router.RouteParser\", [\n    \"module:Class\", \"module:Strings\", \"module:Objs\"\n], function(Class, Strings, Objs, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Route Parser Class\n         * \n         * @class BetaJS.Router.RouteParser\n         */\n        return {\n\n            /**\n             * Create a new instance.\n             * \n             * @param {object} routes routes mapping\n             */\n            constructor: function(routes) {\n                inherited.constructor.call(this);\n                this.routes = {};\n                Objs.iter(routes, function(route, key) {\n                    this.bind(key, route);\n                }, this);\n            },\n\n            /**\n             * Return parses a route and returns the parsed result.\n             * \n             * @param {string} route route to be parsed\n             * @return {object} parsed route\n             */\n            parse: function(route) {\n                for (var key in this.routes) {\n                    var entry = this.routes[key];\n                    var result = entry.captureRegex.exec(route);\n                    if (result) {\n                        return {\n                            name: entry.name,\n                            args: result\n                        };\n                    }\n                }\n                return null;\n            },\n\n            /**\n             * Recreates a full route from an abstract route descriptor and route arguments.\n             * \n             * @param {string} name route descriptor\n             * @param {array} args arguments for route\n             * \n             * @return {string} full route\n             * \n             */\n            format: function(name, args) {\n                args = args || {};\n                var entry = this.routes[name];\n                return Strings.regexReplaceGroups(entry.regex,\n                    entry.captureRegex.mapBack(args));\n            },\n\n            /**\n             * Bind a new route.\n             * \n             * @param {string} key route descriptor\n             * @param {string} route route regex string\n             */\n            bind: function(key, route) {\n                this.routes[key] = {\n                    name: key,\n                    regex: route,\n                    captureRegex: Strings.namedCaptureRegex(\"^\" + route + \"$\")\n                };\n                return this;\n            }\n\n        };\n    });\n});\n\nScoped.define(\"module:Router.RouteMap\", [\n    \"module:Class\", \"module:Strings\", \"module:Objs\"\n], function(Class, Strings, Objs, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * RouteMap Class, mapping routes to routes.\n         * \n         * @class BetaJS.Router.RouteMap\n         */\n        return {\n\n            /**\n             * Creates new instance.\n             * \n             * @param {object} options initialization options\n             */\n            constructor: function(options) {\n                inherited.constructor.call(this);\n                options = options || {};\n                this._defaultMap = options.map;\n                this._context = options.context || this;\n                this._bindings = options.bindings || {};\n            },\n\n            /**\n             * Maps a route.\n             * \n             * @param {string} name route name\n             * @param {array} args route arguments\n             * \n             * @return {object} mapped route\n             */\n            map: function(name, args) {\n                var binding = this._bindings[name];\n                if (binding)\n                    return binding.call(this._context, name, args);\n                if (this._defaultMap)\n                    return this._defaultMap.call(this._context, name, args);\n                return {\n                    name: name,\n                    args: args\n                };\n            },\n\n            /**\n             * Binds a route.\n             * \n             * @param {string} name name of route\n             * @param {function} func function to bind the route to\n             */\n            bind: function(name, func) {\n                this._bindings[name] = func;\n                return this;\n            }\n\n        };\n    });\n});\n\nScoped.define(\"module:Router.Router\", [\n    \"module:Class\",\n    \"module:Events.EventsMixin\",\n    \"module:Objs\",\n    \"module:Router.RouteParser\",\n    \"module:Comparators\"\n], function(Class, EventsMixin, Objs, RouteParser, Comparators, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [EventsMixin, function(inherited) {\n\n        /**\n         * Router Class\n         * \n         * @class BetaJS.Router.Router\n         */\n        return {\n\n            /**\n             * Creates new instance.\n             * \n             * @param {object} routes routes mapping for route parser\n             */\n            constructor: function(routes) {\n                inherited.constructor.call(this);\n                this._routeParser = new RouteParser(routes);\n                this._current = null;\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                this._routeParser.destroy();\n                inherited.destroy.call(this);\n            },\n\n            /**\n             * Bind a new route.\n             * \n             * @param {string} key route descriptor\n             * @param {string} route route regex string\n             * @param {function} func optional function to be called when route is dispatched\n             * @param {object} ctx optional function context\n             */\n            bind: function(key, route, func, ctx) {\n                this._routeParser.bind(key, route);\n                if (func)\n                    this.on(\"dispatch:\" + key, func, ctx);\n                return this;\n            },\n\n            /**\n             * Returns the current route.\n             * \n             * @return {string} current route\n             */\n            current: function() {\n                return this._current;\n            },\n\n            /**\n             * Navigates to a new route.\n             * \n             * @param {string} route route to navigate to\n             * @fires BetaJS.Router.Router#navigate\n             * @fires BetaJS.Router.Router#notfound\n             */\n            navigate: function(route) {\n                /**\n                 * @event BetaJS.Router.Router#navigate\n                 */\n                this.trigger(\"navigate\", route);\n                this.trigger(\"navigate:\" + route);\n                var parsed = this._routeParser.parse(route);\n                if (parsed)\n                    this.dispatch(parsed.name, parsed.args, route);\n                else {\n                    /**\n                     * @event BetaJS.Router.Router#notfound\n                     */\n                    this.trigger(\"notfound\", route);\n                }\n                return this;\n            },\n\n            /**\n             * Dispatches a new route.\n             * \n             * @param {string} name name of route\n             * @param {array} args arguments of new route\n             * @param {string} route optional route string\n             * @fires BetaJS.Router.Router#leave\n             * @fires BetaJS.Router.Router#dispatch\n             * @fires BetaJS.Router.Router#dispatched\n             */\n            dispatch: function(name, args, route) {\n                if (this._current) {\n                    if (this._current.name === name && Comparators.deepEqual(args, this._current.args, 2))\n                        return;\n                    /**\n                     * @event BetaJS.Router.Router#leave\n                     */\n                    this.trigger(\"leave\", this._current.name, this._current.args, this._current);\n                    this.trigger(\"leave:\" + this._current.name, this._current.args, this._current);\n                }\n                var current = {\n                    route: route || this.format(name, args),\n                    name: name,\n                    args: args\n                };\n                /**\n                 * @event BetaJS.Router.Router#dispatch\n                 */\n                this.trigger(\"dispatch\", name, args, current);\n                this.trigger(\"dispatch:\" + name, args, current);\n                this._current = current;\n                /**\n                 * @event BetaJS.Router.Router#dispatched\n                 */\n                this.trigger(\"dispatched\", name, args, current);\n                this.trigger(\"dispatched:\" + name, args, current);\n                return this;\n            },\n\n            /**\n             * Recreates a full route from an abstract route descriptor and route arguments.\n             * \n             * @param {string} name route descriptor\n             * @param {array} args arguments for route\n             * \n             * @return {string} full route\n             * \n             */\n            format: function(name, args) {\n                return this._routeParser.format(name, args);\n            }\n\n        };\n    }]);\n});\n\n\n\nScoped.define(\"module:Router.RouteBinder\", [\n    \"module:Class\",\n    \"module:Types\",\n    \"module:Comparators\"\n], function(Class, Types, Comparators, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Abstract Route Binder Class for bidirectionally binding the route to a separate router.\n         * \n         * @class BetaJS.Router.RouteBinder\n         */\n        return {\n\n            /**\n             * Overwrite the local route of this binder.\n             * \n             * @param {string} currentRoute current route\n             */\n            _setLocalRoute: function(currentRoute) {},\n\n            /**\n             * Read the local route of this binder.\n             * \n             * @return {string} local route\n             */\n            _getLocalRoute: function() {},\n\n            /**\n             * Notify the router that the local route has changed.\n             */\n            _localRouteChanged: function() {\n                this.setGlobalRoute(this._getLocalRoute());\n            },\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {object} router router instance\n             */\n            constructor: function(router) {\n                inherited.constructor.call(this);\n                this._router = router;\n                router.on(\"dispatched\", function() {\n                    this.setLocalRoute(router.current());\n                }, this);\n                if (router.current())\n                    this.setLocalRoute(router.current());\n                else if (this._getLocalRoute())\n                    this.setGlobalRoute(this._getLocalRoute());\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                this._router.off(null, null, this);\n                inherited.destroy.call(this);\n            },\n\n            /**\n             * Sets the local route.\n             * \n             * @param {string} currentRoute current route\n             */\n            setLocalRoute: function(currentRoute) {\n                this._lastLocalRoute = currentRoute;\n                this._setLocalRoute(currentRoute);\n                return this;\n            },\n\n            /**\n             * Sets the global route.\n             * \n             * @param {string} route new global route\n             */\n            setGlobalRoute: function(route) {\n                if (Types.is_string(route)) {\n                    if (!this._lastLocalRoute || route !== this._lastLocalRoute.route)\n                        this._router.navigate(route);\n                } else {\n                    if (!this._lastLocalRoute || route.name !== this._lastLocalRoute.name || !Comparators.deepEqual(route.args, this._lastLocalRoute.args, 2))\n                        this._router.dispatch(route.name, route.args);\n                }\n                return this;\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Router.StateRouteBinder\", [\n    \"module:Router.RouteBinder\", \"module:Objs\", \"module:Strings\", \"module:Router.RouteMap\"\n], function(RouteBinder, Objs, Strings, RouteMap, scoped) {\n    return RouteBinder.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * State Router Binder Class, binding a router to a state machine\n         * \n         * @class BetaJS.Router.StateRouteBinder\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {object} router router instance\n             * @param {object} stateHost state host instance\n             * @param {object} options optional options\n             */\n            constructor: function(router, stateHost, options) {\n                this._stateHost = stateHost;\n                options = Objs.extend({\n                    capitalizeStates: false\n                }, options);\n                this._options = options;\n                this._routeToState = new RouteMap({\n                    map: this._options.routeToState || function(name, args) {\n                        return {\n                            name: options.capitalizeStates ? Strings.capitalize(name) : name,\n                            args: args\n                        };\n                    },\n                    context: this._options.context\n                });\n                this._stateToRoute = new RouteMap({\n                    map: this._options.stateToRoute || function(name, args) {\n                        return {\n                            name: name.toLowerCase(),\n                            args: args\n                        };\n                    },\n                    context: this._options.context\n                });\n                inherited.constructor.call(this, router);\n                stateHost.on(\"start\", this._localRouteChanged, this);\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                this._routeToState.destroy();\n                this._stateToRoute.destroy();\n                this._stateHost.off(null, null, this);\n                inherited.destroy.call(this);\n            },\n\n            /**\n             * Bind a route to a state.\n             * \n             * @param {string} name route name\n             * @param {function} func state function\n             */\n            bindRouteToState: function(name, func) {\n                this._routeToState.bind(name, func);\n                return this;\n            },\n\n            /**\n             * Bind a state to a route.\n             * \n             * @param {string} name state name\n             * @param {function} func route function\n             */\n            bindStateToRoute: function(name, func) {\n                this._stateToRoute.bind(name, func);\n                return this;\n            },\n\n            /**\n             * Register a new route and corresponding state.\n             * \n             * @param {string} name name of route / state\n             * @param {string} route new route\n             * @param {object} extension state extension object\n             */\n            register: function(name, route, extension) {\n                this._router.bind(name, route);\n                this._stateHost.register(this._options.capitalizeStates ? Strings.capitalize(name) : name, extension);\n                return this;\n            },\n\n            /**\n             * @override\n             */\n            _setLocalRoute: function(currentRoute) {\n                var mapped = this._routeToState.map(currentRoute.name, currentRoute.args);\n                if (mapped) {\n                    this._stateHost.weakNext(mapped.name, mapped.args);\n                    /*\n                    Objs.iter(args, function (value, key) {\n                    \tthis._stateHost.set(key, value);\n                    }, this);\n                    */\n                }\n            },\n\n            /**\n             * @override\n             */\n            _getLocalRoute: function() {\n                if (!this._stateHost.state())\n                    return null;\n                var state = this._stateHost.state();\n                return this._stateToRoute.map(state.state_name(), state.allAttr());\n            }\n\n        };\n    });\n});\n\n\nScoped.define(\"module:Router.RouterHistory\", [\n    \"module:Class\", \"module:Events.EventsMixin\"\n], function(Class, EventsMixin, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [EventsMixin, function(inherited) {\n\n        /**\n         * Router History Class\n         * \n         * @class BetaJS.Router.RouterHistory\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {object} router router instance\n             * @fires BetaJS.Router.RouterHistory#change\n             * @fires BetaJS.Router.RouterHistory#insert\n             */\n            constructor: function(router) {\n                inherited.constructor.call(this);\n                this._router = router;\n                this._history = [];\n                router.on(\"dispatched\", function(name, args, current) {\n                    this._history.push(current);\n                    /**\n                     * @event BetaJS.Router.RouterHistory#change\n                     */\n                    this.trigger(\"change\", current);\n                    /**\n                     * @event BetaJS.Router.RouterHistory#insert\n                     */\n                    this.trigger(\"insert\", current);\n                }, this);\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                this._router.off(null, null, this);\n                inherited.destroy.call(this);\n            },\n\n            /**\n             * Returns the last history item.\n             * \n             * @param {int} index optional index, counting from the end.\n             * @return {string} history route\n             */\n            last: function(index) {\n                index = index || 0;\n                return this.get(this.count() - 1 - index);\n            },\n\n            /**\n             * Return the number of history items.\n             * \n             * @return {int} number of history items \n             */\n            count: function() {\n                return this._history.length;\n            },\n\n            /**\n             * Pops and returns last history entry.\n             *\n             * @return {object} last history entry\n             */\n            pop: function() {\n                return this._history.pop();\n            },\n\n            /**\n             * Returns a history item.\n             * \n             * @param {int} index optional index, counting from the start.\n             * @return {string} history route\n             */\n            get: function(index) {\n                index = index || 0;\n                return this._history[index];\n            },\n\n            /**\n             * Goes back in history.\n             * \n             * @param {int} index optional index, stating how many items to go back.\n             * @fires BetaJS.Router.RouterHistory#remove\n             * @fires BetaJS.Router.RouterHistory#change\n             */\n            back: function(index) {\n                if (this.count() < 2)\n                    return null;\n                index = index || 0;\n                while (index >= 0 && this.count() > 1) {\n                    var removed = this.pop();\n                    /**\n                     * @event BetaJS.Router.RouterHistory#remove\n                     */\n                    this.trigger(\"remove\", removed);\n                    --index;\n                }\n                var item = this.pop();\n                /**\n                 * @event BetaJS.Router.RouterHistory#change\n                 */\n                this.trigger(\"change\", item);\n                return this._router.dispatch(item.name, item.args);\n            }\n\n        };\n    }]);\n});\nScoped.define(\"module:States.Host\", [\n    \"module:Properties.Properties\", \"module:Events.EventsMixin\", \"module:States.State\", \"module:Types\", \"module:Strings\", \"module:Classes.ClassRegistry\"\n], function(Class, EventsMixin, State, Types, Strings, ClassRegistry, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, [EventsMixin, function(inherited) {\n\n        /**\n         * State Machine Host Class\n         * \n         * @class BetaJS.States.Host\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {object} options options for state host\n             */\n            constructor: function(options) {\n                inherited.constructor.call(this);\n                options = options || {};\n                this._stateRegistry = options.stateRegistry;\n                this._baseState = options.baseState;\n                this._enabled = true;\n            },\n\n            /**\n             * Initialize state machine.\n             * \n             * @param initial_state initial state as string or class\n             * @param {object} initial_args initial arguments for state\n             * \n             */\n            initialize: function(initial_state, initial_args) {\n                if (!this._stateRegistry) {\n                    var s = null;\n                    if (Types.is_string(initial_state) && initial_state.indexOf(\".\") >= 0) {\n                        var split = Strings.splitLast(initial_state, \".\");\n                        initial_state = split.tail;\n                        s = split.head;\n                    } else if (!Types.is_string(initial_state))\n                        s = Strings.splitLast(initial_state.classname, \".\").head;\n                    else\n                        s = Strings.splitLast(this.cls.classname, \".\").head;\n                    this._stateRegistry = this._auto_destroy(new ClassRegistry(Scoped.getGlobal(s)));\n                }\n                this._createState(initial_state, initial_args).start();\n                this._baseState = this._baseState || this._state.cls;\n                return this;\n            },\n\n            /**\n             * Creates a new state.\n             * \n             * @protected\n             * \n             * @param state state as string or class\n             * @param {object} args arguments for state\n             * @param {object} transitionals transitional arguments for state\n             * \n             * @return {object} created state\n             */\n            _createState: function(state, args, transitionals) {\n                return this._stateRegistry.create(state, this, args || {}, transitionals || {});\n            },\n\n            /**\n             * Finalize current state.\n             */\n            finalize: function() {\n                if (this._state)\n                    this._state.end();\n                this._state = null;\n                return this;\n            },\n\n            /**\n             * @override\n             */\n            destroy: function() {\n                this.finalize();\n                inherited.destroy.call(this);\n            },\n\n            /**\n             * Enable the state machine.\n             */\n            enable: function() {\n                this._enabled = true;\n                return this;\n            },\n\n            /**\n             * Disable the state machine.\n             */\n            disable: function() {\n                this._enabled = false;\n                return this;\n            },\n\n            /**\n             * Returns the current state.\n             * \n             * @return {object} current state\n             */\n            state: function() {\n                return this._state;\n            },\n\n            /**\n             * Returns the current state name.\n             * \n             * @return {string} state name\n             */\n            state_name: function() {\n                return this.state().state_name();\n            },\n\n            /**\n             * Transitions to the next state\n             * \n             * @return {object} next state\n             */\n            next: function() {\n                return this.state() ? this.state().next.apply(this.state(), arguments) : this.initialize.apply(this, arguments);\n            },\n\n            /**\n             * Weakly transitions to the next state\n             * \n             * @return {object} next state\n             */\n            weakNext: function() {\n                return this.state() ? this.state().weakNext.apply(this.state(), arguments) : this.initialize.apply(this, arguments);\n            },\n\n            /**\n             * Starts a new state.\n             * \n             * @protected\n             * \n             * @param {object} state state to start\n             */\n            _start: function(state) {\n                this._stateEvent(state, \"before_start\");\n                this._state = state;\n                this.set(\"name\", state.state_name());\n            },\n\n            /**\n             * Called after an event was started.\n             * \n             * @protected\n             * \n             * @param {object} state state in question\n             */\n            _afterStart: function(state) {\n                this._stateEvent(state, \"start\");\n            },\n\n            /**\n             * End a state.\n             * \n             * @protected\n             * \n             * @param {object} state state in question\n             */\n            _end: function(state) {\n                this._stateEvent(state, \"end\");\n                this._state = null;\n            },\n\n            /**\n             * Called after an event was ended.\n             * \n             * @protected\n             * \n             * @param {object} state state in question\n             */\n            _afterEnd: function(state) {\n                this._stateEvent(state, \"after_end\");\n            },\n\n            /**\n             * Called when a transition to a state is taking place.\n             * \n             * @protected\n             * \n             * @param {object} state state in question\n             */\n            _next: function(state) {\n                this._stateEvent(state, \"next\");\n            },\n\n            /**\n             * Called after transitioning to a state.\n             * \n             * @protected\n             * \n             * @param {object} state state in question\n             */\n            _afterNext: function(state) {\n                this._stateEvent(state, \"after_next\");\n            },\n\n            /**\n             * Determines whether we can transition to a state\n             * \n             * @protected\n             * \n             * @param {object} state state in question\n             * @return {boolean} true if we can transition\n             */\n            _can_transition_to: function(state) {\n                return this._enabled;\n            },\n\n            /**\n             * Triggers a state event.\n             * \n             * @protected\n             * \n             * @param {object} state state in question\n             * @param {string} s name of event\n             * @fires BetaJS.States.Host#event\n             */\n            _stateEvent: function(state, s) {\n                /**\n                 * @event BetaJS.States.Host#event\n                 */\n                this.trigger(\"event\", s, state.state_name(), state.description());\n                this.trigger(s, state.state_name(), state.description());\n                this.trigger(s + \":\" + state.state_name(), state.description());\n            },\n\n            /**\n             * Registers a new state.\n             * \n             * @param {string} state_name name of new state\n             * @param {object} parent_state class of parent state we should inherit from\n             * @param {object} extend extension of state class\n             * \n             * @return {object} new state class\n             */\n            register: function(state_name, parent_state, extend) {\n                if (!Types.is_string(parent_state)) {\n                    extend = parent_state;\n                    parent_state = null;\n                }\n                if (!this._stateRegistry)\n                    this._stateRegistry = this._auto_destroy(new ClassRegistry(Strings.splitLast(this.cls.classname).head));\n                var base = this._baseState ? (Strings.splitLast(this._baseState.classname, \".\").head + \".\" + state_name) : (state_name.indexOf(\".\") >= 0 ? state_name : null);\n                var cls = (this._stateRegistry.get(parent_state) || this._baseState || State).extend(base, extend);\n                if (!base)\n                    cls.classname = state_name;\n                this._stateRegistry.register(Strings.last_after(state_name, \".\"), cls);\n                return this;\n            }\n\n        };\n    }]);\n});\n\n\nScoped.define(\"module:States.State\", [\n    \"module:Class\", \"module:Types\", \"module:Strings\", \"module:Async\", \"module:Objs\"\n], function(Class, Types, Strings, Async, Objs, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * Abstract State Class\n         * \n         * @class BetaJS.States.State\n         */\n        return {\n\n            _locals: [],\n            _persistents: [],\n            _defaults: {},\n            _clonedDefaults: {},\n\n            _white_list: null,\n\n            _starting: false,\n            _started: false,\n            _stopped: false,\n            _transitioning: false,\n            __next_state: null,\n            __suspended: 0,\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {object} host state host\n             * @param {object} args arguments for creating the state\n             * @param {object} transitionals transitionals variables\n             */\n            constructor: function(host, args, transitionals) {\n                inherited.constructor.call(this);\n                this.host = host;\n                this.transitionals = transitionals;\n                args = Objs.extend(Objs.extend(Objs.clone(this._clonedDefaults || {}, -1), Objs.clone(this._defaults || {}, 1)), args);\n                this._locals = Types.is_function(this._locals) ? this._locals() : this._locals;\n                var used = {};\n                for (var i = 0; i < this._locals.length; ++i) {\n                    this[\"_\" + this._locals[i]] = args[this._locals[i]];\n                    used[this._locals[i]] = true;\n                }\n                this._persistents = Types.is_function(this._persistents) ? this._persistents() : this._persistents;\n                for (i = 0; i < this._persistents.length; ++i) {\n                    this[\"_\" + this._persistents[i]] = args[this._persistents[i]];\n                    used[this._locals[i]] = true;\n                }\n                host.suspendEvents();\n                this.__hostArgs = {};\n                Objs.iter(args, function(value, key) {\n                    if (!used[key]) {\n                        this.__hostArgs[key] = true;\n                        host.set(key, value);\n                    }\n                }, this);\n                host.resumeEvents();\n            },\n\n            /**\n             * Returns all attributes of the state.\n             * \n             * @return {object} all attributes\n             */\n            allAttr: function() {\n                var result = Objs.clone(this.host.data(), 1);\n                Objs.iter(this._locals, function(key) {\n                    result[key] = this[\"_\" + key];\n                }, this);\n                Objs.iter(this._persistents, function(key) {\n                    result[key] = this[\"_\" + key];\n                }, this);\n                return result;\n            },\n\n            /**\n             * Returns the name of state.\n             * \n             * @return {string} name of state\n             */\n            state_name: function() {\n                return Strings.last_after(this.cls.classname, \".\");\n            },\n\n            /**\n             * Returns the description of state.\n             * \n             * @return {string} description of state\n             */\n            description: function() {\n                return this.state_name();\n            },\n\n            /**\n             * Starts the state.\n             */\n            start: function() {\n                if (this._starting)\n                    return this;\n                this._starting = true;\n                this.host._start(this);\n                this._start();\n                if (this.host) {\n                    this.host._afterStart(this);\n                    this._started = true;\n                }\n                return this;\n            },\n\n            /**\n             * Ends the state.\n             */\n            end: function() {\n                if (this._stopped)\n                    return this;\n                this._stopped = true;\n                this._end();\n                this.host._end(this);\n                this.host._afterEnd(this);\n                this.destroy();\n                return this;\n            },\n\n            /**\n             * Eventually transitions to the next state.\n             * \n             * @param {string} state_name name of next state\n             * @param {object} args arguments for creating the state\n             * @param {object} transitionals transitionals variables\n             * \n             * @return {object} next state\n             */\n            eventualNext: function(state_name, args, transitionals) {\n                this.suspend();\n                var state = this.next(state_name, args, transitionals);\n                this.eventualResume();\n                return state;\n            },\n\n            /**\n             * Eventually transitions to the next state.\n             * \n             * @param {string} state_name name of next state\n             * @param {object} args arguments for creating the state\n             * @param {object} transitionals transitionals variables\n             * \n             * @return {object} next state\n             */\n            next: function(state_name, args, transitionals) {\n                if (!this._starting || this._stopped || this.__next_state)\n                    return null;\n                args = args || {};\n                for (var i = 0; i < this._persistents.length; ++i) {\n                    if (!(this._persistents[i] in args))\n                        args[this._persistents[i]] = this[\"_\" + this._persistents[i]];\n                }\n                var obj = this.host._createState(state_name, args, transitionals);\n                if (!this.can_transition_to(obj)) {\n                    obj.destroy();\n                    return null;\n                }\n                if (!this._started) {\n                    this.host._afterStart(this);\n                    this._started = true;\n                }\n                this.__next_state = obj;\n                this._transitioning = true;\n                this._transition();\n                if (this.__suspended <= 0)\n                    this.__next();\n                return obj;\n            },\n\n            /**\n             * Checks weakly whether a prospective new state is equal to this state.\n             * \n             * @param {string} state_name name of next state\n             * @param {object} args arguments for creating the state\n             * @param {object} transitionals transitionals variables\n             * \n             * @return {boolean} true if equal\n             */\n            weakSame: function(state_name, args, transitionals) {\n                var same = true;\n                if (state_name !== this.state_name())\n                    same = false;\n                var all = this.allAttr();\n                Objs.iter(args, function(value, key) {\n                    if (all[key] !== value)\n                        same = false;\n                }, this);\n                return same;\n            },\n\n            /**\n             * Weakly transitions to the next state.\n             * \n             * @param {string} state_name name of next state\n             * @param {object} args arguments for creating the state\n             * @param {object} transitionals transitionals variables\n             * \n             * @return {object} next state\n             */\n            weakNext: function(state_name, args, transitionals) {\n                return this.weakSame.apply(this, arguments) ? this : this.next.apply(this, arguments);\n            },\n\n            __next: function() {\n                var host = this.host;\n                var obj = this.__next_state;\n                host._next(obj);\n                var hostArgs = this.__hostArgs;\n                this.end();\n                obj.start();\n                host.suspendEvents();\n                obj = host.state();\n                if (!obj || obj.destroyed())\n                    return;\n                Objs.iter(hostArgs, function(dummy, key) {\n                    if (!obj.__hostArgs[key])\n                        host.unset(key);\n                }, this);\n                host.resumeEvents();\n                host._afterNext(obj);\n            },\n\n            _transition: function() {},\n\n            /**\n             * Suspends the state.\n             */\n            suspend: function() {\n                this.__suspended++;\n                return this;\n            },\n\n            /**\n             * Eventually resumes the state.\n             */\n            eventualResume: function() {\n                Async.eventually(this.resume, this);\n                return this;\n            },\n\n            /**\n             * Resumes the state.\n             */\n            resume: function() {\n                this.__suspended--;\n                if (this.__suspended === 0 && !this._stopped && this.__next_state)\n                    this.__next();\n                return this;\n            },\n\n            /**\n             * Determines whether the state can transition to another state.\n             * \n             * @param {object} state another state\n             * \n             * @return {boolean} true if it can transition\n             */\n            can_transition_to: function(state) {\n                return this.host && this.host._can_transition_to(state) && this._can_transition_to(state);\n            },\n\n            _start: function() {},\n\n            _end: function() {},\n\n            _can_transition_to: function(state) {\n                return !Types.is_array(this._white_list) || Objs.contains_value(this._white_list, state.state_name());\n            }\n\n        };\n    }, {\n\n        _extender: {\n            _defaults: function(base, overwrite) {\n                return Objs.extend(Objs.clone(base, 1), overwrite);\n            }\n        }\n\n    });\n});\n\n\nScoped.define(\"module:States.StateRouter\", [\n    \"module:Class\", \"module:Objs\"\n], function(Class, Objs, scoped) {\n    return Class.extend({\n        scoped: scoped\n    }, function(inherited) {\n\n        /**\n         * State Router Class\n         * \n         * @class BetaJS.States.StateRouter\n         */\n        return {\n\n            /**\n             * Creates a new instance.\n             * \n             * @param {object} host state host\n             */\n            constructor: function(host) {\n                inherited.constructor.call(this);\n                this._host = host;\n                this._routes = [];\n                this._states = {};\n            },\n\n            /**\n             * Register a route.\n             * \n             * @param {string} route route to be registered\n             * @param {string} state state to be registered\n             * @param {array} mapping optional argument mapping\n             */\n            registerRoute: function(route, state, mapping) {\n                var descriptor = {\n                    key: route,\n                    route: new RegExp(\"^\" + route + \"$\"),\n                    state: state,\n                    mapping: mapping || []\n                };\n                this._routes.push(descriptor);\n                this._states[state] = descriptor;\n                return this;\n            },\n\n            /**\n             * Read a route from a state object.\n             * \n             * @param {object} stateObject state object\n             * \n             * @return {string} corresponding route\n             */\n            readRoute: function(stateObject) {\n                var descriptor = this._states[stateObject.state_name()];\n                if (!descriptor)\n                    return null;\n                var regex = /\\(.*?\\)/;\n                var route = descriptor.key;\n                Objs.iter(descriptor.mapping, function(arg) {\n                    route = route.replace(regex, stateObject[\"_\" + arg]);\n                }, this);\n                return route;\n            },\n\n            /**\n             * Parses a route.\n             * \n             * @param {string} route route to be parsed\n             * \n             * @return {object} state and argument descriptor\n             */\n            parseRoute: function(route) {\n                for (var i = 0; i < this._routes.length; ++i) {\n                    var descriptor = this._routes[i];\n                    var result = descriptor.route.exec(route);\n                    if (result === null)\n                        continue;\n                    var args = {};\n                    for (var j = 0; j < descriptor.mapping.length; ++j)\n                        args[descriptor.mapping[j]] = result[j + 1];\n                    return {\n                        state: descriptor.state,\n                        args: args\n                    };\n                }\n                return null;\n            },\n\n            /**\n             * Returns the current route.\n             * \n             * @return {string} current route\n             */\n            currentRoute: function() {\n                return this.readRoute(this._host.state());\n            },\n\n            /**\n             * Navigate to a route.\n             * \n             * @param {string} route route to be navigated to\n             */\n            navigateRoute: function(route) {\n                var parsed = this.parseRoute(route);\n                if (parsed)\n                    this._host.next(parsed.state, parsed.args);\n                return this;\n            }\n\n        };\n    });\n});\nScoped.define(\"module:JavaScript\", [\"module:Objs\"], function (Objs) {\n    /**\n     * JavaScript Simple Parse Functions\n     *\n     * @module BetaJS.JavaScript\n     */\n    return {\n        STRING_SINGLE_QUOTATION_REGEX: /'[^']*'/g,\n        STRING_DOUBLE_QUOTATION_REGEX: /\"[^\"]*\"/g,\n        PROPER_IDENTIFIER_REGEX: /^[a-zA-Z_][a-zA-Z_0-9]*$/,\n        IDENTIFIER_REGEX: /[a-zA-Z_][a-zA-Z_0-9]*/g,\n        IDENTIFIER_SCOPE_REGEX: /[a-zA-Z_][a-zA-Z_0-9\\.]*/g,\n        RESERVED: Objs.objectify([\n            \"if\", \"then\", \"else\", \"return\", \"var\"\n        ], true),\n        /**\n         * Is string a JS-reserved keyword?\n         *\n         * @param {string} key string in question\n         * @return {boolean} true if reserved\n         */\n        isReserved: function (key) {\n            return key in this.RESERVED;\n        },\n        /**\n         * Is string a valid JS identifier?\n         *\n         * @param {string} key string in question\n         * @return {boolean} true if identifier\n         */\n        isIdentifier: function (key) {\n            return !this.isReserved(key);\n        },\n        /**\n         * Is string a valid proper JS identifier?\n         *\n         * @param {string} key string in question\n         * @return {boolean} true if identifier\n         */\n        isProperIdentifier: function (key) {\n            return this.isIdentifier(key) && this.PROPER_IDENTIFIER_REGEX.test(key);\n        },\n        /**\n         * Remove string definitions from JS code.\n         *\n         * @param {string} code input code\n         * @return {string} code without strings\n         */\n        removeStrings: function (code) {\n            return code.replace(this.STRING_SINGLE_QUOTATION_REGEX, \"\").replace(this.STRING_DOUBLE_QUOTATION_REGEX, \"\");\n        },\n        /**\n         * Return JS identifiers from a piece of code.\n         *\n         * @param {string} code input code\n         * @param {boolean} keepScopes keep scopes, e.g. `foo.bar` instead of `foo` and `bar` (default: false)\n         * @return {array} array of extracted identifiers\n         */\n        extractIdentifiers: function (code, keepScopes) {\n            var regex = keepScopes ? this.IDENTIFIER_SCOPE_REGEX : this.IDENTIFIER_REGEX;\n            code = this.removeStrings(code);\n            return Objs.filter(code.match(regex), this.isIdentifier, this);\n        },\n        /**\n         * Return function parameter names\n         *\n         * @param {string} func JavaScript function to extract parameter names\n         * @return {array} array of extracted parameter names\n         */\n        extractFunctionParameterNames: function (func) {\n            return (func.toString().match(/function \\((.*)\\).*/))[1].replace(/\\s*/g, \"\").split(\",\");\n        }\n    };\n});\n\nScoped.define(\"module:Maths\", [], function () {\n    /**\n     * This module contains auxilary math functions.\n     *\n     * @module BetaJS.Maths\n     */\n    return {\n        /**\n         * Ceiling an integer to be a multiple of another integer.\n         *\n         * @param {int} number the number to be ceiled\n         * @param {int} steps the multiple\n         * @param {int} max an optional maximum\n         *\n         * @return {int} ceiled integer\n         */\n        discreteCeil: function (number, steps, max) {\n            var x = Math.ceil(number / steps) * steps;\n            return max && x > max ? 0 : x;\n        },\n        /**\n         * Clamps number between an upper and lower bound.\n         *\n         * @param {number} number the number to clamp\n         * @param {number} lower the lower bound\n         * @param {number} upper the upper bound\n         *\n         * @return {number} the clamped number\n         */\n        clamp: function (number, lower, upper) {\n            if (lower === void 0) { lower = -Infinity; }\n            if (upper === void 0) { upper = Infinity; }\n            if (number < lower)\n                return lower;\n            if (number > upper)\n                return upper;\n            return number;\n        },\n        /**\n         * Creates an array of numbers that contains an arithmetic progression.\n         *\n         * @param {number} start initial term\n         * @param {number} end upper bound (inclusive)\n         * @param {number} step step between consecutive terms\n         *\n         * @return {Array} the arithmetic progression\n         */\n        range: function (start, end, step) {\n            if (start === end)\n                return [start];\n            var array = [];\n            var current = start;\n            var sgn = end >= start ? 1 : -1;\n            if (!step)\n                step = sgn;\n            var stepsgn = step >= 0 ? 1 : -1;\n            if (stepsgn != sgn || step === 0)\n                return array;\n            while (start <= end ? current <= end : current >= end) {\n                array.push(current);\n                current += step;\n            }\n            return array;\n        },\n        /**\n         * Generates random integer between min and max\n         *\n         * @param {int} min minimum value for random integer\n         * @param {int} max maximum value for random integer\n         *\n         * @return {int} the random integer\n         */\n        randomInt: function (min, max) {\n            if (!max) {\n                max = min;\n                min = 0;\n            }\n            return Math.floor(Math.random() * (max - min + 1) + min);\n        }\n    };\n});\n\nScoped.define(\"module:Tokens\", function () {\n    /**\n     * Unique Token Generation\n     *\n     * @module BetaJS.Tokens\n     */\n    return {\n        /**\n         * Generates a random token\n         *\n         * @param {integer} length optional length of token, default is 16\n         * @return {string} generated token\n         */\n        generate_token: function (length) {\n            if (length === void 0) { length = 16; }\n            var s = \"\";\n            while (s.length < length)\n                s += Math.random().toString(36).substr(2);\n            return s.substr(0, length);\n        },\n        /**\n         * Generated a simple hash value from a string.\n         *\n         * @param {string} input string\n         * @return {integer} simple hash value\n         * @see http://jsperf.com/string-hashing-methods\n         */\n        simple_hash: function (s) {\n            if (s.length == 0)\n                return 0;\n            var nHash = 0;\n            for (var i = 0; i < s.length; ++i) {\n                nHash = ((nHash << 5) - nHash) + s.charCodeAt(i);\n                nHash = nHash & nHash;\n            }\n            return Math.abs(nHash);\n        }\n    };\n});\n\n}).call(Scoped);","const Net = require('net');\nconst Stream = require('stream');\nconst EventEmitter = require('events');\n\nconst createPseudoProcess = function () {\n    var result = new EventEmitter();\n    result.stderr = new Stream.Readable();\n    result.stderr._read = function () {};\n    result.stdout = new Stream.Readable();\n    result.stdout._read = function () {};\n    result.stdin = new Stream();\n    result.stdin.writable = true;\n    result.stdin.bytes = 0;\n    result.stdin.write = function(buf) {\n        result.stdin.bytes += buf.length;\n    };\n    result.stdin.end = function(buf) {\n        if (buf)\n            result.stdin.write(buf);\n        result.stdin.writable = false;\n    };\n    return result;\n};\n\n\nmodule.exports = {\n\n    run: function (proxy, data) {\n        data = data || {};\n        var myData = {};\n        for (var key in data)\n            myData[key] = data[key];\n        const clientProcess = createPseudoProcess();\n        const socket = new Net.Socket();\n        var killed = false;\n        clientProcess.kill = function () {\n            if (killed)\n                return;\n            killed = true;\n            socket.end();\n            clientProcess.emit(\"close\", null);\n        };\n        const components = proxy.split(\":\");\n        var stdin = \"\";\n        var called = false;\n        clientProcess.stdin.on(\"data\", function (d) {\n            called = true;\n            stdin += d;\n        });\n        var timeout = setTimeout(function () {\n            if (called)\n                return;\n            clientProcess.stdin.emit(\"end\");\n        }, 1000);\n        clientProcess.stdin.on(\"end\", function () {\n            clearTimeout(timeout);\n            socket.connect(parseInt(components[1], 10), components[0], function() {\n                socket.write(JSON.stringify({\n                    data: myData,\n                    stdin: stdin\n                }));\n                var resultData = \"\";\n                socket.on(\"data\", function (data) {\n                    resultData += data;\n                });\n                socket.on(\"end\", function () {\n                    if (killed)\n                        return;\n                    const result = JSON.parse(resultData);\n                    clientProcess.stderr.push(result.stderr);\n                    clientProcess.stderr.push(null);\n                    clientProcess.stdout.push(result.stdout);\n                    clientProcess.stdout.push(null);\n                    clientProcess.emit(\"close\", result.status);\n                });\n            });\n        });\n        return clientProcess;\n    }\n\n};","const FilenameRegex = /([\\.A-Za-z0-9-_]*\\/[\\.A-Za-z0-9-_\\/]+)/g;\nconst FS = require(\"fs\");\nconst Path = require(\"path\");\nconst ChildProcess = require(\"child_process\");\n\nconst chmod = function (mods, filename) {\n    // console.log(\"chmod \" + mods + \" \" + filename);\n    ChildProcess.exec(\"chmod \" + mods + \" \" + filename);\n};\n\nconst chown = function (owner, filename) {\n    // console.log(\"chown \" + owner + \" \" + filename);\n    ChildProcess.exec(\"chown \" + owner + \" \" + filename);\n};\n\n\nmodule.exports = {\n\n    extractFiles: function (args) {\n        var files = {};\n        args.forEach(function (arg) {\n            while (match = FilenameRegex.exec(arg))\n\t\t\t\t\t\t\t\tif (arg.indexOf(\"://\") === -1)\n\t\t\t\t\t\t\t\t\t\tfiles[match[1]] = true;\n        });\n        var result = [];\n        for (var file in files)\n            result.push(file);\n        return result;\n    },\n\n    analyzeFiles: function (files) {\n        var mountMap = {};\n        files.forEach(function (filename) {\n            const originalDirectory = Path.dirname(Path.resolve(filename));\n            mountMap[originalDirectory] = originalDirectory;\n        });\n        for (var sub in mountMap)\n            for (var root in mountMap)\n                if (root.length < mountMap[sub].length && sub.indexOf(root) === 0 && sub.charAt(root.length) === \"/\")\n                    mountMap[sub] = root;\n        var mounts = {};\n        var idx = 0;\n        for (sub in mountMap) {\n            root = mountMap[sub];\n            if (mounts[root])\n                continue;\n            mounts[root] = \"/dockermounts-\" + idx;\n            idx++;\n        }\n        var mappings = {};\n        files.forEach(function (filename, index) {\n            const originalFullName = Path.resolve(filename);\n            const baseName = Path.basename(filename);\n            const originalDirectory = Path.dirname(originalFullName);\n            const exists = FS.existsSync(originalFullName);\n            const dirExists = FS.existsSync(originalDirectory);\n            const stats = exists ? FS.lstatSync(originalFullName) : {};\n            const directoryStats = dirExists ? FS.lstatSync(originalDirectory) : {};\n            const isFile = exists && stats.isFile();\n            const isDirectory = exists && stats.isDirectory();\n            const mountSource = mountMap[originalDirectory];\n            const mountTarget = mounts[mountSource];\n            const mountFullName = mountTarget + originalDirectory.substring(mountSource.length) + \"/\" + baseName;\n            mappings[filename] = {\n                index: index,\n                originalName: filename,\n                originalFullName: originalFullName,\n                originalStats: stats,\n                originalDirectoryStats: directoryStats,\n                baseName: baseName,\n                originalDirectory: originalDirectory,\n                exists: exists,\n                dirExists: dirExists,\n                isFile: isFile,\n                isDirectory: isDirectory,\n                mountSource: mountSource,\n                mountTarget: mountTarget,\n                mountFullName: mountFullName\n            };\n            mounts[mountSource] = mountTarget;\n        });\n        return {\n            mappings: mappings,\n            mounts: mounts\n        };\n    },\n\n    replaceFiles: function (args, files) {\n        return args.map(function (arg) {\n            var result = arg;\n            for (var fileKey in files) {\n                var file = files[fileKey];\n                result = result.replace(file.originalName, file.mountFullName);\n            }\n            return result;\n        });\n    },\n\n    generateMountParameters: function (mounts) {\n        var result = [];\n        for (var mountSource in mounts) {\n            var mountTarget = mounts[mountSource];\n            result.push(\"-v\");\n            result.push(mountSource + \":\" + mountTarget + \":rw\");\n        }\n        return result;\n    },\n\n    ensureOriginalDirectoryExistence: function (files) {\n        for (var fileKey in files) {\n            var file = files[fileKey];\n            // console.log(\"Check\", file);\n            if (file.exists || file.dirExists)\n                continue;\n            // extract all directory tokens into array, reconstruct path and work our way through it\n            var dirs = file.originalDirectory.split(\"/\");\n            var currentDir = \"\";\n            dirs.forEach(function (dir) {\n                currentDir += \"/\" + dir;\n                if (!FS.existsSync(currentDir)) {\n                    // console.log(\"Create Directory\", currentDir);\n                    FS.mkdirSync(currentDir);\n                }\n            });\n        }\n    },\n\n    extractOwns: function (files) {\n        var owns = {};\n        for (var fileKey in files) {\n            var file = files[fileKey];\n            if (file.exists)\n                owns[file.originalFullName] = file.originalStats.uid;\n            owns[file.originalDirectory] = file.originalDirectoryStats.uid;\n        }\n        return owns;\n    },\n\n    extractMods: function (files) {\n        var mods = {};\n        for (var fileKey in files) {\n            var file = files[fileKey];\n            if (file.exists) {\n                var m = file.originalStats.mode;\n                var mode = ((m >> 6) & 7) * 100 + ((m >> 3) & 7) * 10 + ((m >> 0) & 7) * 1;\n                mods[file.originalFullName] = mode;\n            }\n            /*\n            var m = file.originalDirectoryStats.mode;\n            var mode = ((m >> 6) & 7) * 100 + ((m >> 3) & 7) * 10 + ((m >> 0) & 7) * 1;\n            mods[file.originalDirectory] = mode;*/\n        }\n        return mods;\n    },\n\n    restoreOwns: function (owns) {\n        for (var fileName in owns) {\n            chown(owns[fileName], fileName);\n        }\n    },\n\n    restoreMods: function (mods) {\n        for (var fileName in mods) {\n            chmod(mods[fileName], fileName);\n        }\n    },\n\n    changeOwns: function (files, owner) {\n        for (var fileKey in files) {\n            var file = files[fileKey];\n            //if (file.exists)\n                chown(owner, file.originalFullName);\n            chown(owner, file.originalDirectory);\n        }\n    },\n\n    changeMods: function (files, mods) {\n        for (var fileKey in files) {\n            var file = files[fileKey];\n            //if (file.exists)\n                chmod(mods, file.originalFullName);\n            //chmod(mods, file.originalDirectory);\n        }\n    }\n\n};","const Client = require(__dirname + \"/client.js\");\nconst Files = require(__dirname + \"/files.js\");\nconst ChildProcess = require(\"child_process\");\n\n\nmodule.exports = {\n\n    polyfillRun: function (options) {\n        if (options.docker && typeof options.docker === \"string\")\n            options.docker = {container: options.docker};\n        var process;\n        if (options.docker) {\n            options.docker.command = options.command;\n            options.docker.argv = options.argv;\n            process = this.dockerRun(options.docker);\n        } else\n            process = this.nodockerRun(options);\n        if (options.timeout) {\n            var timer = setTimeout(function () {\n                process.emit(\"timeout\");\n                process.kill();\n            }, options.timeout);\n            process.on(\"close\", function () {\n                clearTimeout(timer);\n            });\n        }\n        return process;\n    },\n\n    nodockerRun: function (options) {\n        return ChildProcess.spawn(options.command, options.argv);\n    },\n\n    dockerRun: function (options) {\n        return options.proxy ? this.clientRun(options) : this.localRun(options);\n    },\n\n    clientRun: function (options) {\n        return Client.run(options.proxy, options);\n    },\n\n    localRun: function (options) {\n        options.preprocessFiles = options.preprocessFiles || {};\n        options.postprocessFiles = options.postprocessFiles || {};\n        const container = options.container;\n        // command can be undefined\n        const command = options.command;\n        var argv = options.argv || [];\n        // replace arguments with replacement hash\n        if (options.replaceArguments) {\n            argv = argv.map(function (arg) {\n                for (var replaceFrom in options.replaceArguments) {\n                    var replaceTo = options.replaceArguments[replaceFrom];\n                    arg = arg.replace(new RegExp(replaceFrom, \"g\"), replaceTo);\n                }\n                return arg;\n            });\n        }\n        // extract all file names\n        const files = Files.extractFiles(argv);\n        // analyze files\n        const analyzedFiles = Files.analyzeFiles(files);\n        const fileMounts = analyzedFiles.mounts;\n        const fileMappings = analyzedFiles.mappings;\n        // replace files in arguments\n        argv = Files.replaceFiles(argv, fileMappings);\n        // generate docker mount parameters\n        const mountParameters = Files.generateMountParameters(fileMounts);\n        // generate command line\n        var dockerArgs = [\"run\", \"--rm\"];\n        dockerArgs = dockerArgs.concat(mountParameters);\n        if (command) {\n            dockerArgs.push(\"--entrypoint\");\n            dockerArgs.push(command);\n        }\n        dockerArgs.push(container);\n        dockerArgs = dockerArgs.concat(argv);\n        // not sure why\n        dockerArgs = dockerArgs.join(\" \").split(\" \");\n        // Adjust file permissions and ownership\n        var oldChown, oldMods;\n        if (options.preprocessFiles.mkdirs) {\n            Files.ensureOriginalDirectoryExistence(fileMappings);\n        }\n        if (options.preprocessFiles.chown) {\n            if (options.postprocessFiles.recoverChown)\n                oldChown = Files.extractOwns(fileMappings);\n            Files.changeOwns(fileMappings, options.preprocessFiles.chown);\n        }\n        if (options.preprocessFiles.chmod) {\n            if (options.postprocessFiles.recoverChmod)\n                oldMods = Files.extractMods(fileMappings);\n            Files.changeMods(fileMappings, options.preprocessFiles.chmod);\n        }\n        // Start docker\n        var docker = ChildProcess.spawn(\"docker\", dockerArgs);\n        docker.on(\"close\", function () {\n            // Postprocess Ownership\n            if (options.postprocessFiles.chown)\n                Files.changeOwns(fileMappings, options.postprocessFiles.chown);\n            if (options.postprocessFiles.chmod)\n                Files.changeMods(fileMappings, options.postprocessFiles.chmod);\n            if (oldChown)\n                Files.restoreOwns(oldChown);\n            if (oldMods)\n                Files.restoreMods(oldMods);\n        });\n        return docker;\n    },\n\n    pipeProcesses: function (source, target) {\n        source.stderr.pipe(target.stderr);\n        source.stdout.pipe(target.stdout);\n        target.stdin.pipe(source.stdin);\n        target.stdin.on(\"end\", function () {\n            source.stdin.emit(\"end\");\n        });\n        source.on(\"close\", function (status) {\n            target.exit(status);\n        });\n    }\n\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","Scoped = global.Scoped || require(\"betajs-scoped\");\nBetaJS = global.BetaJS || require(\"betajs\");\nScoped.binding(\"betajs\", \"global:BetaJS\");\n\nmodule.exports = {\n\n\tffprobe: require(__dirname + \"/src/ffprobe.js\").ffprobe,\n\n\tffmpeg: require(__dirname + \"/src/ffmpeg.js\").ffmpeg,\n\n\tffprobe_simple: require(__dirname + \"/src/ffprobe-simple.js\").ffprobe_simple,\n\n\tffmpeg_simple_raw: require(__dirname + \"/src/ffmpeg-simple.js\").ffmpeg_simple_raw,\n\n\tffmpeg_simple: require(__dirname + \"/src/ffmpeg-simple.js\").ffmpeg_simple,\n\n\tffmpeg_faststart: require(__dirname + \"/src/ffmpeg-faststart.js\").ffmpeg_faststart,\n\n\tffmpeg_graceful: require(__dirname + \"/src/ffmpeg-graceful.js\").ffmpeg_graceful,\n\n\tffmpeg_volume_detect: require(__dirname + \"/src/ffmpeg-volume-detect.js\").ffmpeg_volume_detect,\n\n\tffmpeg_test: require(__dirname + \"/src/ffmpeg-test.js\").ffmpeg_test,\n\n\tffmpeg_multi_pass: require(__dirname + \"/src/ffmpeg-multi-pass.js\").ffmpeg_multi_pass,\n\n\tffmpeg_playlist: require(__dirname + \"/src/ffmpeg-playlist.js\").ffmpeg_playlist,\n\n\tffmpeg_playlist_raw: require(__dirname + \"/src/ffmpeg-playlist.js\").ffmpeg_playlist_raw\n\n};","Scoped.require([\n\t\"betajs:Promise\",\n\t\"betajs:Types\",\n\t\"betajs:Objs\"\n], function(Promise, Types, Objs) {\n\n\tvar ffmpeg = require(__dirname + \"/ffmpeg.js\");\n\tvar helpers = require(__dirname + \"/ffmpeg-helpers.js\");\n\tmodule.exports = {\n\n\t\tffmpeg_faststart: function(file, output, eventCallback, eventContext, opts) {\n\t\t\tconst options = [];\n\t\t\toptions.push(\"-c copy\");\n\t\t\toptions.push(helpers.paramsFastStart);\n\t\t\treturn ffmpeg.ffmpeg(file, options, output, eventCallback, eventContext, opts);\n\t\t}\n\n\t};\n\n});\n\n","Scoped.require([\n    \"betajs:Promise\",\n    \"betajs:Types\",\n    \"betajs:Objs\"\n], function (Promise, Types, Objs) {\n\t\n    var ffmpeg_simple = require(__dirname + \"/ffmpeg-simple.js\");\n    var tmp = require('tmp');\n\t\n\tmodule.exports = {\n\t\t\t \n\t\tffmpeg_graceful: function (files, options, output, eventCallback, eventContext, opts) {\n\t\t\toptions = options || {};\n\t\t\treturn ffmpeg_simple.ffmpeg_simple(files, options, output, eventCallback, eventContext, opts).mapError(function (err) {\n\t\t\t\tif ((Types.is_array(files) && files.length > 1) || options.output_type === 'audio' || options.output_type === \"image\")\n\t\t\t\t\treturn err;\n\n                var promise = Promise.create();\n\n                tmp.file({postfix: \".aac\"}, function (err, audioFile, fd, cleanupCallback) {\n                    if (err) {\n                        promise.asyncError(err);\n                        return;\n                    }\n                    promise.callback(function () {\n                        cleanupCallback();\n                    });\n                    tmp.file(function (err, videoFile, fd, cleanupCallback) {\n                        if (err) {\n                            promise.asyncError(err);\n                            return;\n                        }\n                        promise.callback(function () {\n                            cleanupCallback();\n                        });\n                        ffmpeg_simple.ffmpeg_simple(files, {output_type: \"audio\"}, audioFile, eventCallback, eventContext, opts).forwardError(promise).success(function () {\n                            ffmpeg_simple.ffmpeg_simple(files, {output_type: \"video\", remove_audio: true }, videoFile, eventCallback, eventContext, opts).forwardError(promise).success(function () {\n                            \tffmpeg_simple.ffmpeg_simple([videoFile, audioFile], options, output, eventCallback, eventContext, opts).forwardCallback(promise);\n                            });\n                        });\n                    });\n                });\n\n                return promise;\n\t\t\t});\n\t\t}\n\t\t\t\n\t};\t\n\t\n});\n\n","Scoped.require([\n    \"betajs:TimeFormat\"                \n], function (TimeFormat) {\n\t\n\tmodule.exports = {\n\t\t\n\t\tparseTimeCode: function (timecode) {\n\t\t\tvar m = /(\\d\\d):(\\d\\d):(\\d\\d)\\.(\\d\\d)/.exec(timecode);\n\t\t\treturn m ? parseInt(m[1], 10) * 60 * 60 + parseInt(m[2], 10) * 60 + parseInt(m[3], 10) + parseInt(m[4], 10) / 100 : null;\n\t\t},\n\t\t\n\t\tformatTimeCode: function (seconds) {\n\t\t\treturn TimeFormat.format(\"HH:MM:ss.L\", Math.floor(seconds * 1000));\n\t\t},\n\t\t\n\t\tvideoFormats: {\n\t\t\t\"mp4\": {\n\t\t\t\tbframes: true,\n\t\t\t\tacodec: [\"libfaac\", \"libfdk_aac\", \"libvo_aacenc\", \"aac\"],\n\t\t\t\tvcodec: \"libx264\",\n\t\t\t\tfmt: \"mp4\",\n\t\t\t\tpasses: 2,\n\t\t\t\tmodulus: 2,\n\t\t\t\tparams: \"-pix_fmt yuv420p\"\n\t\t\t},\n\t\t\t\"mp4-av1\": {\n\t\t\t\tbframes: true,\n\t\t\t\tacodec: [\"aac\", \"libfaac\", \"libfdk_aac\", \"libvo_aacenc\"],\n\t\t\t\tvcodec: \"av1\",\n\t\t\t\tfmt: \"mp4\",\n\t\t\t\tpasses: 2,\n\t\t\t\tmodulus: 2,\n\t\t\t\tparams: \"-strict experimental\"\n\t\t\t},\n\t\t\t\"avi\": {\n\t\t\t\tbframes: true,\n\t\t\t\tacodec: [\"aac\", \"libfdk_aac\", \"libfaac\", \"libvo_aacenc\"],\n\t\t\t\tvcodec: \"libaom-av1\",\n\t\t\t\tfmt: \"avi\",\n\t\t\t\tpasses: 2,\n\t\t\t\tmodulus: 2,\n\t\t\t\tparams: \"-strict experimental\"\n\t\t\t},\n\t\t\t\"m3u8\": {\n\t\t\t\tbframes: true,\n\t\t\t\tacodec: \"aac\",\n\t\t\t\tvcodec: \"h264\",\n\t\t\t\tpasses: 2,\n\t\t\t\tmodulus: 2\n\t\t\t},\n\t\t\t\"ogg\": {\n\t\t\t\tbframes: true,\n\t\t\t\tacodec: \"libvorbis\",\n\t\t\t\tvcodec: \"libtheora\"\n\t\t\t},\n\t\t\t\"webm\": {\n\t\t\t\tbframes: true,\n\t\t\t\tacodec: \"libvorbis\",\n\t\t\t\tvcodec: \"libvpx\",\n\t\t\t\tfmt: \"webm\"\n\t\t\t},\n\t\t\t\"wmv\": {\n\t\t\t\tacodec: \"wmav2\",\n\t\t\t\tvcodec: \"wmv2\"\n\t\t\t},\n\t\t\t\"wmv3\": {\n\t\t\t\tacodec: \"wmav3\",\n\t\t\t\tvcodec: \"wmv3\"\n\t\t\t},\n\t\t\t\"flv\": {\n\t\t\t\tfmt: \"flv\",\n\t\t\t\tparams: \"-ar 44100\"\n\t\t\t}\n\t\t},\n\t\t\n\t\tparamsSynchronize: \"-async 1 -metadata:s:v:0 start_time=0\",\n\t\t\n\t\tparamsAudioOnly: \"-vn\",\n\t\t\n\t\tparamsFormatImage: \"-f image2\",\n\t\t\t\n\t\tparamsVideoMap: function (index) { return \"-map \" + \"0:\" + index; },\n\t\t\n\t\tparamsAudioMap: function (index) { return \"-map \" + \"1:\" + index; },\n\t\t\n\t\tparamsVideoCodecUniversalConfig: \"-refs 6 -coder 1 -sc_threshold 40 -flags +loop -me_range 16 -subq 7 -i_qfactor 0.71 -qcomp 0.6 -qdiff 4 -trellis 1\",\n\t\t\n\t\tparamsTimeDuration: function (time_start, time_end, time_limit) {\n\t\t\tvar args = [];\n\t\t\tif (time_start) {\n\t\t\t\targs.push(\"-ss\");\n\t\t\t\targs.push(this.formatTimeCode(time_start));\n\t\t\t}\n\t\t\tif (time_end) {\n\t\t\t\targs.push(\"-to\");\n\t\t\t\targs.push(this.formatTimeCode(time_end));\n\t\t\t}\n\t\t\tif (time_limit)  {\n\t\t\t\targs.push(\"-t\");\n\t\t\t\targs.push(this.formatTimeCode((time_start || 0) + time_limit));\n\t\t\t}\n\t\t\treturn args.join(\" \");\n\t\t},\n\t\t\n\t\tparamsFramerate: function (framerate, bframes, framerate_gop) {\n\t\t\treturn \"-r \" + framerate + (bframes ? \" -b_strategy 1 -bf 3 -g \" + framerate_gop : \"\");\n\t\t},\n\t\t\n\t\tparamsVideoProfile: function (video_profile) {\n\t\t\treturn \"-profile:v \" + video_profile;\n\t\t},\n\t\t\n\t\tparamsFastStart: \"-movflags +faststart\",\n\t\t\n\t\tparamsVideoFormat: function (fmt, vcodec, acodec, params) {\n\t\t\tvar args = [];\n\t\t\tif (fmt) {\n\t\t\t\targs.push(\"-f\");\n\t\t\t\targs.push(fmt);\n\t\t\t}\n\t\t\tif (vcodec) {\n\t\t\t\targs.push(\"-vcodec\");\n\t\t\t\targs.push(vcodec);\n\t\t\t}\n\t\t\tif (acodec) {\n\t\t\t\targs.push(\"-acodec\");\n\t\t\t\targs.push(acodec);\n\t\t\t}\n\t\t\tif (params)\n\t\t\t\targs.push(params);\n\t\t\treturn args.join(\" \");\n\t\t},\n\t\t\n\t\tparamsImageExtraction: function (image_position, image_percentage, duration) {\n\t\t\tvar args = [];\n\t\t\targs.push(\"-ss\");\n\t\t\tif (image_position !== null)\n\t\t\t\targs.push(this.formatTimeCode(image_position));\n\t\t\telse if (image_percentage !== null)\n\t\t\t\targs.push(this.formatTimeCode(image_percentage * duration));\n\t\t\telse\n\t\t\t\targs.push(this.formatTimeCode(0.5 * duration));\n\t\t\targs.push(\"-vframes\");\n\t\t\targs.push(\"1\");\n\t\t\treturn args.join(\" \");\n\t\t},\n\t\t\n\t\tparamsHighQualityGif: function (options) {\n\t\t\tvar args = [];\n\t\t\targs.push(\"-filter_complex [0:v]\");\n\t\t\tif (options.framerate)\n\t\t\t\targs.push(\"fps=\" + options.framerate + \",\");\n\t\t\tif (options.width || options.height)\n\t\t\t\targs.push(\"scale=w=\" + (options.width || -1) + \":h=\" + (options.height || -1) + \":flags=lanczos,\");\n\t\t\targs.push(\"split[a][b];[a]palettegen[p];[b][p]paletteuse\");\n\t\t\treturn args.join(\"\");\n\t\t},\n\t\t\n\t\tparseProgress: function (progress, duration) {\n\t\t\tvar raw = {};\n\t\t\tif (progress.frame)\n\t\t\t\traw.frame = parseInt(progress.frame, 10);\n\t\t\tif (progress.fps)\n\t\t\t\traw.fps = parseFloat(progress.fps);\n\t\t\tif (progress.q)\n\t\t\t\traw.q = parseFloat(progress.q);\n\t\t\tif (progress.size)\n\t\t\t\traw.size_kb = parseInt(progress.size, 10);\n\t\t\tif (progress.bitrate)\n\t\t\t\traw.bitrate_kbits = parseFloat(progress.bitrate);\n\t\t\tif (progress.dup)\n\t\t\t\traw.dup = parseInt(progress.dup, 10);\n\t\t\tif (progress.drop)\n\t\t\t\traw.drop = parseInt(progress.drop, 10);\n\t\t\tif (progress.time) \n\t\t\t\traw.time = this.parseTimeCode(progress.time);\n\t\t\traw.pass = progress.pass || 1;\n\t\t\traw.passes = progress.passes || 1;\n\t\t\tif (duration && raw.time)\n\t\t\t\traw.progress = (raw.pass - 1) / raw.passes + raw.time / duration / raw.passes;\n\t\t\treturn raw;\n\t\t},\n\n\t\tcomputeDuration: function (duration, time_start, time_end, time_limit) {\n\t\t\ttime_end = time_end > 0 && time_end < duration ? time_end : duration;\n\t\t\ttime_start = time_start > 0 ? Math.min(time_start, duration) : 0;\n\t\t\tduration = Math.max(time_end - time_start, 0);\n\t\t\tif (time_limit)\n\t\t\t\tduration = Math.min(duration, time_limit);\n\t\t\treturn duration;\n\t\t}\n\n\t};\n\t\n});","Scoped.require([\n    \"betajs:Promise\",\n    \"betajs:Types\",\n    \"betajs:Objs\"\n], function (Promise, Types, Objs) {\n\t\n\tvar ffmpeg = require(__dirname + \"/ffmpeg.js\");\n\tvar tmp = require('tmp');\n\t\n\tmodule.exports = {\n\t\t\t \n\t\tffmpeg_multi_pass: function (files, options, passes, output, eventCallback, eventContext, opts) {\n\t\t\toptions = options || [];\n\n\t\t\tif (passes === 1)\n\t\t\t\treturn ffmpeg.ffmpeg(files, options, output, eventCallback, eventContext, opts);\n\t\t\t \n\t\t\tvar promise = Promise.create();\n\t\t\t\n\t\t\ttmp.file(function (err, path, fd, cleanupCallback) {\n\t\t\t\tif (err) {\n\t\t\t\t\tpromise.asyncError(err);\n\t\t\t\t\treturn;\n\t\t\t    }\n\t\t\t\tpromise.callback(function () {\n\t\t\t\t\tcleanupCallback();\n\t\t\t\t});\n\t\t\t\tffmpeg.ffmpeg(files, options.concat([\n\t                '-pass',\n\t                '1',\n\t                '-passlogfile',\n\t                path\n\t            ]), output, function (progress) {\n\t\t\t\t\tprogress.pass = 1;\n\t\t\t\t\tprogress.passes = 2;\n\t\t\t\t\tif (eventCallback)\n\t\t\t\t\t\teventCallback.call(this, progress);\n\t\t\t\t}, this, opts).forwardError(promise).success(function () {\n\t\t\t\t\tffmpeg.ffmpeg(files, options.concat([\n     \t                '-pass',\n    \t                '2',\n    \t                '-passlogfile',\n    \t                path\n                    ]), output, function (progress) {\n\t\t\t\t\t\tprogress.pass = 2;\n\t\t\t\t\t\tprogress.passes = 2;\n\t\t\t\t\t\tif (eventCallback)\n\t\t\t\t\t\t\teventCallback.call(this, progress);\n\t\t\t\t\t}, this, opts).forwardCallback(promise);\n\t\t\t\t}, this);\n\t\t\t});\n\t\t\t\t\n\t\t\treturn promise;\n\t\t}\n\t\t\t\n\t};\n\t\n});\n\n","Scoped.require([\n\t\"betajs:Promise\",\n\t\"betajs:Types\",\n\t\"betajs:Objs\"\n], function(Promise, Types, Objs) {\n\tconst FS = require(\"fs\");\n\n\tvar ffmpeg_multi_pass = require(__dirname + \"/ffmpeg-multi-pass.js\");\n\tvar ffprobe_simple = require(__dirname + \"/ffprobe-simple.js\");\n\tvar ffmpeg_volume_detect = require(__dirname + \"/ffmpeg-volume-detect.js\");\n\tvar helpers = require(__dirname + \"/ffmpeg-helpers.js\");\n\tvar ffmpeg_test = require(__dirname + \"/ffmpeg-test.js\");\n\n\tmodule.exports = {\n\n\t\tffmpeg_playlist: function(files, options, output, eventCallback, eventContext, opts) {\n\t\t\treturn this.ffmpeg_playlist_raw(files, options, output, eventCallback, eventContext, opts).mapError(function(e) {\n\t\t\t\tif (e.logs) {\n\t\t\t\t\tif (e.logs.indexOf(\"Too many packets buffered for output stream\") >= 0 && !options.maxMuxingQueueSize) {\n\t\t\t\t\t\toptions.maxMuxingQueueSize = true;\n\t\t\t\t\t\treturn this.ffmpeg_playlist_raw(files, options, output, eventCallback, eventContext, opts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t}, this);\n\t\t},\n\n\t\tffmpeg_playlist_raw: function(files, options, output, eventCallback, eventContext, opts) {\n\t\t\topts = opts || {};\n\t\t\tif (Types.is_string(files))\n\t\t\t\tfiles = [files];\n\t\t\toptions = Objs.extend({\n\t\t\t\toutput_type: \"video\", // video, audio, image\n\t\t\t\tsynchronize: true,\n\t\t\t\tframerate: 25, // null\n\t\t\t\tframerate_gop: 250,\n\t\t\t\timage_percentage: null,\n\t\t\t\timage_position: null,\n\t\t\t\ttime_limit: null,\n\t\t\t\ttime_start: 0,\n\t\t\t\ttime_end: null,\n\t\t\t\tvideo_map: null, //0,1,2,...\n\t\t\t\taudio_map: null, //0,1,2\n\t\t\t\tvideo_profile: \"baseline\",\n\t\t\t\tfaststart: true,\n\t\t\t\tvideo_format: \"m3u8\",\n\n\t\t\t\taudio_bit_rate: null,\n\t\t\t\tvideo_bit_rate: null,\n\n\t\t\t\tnormalize_audio: false,\n\t\t\t\tremove_audio: false,\n\t\t\t\twidth: null,\n\t\t\t\theight: null,\n\t\t\t\tauto_rotate: true,\n\t\t\t\trotate: null,\n\n\t\t\t\tratio_strategy: \"fixed\", // \"shrink\", \"stretch\"\n\t\t\t\tsize_strategy: \"keep\", // \"shrink\", \"stretch\"\n\t\t\t\tshrink_strategy: \"shrink-pad\", // \"crop\", \"shrink-crop\"\n\t\t\t\tstretch_strategy: \"pad\", // \"stretch-pad\", \"stretch-crop\"\n\t\t\t\tmixed_strategy: \"shrink-pad\", // \"stretch-crop\", \"crop-pad\"\n\n\t\t\t\twatermark: null,\n\t\t\t\twatermark_size: 0.25,\n\t\t\t\twatermark_x: 0.95,\n\t\t\t\twatermark_y: 0.95,\n\n\t\t\t\twatermarks: [],\n\n\t\t\t\tmaxMuxingQueueSize: false,\n\n\t\t\t\tsegment_target_duration: 4,\n\t\t\t\tmax_bitrate_ratio: 1.07,\n\t\t\t\trate_monitor_buffer_ratio: 1.5,\n\t\t\t\tkey_frames_interval: 25,\n\t\t\t\trenditions: [\n\t\t\t\t\t{resolution: \"640x360\", bitrate: 800, audio_rate: 96},\n\t\t\t\t\t{resolution: \"842x480\", bitrate: 1400, audio_rate: 128},\n\t\t\t\t\t{resolution: \"1280x720\", bitrate: 2800, audio_rate: 128},\n\t\t\t\t\t{resolution: \"1920x1080\", bitrate: 5000, audio_rate: 192}\n\t\t\t\t]\n\t\t\t}, options);\n\n\t\t\tvar promises = files.map(function(file) {\n\t\t\t\treturn ffprobe_simple.ffprobe_simple(file, opts);\n\t\t\t});\n\n\t\t\tif (options.watermark) {\n\t\t\t\toptions.watermarks.unshift({\n\t\t\t\t\twatermark: options.watermark,\n\t\t\t\t\twatermark_size: options.watermark_size,\n\t\t\t\t\twatermark_x: options.watermark_x,\n\t\t\t\t\twatermark_y: options.watermark_y\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (options.normalize_audio)\n\t\t\t\tpromises.push(ffmpeg_volume_detect.ffmpeg_volume_detect(files[options.audio_map || files.length - 1], opts));\n\t\t\toptions.watermarks.forEach(function(wm) {\n\t\t\t\tpromises.push(ffprobe_simple.ffprobe_simple(wm.watermark, opts));\n\t\t\t}, this);\n\t\t\tif (opts.test_ffmpeg)\n\t\t\t\tpromises.push(ffmpeg_test.ffmpeg_test(opts));\n\n\t\t\treturn Promise.and(promises).mapSuccess(function(infos) {\n\n\t\t\t\tvar testInfo = opts.test_info || {};\n\t\t\t\tif (opts.test_ffmpeg)\n\t\t\t\t\ttestInfo = infos.pop();\n\n\t\t\t\tvar watermarkInfos = [];\n\t\t\t\toptions.watermarks.forEach(function() {\n\t\t\t\t\twatermarkInfos.unshift(infos.pop());\n\t\t\t\t});\n\n\t\t\t\tvar audioNormalizationInfo = null;\n\t\t\t\tif (options.normalize_audio)\n\t\t\t\t\taudioNormalizationInfo = infos.pop();\n\n\t\t\t\tvar isImage = infos.length === 1 && infos[0].image && !infos[0].video && !infos[0].audio;\n\n\t\t\t\tvar passes = 1;\n\n\t\t\t\tvar args = [];\n\n\t\t\t\t/*\n\t\t\t\t *\n\t\t\t\t * Synchronize Audio & Video\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif (options.remove_audio) {\n\t\t\t\t\targs.push(\"-an\");\n\t\t\t\t} else if (options.synchronize) {\n\t\t\t\t\targs.push(helpers.paramsSynchronize);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * \n\t\t\t\t * Map Streams\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\tif (infos.length > 1) {\n\t\t\t\t\tvar videoIdx = options.video_map || 0;\n\t\t\t\t\targs.push(\"-map \" + videoIdx + \":\" + infos[videoIdx].video.index);\n\t\t\t\t}\n\t\t\t\tif (infos.length > 1) {\n\t\t\t\t\tvar audioIdx = options.audio_map || 1;\n\t\t\t\t\targs.push(\"-map \" + audioIdx + \":\" + infos[audioIdx].audio.index);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t *\n\t\t\t\t * Audio Normalization?\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\tif (audioNormalizationInfo) {\n\t\t\t\t\targs.push(\"-af\");\n\t\t\t\t\targs.push(\"volume=\" + (-audioNormalizationInfo.max_volume) + \"dB\");\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * \n\t\t\t\t * Which time region should be used?\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\tvar duration = helpers.computeDuration(infos[0].duration, options.time_start, options.time_end,\n\t\t\t\t\t\toptions.time_limit);\n\t\t\t\tif (options.time_start || options.time_end || options.time_limit)\n\t\t\t\t\targs.push(helpers.paramsTimeDuration(options.time_start, options.time_end, options.time_limit));\n\n\t\t\t\tvar videoInfo = infos[0].video;\n\t\t\t\tvar audioInfo = infos[1] ? infos[1].audio || infos[0].audio : infos[0].audio;\n\n\t\t\t\tvar sourceWidth = 0;\n\t\t\t\tvar sourceHeight = 0;\n\t\t\t\tvar targetWidth = 0;\n\t\t\t\tvar targetHeight = 0;\n//try {\n\n\t\t\t\tvar source = infos[0];\n\t\t\t\tvar sourceInfo = source.video || source.image;\n\t\t\t\tvar requiredRotation = 0;\n\t\t\t\tif (options.auto_rotate && !(testInfo.capabilities && testInfo.capabilities.auto_rotate))\n\t\t\t\t\trequiredRotation = sourceInfo.rotation % 360;\n\t\t\t\tif (options.rotate) {\n\t\t\t\t\trequiredRotation = (requiredRotation + options.rotate) % 360;\n\t\t\t\t\tif (options.rotate % 180 === 90) {\n\t\t\t\t\t\tvar temp = sourceInfo.rotated_width;\n\t\t\t\t\t\tsourceInfo.rotated_width = sourceInfo.rotated_height;\n\t\t\t\t\t\tsourceInfo.rotated_height = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsourceWidth = sourceInfo.rotated_width;\n\t\t\t\tsourceHeight = sourceInfo.rotated_height;\n\t\t\t\tvar sourceRatio = sourceWidth / sourceHeight;\n\t\t\t\ttargetWidth = sourceWidth;\n\t\t\t\ttargetHeight = sourceHeight;\n\t\t\t\tvar targetRatio = sourceRatio;\n\t\t\t\tvar ratioSourceTarget = 0;\n\n\t\t\t\t/*\n\t\t\t\t *\n\t\t\t\t * Which sizing should be used?\n\t\t\t\t *\n\t\t\t\t */\n\n\t\t\t\tvar renditionArgs = {};\n\t\t\t\tObjs.iter(options.renditions, function(rendition, i) {\n\t\t\t\t\t// Step 1: Fix Rotation\n\t\t\t\t\trenditionArgs[rendition.resolution] = {};\n\t\t\t\t\tvar vfilters = [];\n\t\t\t\t\tvar sizing = \"\";\n\n\t\t\t\t\tif (requiredRotation !== 0) {\n\t\t\t\t\t\tif (requiredRotation % 180 === 90) {\n\t\t\t\t\t\t\tvfilters.push(\"transpose=\" + (requiredRotation === 90 ? 1 : 2));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (requiredRotation === 180) {\n\t\t\t\t\t\t\tvfilters.push(\"hflip,vflip\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs.push(\"-metadata:s:v:0\");\n\t\t\t\t\t\targs.push(\"rotate=0\");\n\t\t\t\t\t}\n\n\t\t\t\t\tlet widthHeight = rendition.resolution.split(\"x\");\n\t\t\t\t\tlet renditionWidth = Types.parseInt(widthHeight[0]);\n\t\t\t\t\tlet renditionHeight = Types.parseInt(widthHeight[1]);\n\n\t\t\t\t\tvar modulus = options.output_type === \"video\" ? helpers.videoFormats[options.video_format].modulus || 1 : 1;\n\t\t\t\t\tvar modulusAdjust = function(value) {\n\t\t\t\t\t\tvalue = Math.round(value);\n\t\t\t\t\t\treturn value % modulus === 0 ? value : (Math.round(value / modulus) * modulus);\n\t\t\t\t\t};\n\n\t\t\t\t\tif (modulusAdjust(sourceWidth) !== sourceWidth || modulusAdjust(sourceHeight) !== sourceHeight ||\n\t\t\t\t\t\t\trenditionWidth || renditionHeight) {\n\n\t\t\t\t\t\t// Step 2: Fix Size & Ratio\n\t\t\t\t\t\ttargetWidth = renditionWidth || sourceWidth;\n\t\t\t\t\t\ttargetHeight = renditionHeight || sourceHeight;\n\t\t\t\t\t\ttargetRatio = targetWidth / targetHeight;\n\t\t\t\t\t\tratioSourceTarget = Math.sign(sourceWidth * targetHeight - targetWidth * sourceHeight);\n\n\t\t\t\t\t\tif (options.ratio_strategy !== \"fixed\" && ratioSourceTarget !== 0) {\n\t\t\t\t\t\t\tif ((options.ratio_strategy === \"stretch\" && ratioSourceTarget > 0) ||\n\t\t\t\t\t\t\t\t\t(options.ratio_strategy === \"shrink\" && ratioSourceTarget < 0))\n\t\t\t\t\t\t\t\ttargetWidth = targetHeight * sourceRatio;\n\t\t\t\t\t\t\tif ((options.ratio_strategy === \"stretch\" && ratioSourceTarget < 0) ||\n\t\t\t\t\t\t\t\t\t(options.ratio_strategy === \"shrink\" && ratioSourceTarget > 0))\n\t\t\t\t\t\t\t\ttargetHeight = targetWidth / sourceRatio;\n\t\t\t\t\t\t\ttargetRatio = sourceRatio;\n\t\t\t\t\t\t\tratioSourceTarget = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (options.size_strategy === \"shrink\" && targetWidth > sourceWidth && targetHeight > sourceHeight) {\n\t\t\t\t\t\t\ttargetWidth = ratioSourceTarget < 0 ? sourceHeight * targetRatio : sourceWidth;\n\t\t\t\t\t\t\ttargetHeight = ratioSourceTarget >= 0 ? targetWidth / targetRatio : sourceHeight;\n\t\t\t\t\t\t} else if (options.size_strategy === \"stretch\" && targetWidth < sourceWidth && targetHeight <\n\t\t\t\t\t\t\t\tsourceHeight) {\n\t\t\t\t\t\t\ttargetWidth = ratioSourceTarget >= 0 ? sourceHeight * targetRatio : sourceWidth;\n\t\t\t\t\t\t\ttargetHeight = ratioSourceTarget < 0 ? targetWidth / targetRatio : sourceHeight;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar vf = [];\n\n\t\t\t\t\t\t// Step 3: Modulus\n\n\t\t\t\t\t\ttargetWidth = modulusAdjust(targetWidth);\n\t\t\t\t\t\ttargetHeight = modulusAdjust(targetHeight);\n\n\t\t\t\t\t\tvar cropped = false;\n\t\t\t\t\t\tvar addCrop = function(x, y, multi) {\n\t\t\t\t\t\t\tx = Math.round(x);\n\t\t\t\t\t\t\ty = Math.round(y);\n\t\t\t\t\t\t\tif (x === 0 && y === 0)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\tcropped = true;\n\t\t\t\t\t\t\tvar cropWidth = targetWidth - 2 * x;\n\t\t\t\t\t\t\tvar cropHeight = targetHeight - 2 * y;\n\t\t\t\t\t\t\tvfilters.push(\"scale=\" + [\n\t\t\t\t\t\t\t\tmulti || ratioSourceTarget >= 0 ? cropWidth : targetWidth,\n\t\t\t\t\t\t\t\t!multi && ratioSourceTarget >= 0 ? targetHeight : cropHeight].join(\":\"));\n\t\t\t\t\t\t\tvfilters.push(\"crop=\" + [\n\t\t\t\t\t\t\t\t!multi && ratioSourceTarget <= 0 ? cropWidth : targetWidth,\n\t\t\t\t\t\t\t\tmulti || ratioSourceTarget <= 0 ? targetHeight : cropHeight,\n\t\t\t\t\t\t\t\t-x,\n\t\t\t\t\t\t\t\t-y].join(\":\"));\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvar padded = false;\n\t\t\t\t\t\tvar addPad = function(x, y, multi) {\n\t\t\t\t\t\t\tx = Math.round(x);\n\t\t\t\t\t\t\ty = Math.round(y);\n\t\t\t\t\t\t\tif (x === 0 && y === 0)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\tpadded = true;\n\t\t\t\t\t\t\tvar padWidth = targetWidth - 2 * x;\n\t\t\t\t\t\t\tvar padHeight = targetHeight - 2 * y;\n\t\t\t\t\t\t\tvfilters.push(\"scale=\" + [\n\t\t\t\t\t\t\t\tmulti || ratioSourceTarget <= 0 ? padWidth : targetWidth,\n\t\t\t\t\t\t\t\t!multi && ratioSourceTarget <= 0 ? targetHeight : padHeight].join(\":\"));\n\t\t\t\t\t\t\tvfilters.push(\"pad=\" + [\n\t\t\t\t\t\t\t\t!multi && ratioSourceTarget >= 0 ? padWidth : targetWidth,\n\t\t\t\t\t\t\t\tmulti || ratioSourceTarget >= 0 ? targetHeight : padHeight,\n\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\ty].join(\":\"));\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Step 4: Crop & Pad\n\t\t\t\t\t\tif (targetWidth >= sourceWidth && targetHeight >= sourceHeight) {\n\t\t\t\t\t\t\tif (options.stretch_strategy === \"pad\")\n\t\t\t\t\t\t\t\taddPad((targetWidth - sourceWidth) / 2,\n\t\t\t\t\t\t\t\t\t\t(targetHeight - sourceHeight) / 2,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t\telse if (options.stretch_strategy === \"stretch-pad\")\n\t\t\t\t\t\t\t\taddPad(ratioSourceTarget <= 0 ? (targetWidth - targetHeight * sourceRatio) / 2 : 0,\n\t\t\t\t\t\t\t\t\t\tratioSourceTarget >= 0 ? (targetHeight - targetWidth / sourceRatio) / 2 : 0);\n\t\t\t\t\t\t\telse // stretch-crop\n\t\t\t\t\t\t\t\taddCrop(ratioSourceTarget >= 0 ? (targetWidth - targetHeight * sourceRatio) / 2 : 0,\n\t\t\t\t\t\t\t\t\t\tratioSourceTarget <= 0 ? (targetHeight - targetWidth / sourceRatio) / 2 : 0);\n\t\t\t\t\t\t} else if (targetWidth <= sourceWidth && targetHeight <= sourceHeight) {\n\t\t\t\t\t\t\tif (options.shrink_strategy === \"crop\")\n\t\t\t\t\t\t\t\taddCrop((targetWidth - sourceWidth) / 2,\n\t\t\t\t\t\t\t\t\t\t(targetHeight - sourceHeight) / 2,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t\telse if (options.shrink_strategy === \"shrink-crop\")\n\t\t\t\t\t\t\t\taddCrop(ratioSourceTarget >= 0 ? (targetWidth - targetHeight * sourceRatio) / 2 : 0,\n\t\t\t\t\t\t\t\t\t\tratioSourceTarget <= 0 ? (targetHeight - targetWidth / sourceRatio) / 2 : 0);\n\t\t\t\t\t\t\telse // shrink-pad\n\t\t\t\t\t\t\t\taddPad(ratioSourceTarget <= 0 ? (targetWidth - targetHeight * sourceRatio) / 2 : 0,\n\t\t\t\t\t\t\t\t\t\tratioSourceTarget >= 0 ? (targetHeight - targetWidth / sourceRatio) / 2 : 0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (options.mixed_strategy === \"shrink-pad\")\n\t\t\t\t\t\t\t\taddPad(ratioSourceTarget <= 0 ? (targetWidth - targetHeight * sourceRatio) / 2 : 0,\n\t\t\t\t\t\t\t\t\t\tratioSourceTarget >= 0 ? (targetHeight - targetWidth / sourceRatio) / 2 : 0);\n\t\t\t\t\t\t\telse if (options.mixed_strategy === \"stretch-crop\")\n\t\t\t\t\t\t\t\taddCrop(ratioSourceTarget >= 0 ? (targetWidth - targetHeight * sourceRatio) / 2 : 0,\n\t\t\t\t\t\t\t\t\t\tratioSourceTarget <= 0 ? (targetHeight - targetWidth / sourceRatio) / 2 : 0);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// crop-pad\n\t\t\t\t\t\t\t\tcropped = true;\n\t\t\t\t\t\t\t\tpadded = true;\n\t\t\t\t\t\t\t\tvar direction = ratioSourceTarget >= 0;\n\t\t\t\t\t\t\t\tvar dirX = Math.abs(Math.round((sourceWidth - targetWidth) / 2));\n\t\t\t\t\t\t\t\tvar dirY = Math.abs(Math.round((sourceHeight - targetHeight) / 2));\n\t\t\t\t\t\t\t\tvfilters.push(\"crop=\" + [\n\t\t\t\t\t\t\t\t\tdirection ? targetWidth : sourceWidth,\n\t\t\t\t\t\t\t\t\tdirection ? sourceHeight : targetHeight,\n\t\t\t\t\t\t\t\t\tdirection ? dirX : 0,\n\t\t\t\t\t\t\t\t\tdirection ? 0 : dirY].join(\":\"));\n\t\t\t\t\t\t\t\tvfilters.push(\n\t\t\t\t\t\t\t\t\t\t\"pad=\" + [targetWidth, targetHeight, direction ? 0 : dirX, direction ? dirY : 0].join(\":\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!padded && !cropped)\n\t\t\t\t\t\t\trenditionArgs[rendition.resolution].sizing = targetWidth + \"x\" + targetHeight;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvfilters = vfilters.join(\",\");\n\n\t\t\t\t\t/*\n\t\t\t\t\t *\n\t\t\t\t\t * Watermark (depends on sizing)\n\t\t\t\t\t *\n\t\t\t\t\t */\n\n\t\t\t\t\tvar watermarkFilters = options.watermarks.map(function(watermark, i) {\n\t\t\t\t\t\tvar watermarkInfo = watermarkInfos[i];\n\t\t\t\t\t\tvar watermarkMeta = watermarkInfo.image || watermarkInfo.video;\n\t\t\t\t\t\tvar scaleWidth = watermarkMeta.width;\n\t\t\t\t\t\tvar scaleHeight = watermarkMeta.height;\n\t\t\t\t\t\tvar maxWidth = targetWidth * watermark.watermark_size;\n\t\t\t\t\t\tvar maxHeight = targetHeight * watermark.watermark_size;\n\t\t\t\t\t\tif (scaleWidth > maxWidth || scaleHeight > maxHeight) {\n\t\t\t\t\t\t\tvar watermarkRatio = maxWidth * scaleHeight >= maxHeight * scaleWidth;\n\t\t\t\t\t\t\tscaleWidth = watermarkRatio ? watermarkMeta.width * maxHeight / watermarkMeta.height : maxWidth;\n\t\t\t\t\t\t\tscaleHeight = !watermarkRatio ? watermarkMeta.height * maxWidth / watermarkMeta.width : maxHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar posX = watermark.watermark_x * (targetWidth - scaleWidth);\n\t\t\t\t\t\tvar posY = watermark.watermark_y * (targetHeight - scaleHeight);\n\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t\"[prewm\" + i + \"];\",\n\t\t\t\t\t\t\t\"movie=\" + watermark.watermark + \",\",\n\t\t\t\t\t\t\t\"scale=\" + [Math.round(scaleWidth), Math.round(scaleHeight)].join(\":\"),\n\t\t\t\t\t\t\t\"[wm\" + i + \"];\",\n\t\t\t\t\t\t\t\"[prewm\" + i + \"][wm\" + i + \"]\",\n\t\t\t\t\t\t\t\"overlay=\" + [Math.round(posX), Math.round(posY)].join(\":\")\n\t\t\t\t\t\t].join(\"\");\n\t\t\t\t\t}).join(\"\");\n\n\t\t\t\t\tif (watermarkFilters) {\n\t\t\t\t\t\tif (vfilters)\n\t\t\t\t\t\t\tvfilters = \"[in]\" + vfilters + watermarkFilters + \"[out]\";\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tvfilters = watermarkFilters.substring(\"[prewm0];\".length).replace(\"[prewm0]\", \"[in]\") + \"[out]\";\n\t\t\t\t\t}\n\n\t\t\t\t\trenditionArgs[rendition.resolution].vf = vfilters;\n\n\t\t\t\t});\n\t\t\t\t/*\n\t\t\t\t * \n\t\t\t\t * Format\n\t\t\t\t *\n\t\t\t\t */\n\n\t\t\t\tif (options.video_profile && options.video_format === \"mp4\") {\n\t\t\t\t\targs.push(helpers.paramsVideoProfile(options.video_profile));\n\t\t\t\t}\n\t\t\t\tif (options.faststart && options.video_format === \"mp4\") {\n\t\t\t\t\targs.push(helpers.paramsFastStart);\n\t\t\t\t}\n\t\t\t\tvar format = helpers.videoFormats[options.video_format];\n\t\t\t\tif (format && (format.fmt || format.vcodec || format.acodec || format.params)) {\n\t\t\t\t\tvar acodec = format.acodec;\n\t\t\t\t\tif (Types.is_array(acodec)) {\n\t\t\t\t\t\tif (testInfo.encoders) {\n\t\t\t\t\t\t\tvar encoders = Objs.objectify(testInfo.encoders);\n\t\t\t\t\t\t\tacodec = acodec.filter(function(codec) {\n\t\t\t\t\t\t\t\treturn encoders[codec];\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (acodec.length === 0)\n\t\t\t\t\t\t\tacodec = format.acodec;\n\t\t\t\t\t\tacodec = acodec[0];\n\t\t\t\t\t}\n\t\t\t\t\targs.push(helpers.paramsVideoFormat(format.fmt, format.vcodec, acodec, format.params));\n\t\t\t\t}\n\t\t\t\targs.push(...helpers.paramsVideoCodecUniversalConfig.split(\" \"));\n\t\t\t\tif (format && format.passes > 1)\n\t\t\t\t\tpasses = format.passes;\n\n\t\t\t\t// Workaround for https://trac.ffmpeg.org/ticket/6375\n\t\t\t\tif (options.maxMuxingQueueSize) {\n\t\t\t\t\targs.push(\"-max_muxing_queue_size\");\n\t\t\t\t\targs.push(\"9999\");\n\t\t\t\t}\n\n\t\t\t\tlet newArgs = [];\n\t\t\t\tconst target = output;\n\t\t\t\tif (!FS.existsSync(target))\n\t\t\t\t\tFS.mkdirSync(target, {recursive: true});\n\t\t\t\tlet masterPlaylist = \"#EXTM3U\\n#EXT-X-VERSION:3\\n\";\n\t\t\t\tconst keyFramesInterval = options.key_frames_interval;\n\t\t\t\tlet staticParams = `-g ${keyFramesInterval} -keyint_min ${keyFramesInterval} -hls_time ${options.segment_target_duration}`;\n\t\t\t\tstaticParams += ` -hls_playlist_type vod`;\n\t\t\t\tObjs.iter(options.renditions, function(obj, i) {\n\t\t\t\t\tlet resolution = renditionArgs[obj.resolution].sizing ? renditionArgs[obj.resolution].sizing : obj.resolution;\n\t\t\t\t\tlet widthHeight = resolution.split(\"x\");\n\t\t\t\t\tlet width = Types.parseInt(widthHeight[0]);\n\t\t\t\t\tlet height = Types.parseInt(widthHeight[1]);\n\t\t\t\t\tlet maxRate = obj.bitrate * options.max_bitrate_ratio;\n\t\t\t\t\tlet bufSize = obj.bitrate * options.rate_monitor_buffer_ratio;\n\t\t\t\t\tlet bandwidth = obj.bitrate * 1000;\n\t\t\t\t\tlet name = `${height}p`;\n\t\t\t\t\tnewArgs.push(...args);\n\t\t\t\t\tnewArgs.push(...staticParams.split(\" \"));\n\t\t\t\t\tif (renditionArgs[obj.resolution].vf) {\n\t\t\t\t\t\tnewArgs.push(...`-vf ${renditionArgs[obj.resolution].vf}`.split(\" \"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewArgs.push(...`-vf scale=w=${width}:h=${height}:force_original_aspect_ratio=decrease`.split(\" \"));\n\t\t\t\t\t}\n\t\t\t\t\tnewArgs.push(\n\t\t\t\t\t\t\t...`-b:v ${obj.bitrate}k -maxrate ${maxRate}k -bufsize ${bufSize}k -b:a ${obj.audio_rate}k`.split(\" \"));\n\t\t\t\t\tnewArgs.push(...`-hls_segment_filename ${target}/${name}_%03d.ts ${target}/${name}.m3u8`.split(\" \"));\n\t\t\t\t\tmasterPlaylist += `#EXT-X-STREAM-INF:BANDWIDTH=${bandwidth},RESOLUTION=${resolution}\\n${name}.m3u8\\n`;\n\t\t\t\t});\n\t\t\t\treturn ffmpeg_multi_pass.ffmpeg_multi_pass(files, newArgs, passes, null, function(progress) {\n\t\t\t\t\tif (eventCallback)\n\t\t\t\t\t\teventCallback.call(eventContext || this, helpers.parseProgress(progress, duration));\n\t\t\t\t}, this, opts).mapSuccess(function() {\n\t\t\t\t\tFS.writeFileSync(target + \"/playlist.m3u8\", masterPlaylist);\n\t\t\t\t\treturn Promise.value({playlist: target + \"/playlist.m3u8\"});\n\t\t\t\t}, this);\n\t\t\t});\n\n\t\t}\n\n\t};\n\n});\n\n","Scoped.require([\n    \"betajs:Promise\",\n    \"betajs:Types\",\n    \"betajs:Objs\"\n], function (Promise, Types, Objs) {\n\t\n\tvar ffmpeg_multi_pass = require(__dirname + \"/ffmpeg-multi-pass.js\");\n    var ffprobe_simple = require(__dirname + \"/ffprobe-simple.js\");\n    var ffmpeg_volume_detect = require(__dirname + \"/ffmpeg-volume-detect.js\");\n    var helpers = require(__dirname + \"/ffmpeg-helpers.js\");\n    var ffmpeg_test = require(__dirname + \"/ffmpeg-test.js\");\n\t\n\t\n\tmodule.exports = {\n\n\t\tffmpeg_simple: function (files, options, output, eventCallback, eventContext, opts) {\n\t\t\treturn this.ffmpeg_simple_raw(files, options, output, eventCallback, eventContext, opts).mapError(function (e) {\n\t\t\t\tif (e.logs) {\n\t\t\t\t\tif (e.logs.indexOf(\"Too many packets buffered for output stream\") >= 0 && !options.maxMuxingQueueSize) {\n\t\t\t\t\t\toptions.maxMuxingQueueSize = true;\n\t\t\t\t\t\treturn this.ffmpeg_simple_raw(files, options, output, eventCallback, eventContext, opts);\n\t\t\t\t\t}\n\t\t\t\t}\n \t\t\t\treturn e;\n\t\t\t}, this);\n\t\t},\n\t\t\t \n\t\tffmpeg_simple_raw: function (files, options, output, eventCallback, eventContext, opts) {\n\t\t\topts = opts || {};\n\t\t\tif (Types.is_string(files))\n\t\t\t\tfiles = [files];\n\t\t\toptions = Objs.extend({\n\t\t\t\toutput_type: \"video\", // video, audio, image\n\t\t\t\tsynchronize: true,\n\t\t\t\tframerate: 25, // null\n\t\t\t\tframerate_gop: 250,\n\t\t\t\timage_percentage: null,\n\t\t\t\timage_position: null,\n\t\t\t\ttime_limit: null,\n\t\t\t\ttime_start: 0,\n\t\t\t\ttime_end: null,\n\t\t\t\tvideo_map: null, //0,1,2,...\n\t\t\t\taudio_map: null, //0,1,2\n\t\t\t\tvideo_profile: \"baseline\",\n\t\t\t\tfaststart: true,\n\t\t\t\tvideo_format: \"mp4\",\n\t\t\t\t\n\t\t\t\taudio_bit_rate: null,\n\t\t\t\tvideo_bit_rate: null,\n\t\t\t\t\n\t\t\t\tnormalize_audio: false,\n\t\t\t\tremove_audio: false,\n\t\t\t\twidth: null,\n\t\t\t\theight: null,\n\t\t\t\tauto_rotate: true,\n\t\t\t\trotate: null,\n\t\t\t\t\n\t\t\t\tratio_strategy: \"fixed\", // \"shrink\", \"stretch\"\n\t\t\t\tsize_strategy: \"keep\", // \"shrink\", \"stretch\"\n\t\t\t\tshrink_strategy: \"shrink-pad\", // \"crop\", \"shrink-crop\"\n\t\t\t\tstretch_strategy: \"pad\", // \"stretch-pad\", \"stretch-crop\"\n\t\t\t\tmixed_strategy: \"shrink-pad\", // \"stretch-crop\", \"crop-pad\"\n\t\t\t\t\n\t\t\t\twatermark: null,\n\t\t\t\twatermark_size: 0.25,\n\t\t\t\twatermark_x: 0.95,\n\t\t\t\twatermark_y: 0.95,\n\n\t\t\t\twatermarks: [],\n\n\t\t\t\tmaxMuxingQueueSize: false\n\t\t\t}, options);\n\n\t\t\tvar promises = files.map(function (file) {\n\t\t\t\treturn ffprobe_simple.ffprobe_simple(file, opts);\n\t\t\t});\n\n\t\t\tif (options.watermark) {\n\t\t\t\toptions.watermarks.unshift({\n\t\t\t\t\twatermark: options.watermark,\n\t\t\t\t\twatermark_size: options.watermark_size,\n\t\t\t\t\twatermark_x: options.watermark_x,\n\t\t\t\t\twatermark_y: options.watermark_y\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tif (options.normalize_audio)\n\t\t\t\tpromises.push(ffmpeg_volume_detect.ffmpeg_volume_detect(files[options.audio_map || files.length - 1], opts));\n\t\t\toptions.watermarks.forEach(function (wm) {\n\t\t\t\tpromises.push(ffprobe_simple.ffprobe_simple(wm.watermark, opts));\n\t\t\t}, this);\n\t\t\tif (opts.test_ffmpeg)\n\t\t\t\tpromises.push(ffmpeg_test.ffmpeg_test(opts));\n\n\t\t\treturn Promise.and(promises).mapSuccess(function (infos) {\n\n\t\t\t\tvar testInfo = opts.test_info || {};\n\t\t\t\tif (opts.test_ffmpeg)\n\t\t\t\t\ttestInfo = infos.pop();\n\t\t\t\t\n\t\t\t\tvar watermarkInfos = [];\n\t\t\t\toptions.watermarks.forEach(function () {\n\t\t\t\t\twatermarkInfos.unshift(infos.pop());\n\t\t\t\t});\n\n\t\t\t\tvar audioNormalizationInfo = null;\n\t\t\t\tif (options.normalize_audio)\n\t\t\t\t\taudioNormalizationInfo = infos.pop();\n\n\t\t\t\tvar isImage = infos.length === 1 && ((infos[0].image && !infos[0].video && !infos[0].audio) ||\n\t\t\t\t\t(infos[0].video && infos[0].format_default_extension.includes(\"_pipe\")));\n\n\t\t\t\tvar passes = 1;\n\t\t\t\t\n\t\t\t\tvar args = [];\n\n\n\t\t\t\t/*\n\t\t\t\t * \n\t\t\t\t * Synchronize Audio & Video \n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\tif (options.output_type === 'video') {\n\t\t\t\t\tif (options.remove_audio)\n\t\t\t\t\t\targs.push(\"-an\");\n\t\t\t\t\telse if (options.synchronize)\n\t\t\t\t\t\targs.push(helpers.paramsSynchronize);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t * \n\t\t\t\t * Map Streams\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\tif (options.output_type === 'audio') {\n\t\t\t\t\targs.push(helpers.paramsAudioOnly);\n\t\t\t\t} else if (options.output_type === 'video') {\n\t\t\t\t\tif (infos.length > 1) {\n\t\t\t\t\t\tvar videoIdx = options.video_map || 0;\n\t\t\t\t\t\targs.push(\"-map \" + videoIdx + \":\" + infos[videoIdx].video.index);\n                    }\n\t\t\t\t\tif (infos.length > 1) {\n\t\t\t\t\t\tvar audioIdx = options.audio_map || 1;\n\t\t\t\t\t\targs.push(\"-map \" + audioIdx + \":\" + infos[audioIdx].audio.index);\n                    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t *\n\t\t\t\t * Audio Normalization?\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\tif (audioNormalizationInfo) {\n\t\t\t\t\targs.push(\"-af\");\n\t\t\t\t\targs.push(\"volume=\" + (-audioNormalizationInfo.max_volume) + \"dB\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t * \n\t\t\t\t * Which time region should be used?\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\tvar duration = helpers.computeDuration(infos[0].duration, options.time_start, options.time_end, options.time_limit);\n\t\t\t\tif (!isImage) {\n                    if (options.output_type === 'image')\n                        args.push(helpers.paramsImageExtraction(options.image_position, options.image_percentage, duration));\n                    else if (options.time_start || options.time_end || options.time_limit)\n                        args.push(helpers.paramsTimeDuration(options.time_start, options.time_end, options.time_limit));\n                }\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tvar videoInfo = infos[0].video;\n\t\t\t\tif (videoInfo && infos[0].bit_rate && (!videoInfo.bit_rate || infos[0].bit_rate > videoInfo.bit_rate))\n\t\t\t\t\tvideoInfo.bit_rate = infos[0].bit_rate;\n\n\t\t\t\tvar audioInfo = infos[1] ? infos[1].audio || infos[0].audio : infos[0].audio;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tvar sourceWidth = 0;\n\t\t\t\tvar sourceHeight = 0;\n\t\t\t\tvar targetWidth = 0;\n\t\t\t\tvar targetHeight = 0;\n//try {\n\t\t\t\t\n\t\t\t\tif (options.output_type !== 'audio') {\n\t\t\t\t\tvar source = infos[0];\n\t\t\t\t\tvar sourceInfo = source.video || source.image;\n\t\t\t\t\tvar requiredRotation = 0;\n\t\t\t\t\tif (options.auto_rotate && !(testInfo.capabilities && testInfo.capabilities.auto_rotate))\n                        requiredRotation = sourceInfo.rotation % 360;\n\t\t\t\t\tif (options.rotate) {\n                        requiredRotation = (requiredRotation + options.rotate) % 360;\n\t\t\t\t\t\tif (options.rotate % 180 === 90) {\n\t\t\t\t\t\t\tvar temp = sourceInfo.rotated_width;\n                            sourceInfo.rotated_width = sourceInfo.rotated_height;\n                            sourceInfo.rotated_height = temp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsourceWidth = sourceInfo.rotated_width;\n\t\t\t\t\tsourceHeight = sourceInfo.rotated_height;\n\t\t\t\t\tvar sourceRatio = sourceWidth / sourceHeight;\n\t\t\t\t\ttargetWidth = sourceWidth;\n\t\t\t\t\ttargetHeight = sourceHeight;\n\t\t\t\t\tvar targetRatio = sourceRatio;\n\t\t\t\t\tvar ratioSourceTarget = 0;\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t * \n\t\t\t\t\t * Which sizing should be used?\n\t\t\t\t\t * \n\t\t\t\t\t */\n\n\t\t\t\t\t// Step 1: Fix Rotation\n\t\t\t\t\tvar vfilters = [];\n\t\t\t\t\tvar sizing = \"\";\n\t\t\t\t\t\n\t\t\t\t\tif (requiredRotation !== 0) {\n\t\t\t\t\t\tif (requiredRotation % 180 === 90) {\n\t\t\t\t\t\t\tvfilters.push(\"transpose=\" + (requiredRotation === 90 ? 1 : 2));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (requiredRotation === 180) {\n\t\t\t\t\t\t\tvfilters.push(\"hflip,vflip\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs.push(\"-metadata:s:v:0\");\n\t\t\t\t\t\targs.push(\"rotate=0\");\n\t\t\t\t\t}\n\n\t\t\t\t\tvar modulus = options.output_type === 'video' ? helpers.videoFormats[options.video_format].modulus || 1 : 1;\n\t\t\t\t\tvar modulusAdjust = function (value) {\n\t\t\t\t\t\tvalue = Math.round(value);\n\t\t\t\t\t\treturn value % modulus === 0 ? value : (Math.round(value / modulus) * modulus);\n\t\t\t\t\t};\n\n\t\t\t\t\tif (modulusAdjust(sourceWidth) !== sourceWidth || modulusAdjust(sourceHeight) !== sourceHeight || options.width || options.height) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Step 2: Fix Size & Ratio\n\t\t\t\t\t\ttargetWidth = options.width || sourceWidth;\n\t\t\t\t\t\ttargetHeight = options.height || sourceHeight;\n\t\t\t\t\t\ttargetRatio = targetWidth / targetHeight;\n\t\t\t\t\t\tratioSourceTarget = Math.sign(sourceWidth * targetHeight - targetWidth * sourceHeight);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (options.ratio_strategy !== \"fixed\" && ratioSourceTarget !== 0) {\n\t\t\t\t\t\t\tif ((options.ratio_strategy === \"stretch\" && ratioSourceTarget > 0) || (options.ratio_strategy === \"shrink\" && ratioSourceTarget < 0))\n\t\t\t\t\t\t\t\ttargetWidth = targetHeight * sourceRatio;\n\t\t\t\t\t\t\tif ((options.ratio_strategy === \"stretch\" && ratioSourceTarget < 0) || (options.ratio_strategy === \"shrink\" && ratioSourceTarget > 0))\n\t\t\t\t\t\t\t\ttargetHeight = targetWidth / sourceRatio;\n\t\t\t\t\t\t\ttargetRatio = sourceRatio;\n\t\t\t\t\t\t\tratioSourceTarget = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (options.size_strategy === \"shrink\" && targetWidth > sourceWidth && targetHeight > sourceHeight) {\n\t\t\t\t\t\t\ttargetWidth = ratioSourceTarget < 0 ? sourceHeight * targetRatio : sourceWidth;\n\t\t\t\t\t\t\ttargetHeight = ratioSourceTarget >= 0 ? targetWidth / targetRatio : sourceHeight;\n\t\t\t\t\t\t} else if (options.size_strategy === \"stretch\" && targetWidth < sourceWidth && targetHeight < sourceHeight) {\n\t\t\t\t\t\t\ttargetWidth = ratioSourceTarget >= 0 ? sourceHeight * targetRatio : sourceWidth;\n\t\t\t\t\t\t\ttargetHeight = ratioSourceTarget < 0 ? targetWidth / targetRatio : sourceHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar vf = [];\n\n\t\t\t\t\t\t// Step 3: Modulus\n\n\t\t\t\t\t\ttargetWidth = modulusAdjust(targetWidth);\n\t\t\t\t\t\ttargetHeight = modulusAdjust(targetHeight);\n\n\t\t\t\t\t\tvar cropped = false;\n\t\t\t\t\t\tvar addCrop = function (x, y, multi) {\n\t\t\t\t\t\t\tx = Math.round(x);\n\t\t\t\t\t\t\ty = Math.round(y);\n\t\t\t\t\t\t\tif (x === 0 && y === 0)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\tcropped = true;\n\t\t\t\t\t\t\tvar cropWidth = targetWidth - 2 * x;\n\t\t\t\t\t\t\tvar cropHeight = targetHeight - 2 * y;\n\t\t\t\t\t\t\tvfilters.push(\"scale=\" + [multi || ratioSourceTarget >= 0 ? cropWidth : targetWidth, !multi && ratioSourceTarget >= 0 ? targetHeight : cropHeight].join(\":\"));\n\t\t\t\t\t\t\tvfilters.push(\"crop=\" + [!multi && ratioSourceTarget <= 0 ? cropWidth : targetWidth, multi || ratioSourceTarget <= 0 ? targetHeight : cropHeight, -x, -y].join(\":\"));\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvar padded = false;\n\t\t\t\t\t\tvar addPad = function (x, y, multi) {\n\t\t\t\t\t\t\tx = Math.round(x);\n\t\t\t\t\t\t\ty = Math.round(y);\n\t\t\t\t\t\t\tif (x === 0 && y === 0)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\tpadded = true;\n\t\t\t\t\t\t\tvar padWidth = targetWidth - 2 * x;\n\t\t\t\t\t\t\tvar padHeight = targetHeight - 2 * y;\n\t\t\t\t\t\t\tvfilters.push(\"scale=\" + [multi || ratioSourceTarget <= 0 ? padWidth : targetWidth, !multi && ratioSourceTarget <= 0 ? targetHeight : padHeight].join(\":\"));\n\t\t\t\t\t\t\tvfilters.push(\"pad=\" + [!multi && ratioSourceTarget >= 0 ? padWidth : targetWidth, multi || ratioSourceTarget >= 0 ? targetHeight : padHeight, x, y].join(\":\"));\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Step 4: Crop & Pad\n\t\t\t\t\t\tif (targetWidth >= sourceWidth && targetHeight >= sourceHeight) {\n\t\t\t\t\t\t\tif (options.stretch_strategy === \"pad\")\n\t\t\t\t\t\t\t\taddPad((targetWidth - sourceWidth) / 2,\n\t\t\t\t\t\t\t\t\t   (targetHeight - sourceHeight) / 2,\n\t\t\t\t\t\t\t\t\t   true);\n\t\t\t\t\t\t\telse if (options.stretch_strategy === \"stretch-pad\")\n\t\t\t\t\t\t\t\taddPad(ratioSourceTarget <= 0 ? (targetWidth - targetHeight * sourceRatio) / 2 : 0,\n\t\t\t\t\t\t\t\t\t   ratioSourceTarget >= 0 ? (targetHeight - targetWidth / sourceRatio) / 2 : 0);\n\t\t\t\t\t\t\telse // stretch-crop\n\t\t\t\t\t\t\t\taddCrop(ratioSourceTarget >= 0 ? (targetWidth - targetHeight * sourceRatio) / 2 : 0,\n\t\t\t\t\t\t\t\t\t\t   ratioSourceTarget <= 0 ? (targetHeight - targetWidth / sourceRatio) / 2 : 0);\n\t\t\t\t\t\t} else if (targetWidth <= sourceWidth && targetHeight <= sourceHeight) {\n\t\t\t\t\t\t\tif (options.shrink_strategy === \"crop\")\n\t\t\t\t\t\t\t\taddCrop((targetWidth - sourceWidth) / 2,\n\t\t\t\t\t\t\t\t\t    (targetHeight - sourceHeight) / 2,\n\t\t\t\t\t\t\t\t\t    true);\n\t\t\t\t\t\t\telse if (options.shrink_strategy === \"shrink-crop\")\n\t\t\t\t\t\t\t\taddCrop(ratioSourceTarget >= 0 ? (targetWidth - targetHeight * sourceRatio) / 2 : 0,\n\t\t\t\t\t\t\t\t\t   ratioSourceTarget <= 0 ? (targetHeight - targetWidth / sourceRatio) / 2 : 0);\n\t\t\t\t\t\t\telse // shrink-pad\n\t\t\t\t\t\t\t\taddPad(ratioSourceTarget <= 0 ? (targetWidth - targetHeight * sourceRatio) / 2 : 0,\n\t\t\t\t\t\t\t\t\t\t   ratioSourceTarget >= 0 ? (targetHeight - targetWidth / sourceRatio) / 2 : 0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (options.mixed_strategy === \"shrink-pad\")\n\t\t\t\t\t\t\t\taddPad(ratioSourceTarget <= 0 ? (targetWidth - targetHeight * sourceRatio) / 2 : 0,\n\t\t\t\t\t\t\t\t\t\t   ratioSourceTarget >= 0 ? (targetHeight - targetWidth / sourceRatio) / 2 : 0);\n\t\t\t\t\t\t\telse if (options.mixed_strategy === \"stretch-crop\")\n\t\t\t\t\t\t\t\taddCrop(ratioSourceTarget >= 0 ? (targetWidth - targetHeight * sourceRatio) / 2 : 0,\n\t\t\t\t\t\t\t\t\t\t   ratioSourceTarget <= 0 ? (targetHeight - targetWidth / sourceRatio) / 2 : 0);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// crop-pad\n\t\t\t\t\t\t\t\tcropped = true;\n\t\t\t\t\t\t\t\tpadded = true;\n\t\t\t\t\t\t\t\tvar direction = ratioSourceTarget >= 0;\n\t\t\t\t\t\t\t\tvar dirX = Math.abs(Math.round((sourceWidth - targetWidth) / 2));\n\t\t\t\t\t\t\t\tvar dirY = Math.abs(Math.round((sourceHeight - targetHeight) / 2));\n\t\t\t\t\t\t\t\tvfilters.push(\"crop=\" + [direction ? targetWidth : sourceWidth, direction ? sourceHeight : targetHeight, direction ? dirX : 0, direction ? 0 : dirY].join(\":\"));\n\t\t\t\t\t\t\t\tvfilters.push(\"pad=\" + [targetWidth, targetHeight, direction ? 0 : dirX, direction ? dirY : 0].join(\":\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!padded && !cropped)\n\t\t\t\t\t\t\tsizing = targetWidth + \"x\" + targetHeight;\n\n\t\t\t\t\t}\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tvfilters = vfilters.join(\",\");\n\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t * \n\t\t\t\t\t * Watermark (depends on sizing)\n\t\t\t\t\t * \n\t\t\t\t\t */\n\n\t\t\t\t\tvar watermarkFilters = options.watermarks.map(function (watermark, i) {\n\t\t\t\t\t\tvar watermarkInfo = watermarkInfos[i];\n\t\t\t\t\t\tvar watermarkMeta = watermarkInfo.image || watermarkInfo.video;\n\t\t\t\t\t\tvar scaleWidth = watermarkMeta.width;\n\t\t\t\t\t\tvar scaleHeight = watermarkMeta.height;\n\t\t\t\t\t\tvar maxWidth = targetWidth * watermark.watermark_size;\n\t\t\t\t\t\tvar maxHeight = targetHeight * watermark.watermark_size;\n\t\t\t\t\t\tif (scaleWidth > maxWidth || scaleHeight > maxHeight) {\n\t\t\t\t\t\t\tvar watermarkRatio = maxWidth * scaleHeight >= maxHeight * scaleWidth;\n\t\t\t\t\t\t\tscaleWidth = watermarkRatio ? watermarkMeta.width * maxHeight / watermarkMeta.height : maxWidth;\n\t\t\t\t\t\t\tscaleHeight = !watermarkRatio ? watermarkMeta.height * maxWidth / watermarkMeta.width : maxHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar posX = watermark.watermark_x * (targetWidth - scaleWidth);\n\t\t\t\t\t\tvar posY = watermark.watermark_y * (targetHeight - scaleHeight);\n\n\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t\"[prewm\" + i + \"];\",\n\t\t\t\t\t\t\t\"movie=\" + watermark.watermark + \",\",\n\t\t\t\t\t\t\t\"scale=\" + [Math.round(scaleWidth), Math.round(scaleHeight)].join(\":\"),\n\t\t\t\t\t\t\t\"[wm\" + i + \"];\",\n\t\t\t\t\t\t\t\"[prewm\" + i + \"][wm\" + i + \"]\",\n\t\t\t\t\t\t\t\"overlay=\" + [Math.round(posX), Math.round(posY)].join(\":\")\n\t\t\t\t\t\t].join(\"\");\n\t\t\t\t\t}).join(\"\");\n\n\t\t\t\t\tif (watermarkFilters) {\n\t\t\t\t\t\tif (vfilters)\n\t\t\t\t\t\t\tvfilters = \"[in]\" + vfilters + watermarkFilters + \"[out]\";\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tvfilters = watermarkFilters.substring(\"[prewm0];\".length).replace(\"[prewm0]\", \"[in]\") + \"[out]\";\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t\t// Video Filters\n\t\t\t\t\tif (vfilters && options.output_type !== \"gif\") {\n\t\t\t\t\t\targs.push(\"-vf\");\n\t\t\t\t\t\targs.push(vfilters);\n\t\t\t\t\t}\n\t\t\t\t\tif (sizing) {\n\t\t\t\t\t\targs.push(\"-s\");\n\t\t\t\t\t\targs.push(sizing);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t * \n\t\t\t\t * Format\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\tif (options.output_type === 'image')\n\t\t\t\t\targs.push(helpers.paramsFormatImage);\n\t\t\t\tif (options.output_type === 'video') {\n\t\t\t\t\tif (options.video_profile && options.video_format === \"mp4\")\n\t\t\t\t\t\targs.push(helpers.paramsVideoProfile(options.video_profile));\n\t\t\t\t\tif (options.faststart && options.video_format === \"mp4\")\n\t\t\t\t\t\targs.push(helpers.paramsFastStart);\n\t\t\t\t\tvar format = helpers.videoFormats[options.video_format];\n\t\t\t\t\tif (format && (format.fmt || format.vcodec || format.acodec || format.params)) {\n\t\t\t\t\t\tvar acodec = format.acodec;\n\t\t\t\t\t\tif (Types.is_array(acodec)) {\n\t\t\t\t\t\t\tif (testInfo.encoders) {\n\t\t\t\t\t\t\t\tvar encoders = Objs.objectify(testInfo.encoders);\n\t\t\t\t\t\t\t\tacodec = acodec.filter(function (codec) {\n\t\t\t\t\t\t\t\t\treturn encoders[codec];\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (acodec.length === 0)\n\t\t\t\t\t\t\t\tacodec = format.acodec;\n\t\t\t\t\t\t\tacodec = acodec[0];\n\t\t\t\t\t\t}\n                        args.push(helpers.paramsVideoFormat(format.fmt, format.vcodec, acodec, format.params));\n                    }\n\t\t\t\t\tif (options.framerate)\n\t\t\t\t\t\targs.push(helpers.paramsFramerate(options.framerate, format.bframes, options.framerate_gop));\n\t\t\t\t\targs.push(helpers.paramsVideoCodecUniversalConfig);\n\t\t\t\t\tif (format && format.passes > 1)\n\t\t\t\t\t\tpasses = format.passes;\n\t\t\t\t}\n\t\t\t\tif (options.output_type === \"gif\") {\n\t\t\t\t\targs.push(helpers.paramsHighQualityGif({\n\t\t\t\t\t\t\"width\": options.width,\n\t\t\t\t\t\t\"height\": options.height,\n\t\t\t\t\t\t\"framerate\": options.framerate\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t * \n\t\t\t\t * Bit rate (depends on watermark + sizing)\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\tif (options.output_type === \"video\") {\n\t\t\t\t\targs.push(\"-b:v\");\n\t\t\t\t\tvar video_bit_rate = options.video_bit_rate;\n\t\t\t\t\tif (!video_bit_rate && videoInfo.bit_rate)\n\t\t\t\t\t\tvideo_bit_rate = videoInfo.bit_rate * Math.min(Math.max(targetWidth * targetHeight / sourceWidth / sourceHeight, 0.25), 4);\n\t\t\t\t\tif (!video_bit_rate)\n\t\t\t\t\t\tvideo_bit_rate = Math.round(1000 * (targetWidth + targetHeight) / 2);\n\t\t\t\t\targs.push(Math.round(video_bit_rate / 1000) + \"k\");\n\t\t\t\t\tif (audioInfo) {\n\t\t\t\t\t\targs.push(\"-b:a\");\n\t\t\t\t\t\tvar audio_bit_rate = options.audio_bit_rate || Math.max(audioInfo.bit_rate || 64000, 64000);\n\t\t\t\t\t\targs.push(Math.round(audio_bit_rate / 1000) + \"k\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Workaround for https://trac.ffmpeg.org/ticket/6375\n\t\t\t\tif (options.maxMuxingQueueSize) {\n\t\t\t\t\targs.push(\"-max_muxing_queue_size\");\n\t\t\t\t\targs.push(\"9999\");\n\t\t\t\t}\n\n//} catch(e) {console.log(e);}\n\n//console.log(files, args, passes, output);\n\t\t\t\treturn ffmpeg_multi_pass.ffmpeg_multi_pass(files, args, passes, output, function (progress) {\n\t\t\t\t\tif (eventCallback)\n\t\t\t\t\t\teventCallback.call(eventContext || this, helpers.parseProgress(progress, duration));\n\t\t\t\t}, this, opts).mapSuccess(function () {\n\t\t\t\t\treturn ffprobe_simple.ffprobe_simple(output, opts);\n\t\t\t\t}, this);\n\t\t\t});\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\t\n\t};\t\n\t\n});\n\n","Scoped.require([\n    \"betajs:Promise\"\n], function (Promise) {\n\n\tvar DockerPolyfill = require(\"docker-polyfill\");\n\n\tvar VersionRegex = /^ffmpeg version (\\d+)\\.(\\d+)\\.(\\d+).*$/i;\n\tvar ConfigurationRegex = /^\\s+configuration:\\s(.*)$/i;\n\tvar CodecRegexDecoders = /^\\s*(.)(.)(.)(.)(.)(.)\\s+(\\w+)\\s+(.+)\\s*\\(decoders:\\s([^)]+)\\s\\)\\s*(?:\\(encoders:\\s([^)]+)\\s\\))?\\s*$/i;\n    var CodecRegexEncoders = /^\\s*(.)(.)(.)(.)(.)(.)\\s+(\\w+)\\s+(.+)\\s*\\(encoders:\\s([^)]+)\\s\\)\\s*$/i;\n    var CodecRegexNone = /^\\s*(.)(.)(.)(.)(.)(.)\\s+(\\w+)\\s+(.+)\\s*$/i;\n\n\tmodule.exports = {\n\t\t\t\n\t\tffmpeg_test: function (options) {\n\t\t\toptions = options || {};\n\t\t\tvar promise = Promise.create();\n\t\t\tvar cmd = 'ffmpeg';\n\t\t\tvar args = ['-codecs'];\n\t\t\tvar file = DockerPolyfill.polyfillRun({\n\t\t\t\tcommand: options.ffmpeg_binary || \"ffmpeg\",\n\t\t\t\targv: [\"-codecs\"],\n\t\t\t\tdocker: options.docker,\n                timeout: options.timeout\n\t\t\t});\n\t\t\tvar stderr = \"\";\n\t\t\tfile.stderr.on(\"data\", function (data) {\n\t\t\t\tstderr += data;\n\t\t\t});\n\t\t\tvar stdout = \"\";\n            file.stdout.on(\"data\", function (data) {\n                stdout += data;\n            });\n\t\t\tvar timeouted = false;\n\t\t\tfile.on(\"timeout\", function () {\n\t\t\t\ttimeouted = true;\n\t\t\t\tpromise.asyncError(\"Timeout reached\");\n\t\t\t});\n            file.on(\"close\", function (status) {\n\t\t\t\tif (timeouted)\n\t\t\t\t\treturn;\n                if (status !== 0) {\n                    promise.asyncError(\"Cannot execute ffmpeg\");\n                    return;\n\t\t\t\t}\n\t\t\t\tvar result = {\n\t\t\t\t\tversion: {},\n\t\t\t\t\tcodecs: {},\n\t\t\t\t\tcapabilities: {\n                        auto_rotate: false\n\t\t\t\t\t},\n\t\t\t\t\tencoders: [],\n\t\t\t\t\tdecoders: []\n\t\t\t\t};\n\t\t\t\tstderr.split(\"\\n\").forEach(function (line) {\n\t\t\t\t\tvar versionMatch = VersionRegex.exec(line);\n\t\t\t\t\tif (versionMatch) {\n\t\t\t\t\t\tresult.version.major = parseInt(versionMatch[1], 10);\n\t\t\t\t\t\tresult.version.minor = parseInt(versionMatch[2], 10);\n\t\t\t\t\t\tresult.version.revision = parseInt(versionMatch[3], 10);\n\t\t\t\t\t}\n\t\t\t\t\tvar configurationMatch = ConfigurationRegex.exec(line);\n\t\t\t\t\tif (configurationMatch)\n\t\t\t\t\t\tresult.configuration = configurationMatch[1].split(\" \");\n\t\t\t\t});\n\t\t\t\tstdout.split(\"\\n\").forEach(function (line) {\n\t\t\t\t\tvar decodersIdx = 9;\n\t\t\t\t\tvar encodersIdx = 10;\n\t\t\t\t\tvar codecMatch = CodecRegexDecoders.exec(line);\n\t\t\t\t\tif (!codecMatch) {\n                        decodersIdx = 10;\n                        encodersIdx = 9;\n                        codecMatch = CodecRegexEncoders.exec(line);\n                        if (!codecMatch)\n                            codecMatch = CodecRegexNone.exec(line);\n\t\t\t\t\t}\n\t\t\t\t\tif (codecMatch) {\n\t\t\t\t\t\tvar codec = {\n\t\t\t\t\t\t\tsupport: {\n\t\t\t\t\t\t\t\tdecoding: codecMatch[1] === 'D',\n                                encoding: codecMatch[2] === 'E',\n                                video: codecMatch[3] === 'V',\n                                audio: codecMatch[3] === 'A',\n                                intra: codecMatch[4] === 'I',\n                                lossy: codecMatch[5] === 'L',\n                                lossless: codecMatch[6] === 'S'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tshort_name: codecMatch[7],\n\t\t\t\t\t\t\tlong_name: codecMatch[8],\n\t\t\t\t\t\t\tdecoders: codecMatch[decodersIdx] ? codecMatch[decodersIdx].split(\" \") : [],\n                            encoders: codecMatch[encodersIdx] ? codecMatch[encodersIdx].split(\" \") : []\n                        };\n                        result.codecs[codecMatch[7]] = codec;\n\t\t\t\t\t\tresult.decoders = result.decoders.concat(codec.decoders);\n\t\t\t\t\t\tresult.encoders = result.encoders.concat(codec.encoders);\n                    }\n\t\t\t\t});\n\t\t\t\tif (result.version.major >= 3)\n\t\t\t\t\tresult.capabilities.auto_rotate = true;\n\t\t\t\tpromise.asyncSuccess(result);\n\t\t\t});\n\t\t\treturn promise;\n\t\t}\n\t\t\t\n\t};\t\n\t\n});\n\n","Scoped.require([\n    \"betajs:Promise\",\n    \"betajs:Types\"\n], function (Promise, Types) {\n\n    var DockerPolyfill = require(\"docker-polyfill\");\n\n\tvar mean_volume_regex = /.*mean_volume:\\s*([^[\\s]+)\\s*/g;\n\tvar max_volume_regex = /.*max_volume:\\s*([^[\\s]+)\\s*/g;\n\t\n\tmodule.exports = {\n\t\t\t \n\t\tffmpeg_volume_detect: function (inputFile, options) {\n\t\t\toptions = options || {};\n\t\t\tvar promise = Promise.create();\n\t\t\tvar file = DockerPolyfill.polyfillRun({\n\t\t\t\tcommand: options.ffmpeg_binary || \"ffmpeg\",\n\t\t\t\targv: [\n                    \"-i\",\n                    inputFile,\n                    \"-vn\",\n                    \"-af\",\n                    \"volumedetect\",\n                    \"-f\",\n                    \"null\",\n                    \"/dev/null\"\n                ],\n\t\t\t\tdocker: options.docker,\n                timeout: options.timeout\n\t\t\t});\n\t\t\tvar lines = \"\";\n\t\t\tfile.stderr.on(\"data\", function (data) {\n\t\t\t\tvar line = data.toString();\n\t\t\t\tlines += line;\n\t\t\t});\n\t\t\tfile.stderr.on(\"end\", function (data) {\n\t\t\t\tlines += data;\n\t\t\t});\n\t\t\tvar timeouted = false;\n\t\t\tfile.on(\"timeout\", function () {\n\t\t\t\ttimeouted = true;\n\t\t\t\tpromise.asyncError(\"Timeout reached\");\n\t\t\t});\n\t\t\tfile.on(\"close\", function (status) {\n\t\t\t\tif (timeouted)\n\t\t\t\t\treturn;\n                if (status !== 0) {\n                    promise.asyncError(\"Cannot read file\");\n                    return;\n                }\n\t\t\t\tlines = lines.split(\"\\n\");\n\t\t\t\tif (status === 0) {\n\t\t\t\t\tvar mean_volume = null;\n\t\t\t\t\tvar max_volume = null;\n\t\t\t\t\tlines.forEach(function (line) {\n\t\t\t\t\t\tvar mean_volume_match = mean_volume_regex.exec(line);\n\t\t\t\t\t\tif (mean_volume_match)\n\t\t\t\t\t\t\tmean_volume = parseFloat(mean_volume_match[1]);\n\t\t\t\t\t\tvar max_volume_match = max_volume_regex.exec(line);\n\t\t\t\t\t\tif (max_volume_match)\n\t\t\t\t\t\t\tmax_volume = parseFloat(max_volume_match[1]);\n\t\t\t\t\t});\n\t\t\t\t\tpromise.asyncSuccess({\n\t\t\t\t\t\tmean_volume: mean_volume,\n\t\t\t\t\t\tmax_volume: max_volume\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tpromise.asyncError(lines[lines.length - 2]);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn promise;\n\t\t}\n\t\t\t\n\t};\t\n\t\n});\n\n","Scoped.require([\n\t\"betajs:Promise\",\n\t\"betajs:Types\"\n], function(Promise, Types) {\n\n\tvar DockerPolyfill = require(\"docker-polyfill\");\n\tvar FS = require(\"fs\");\n\n\tvar progress_regex = /\\s*([^[=\\s]+)\\s*=\\s*([^[=\\s]+)/g;\n\n\tmodule.exports = {\n\n\t\tffmpeg: function(files, options, output, eventCallback, eventContext, opts) {\n\t\t\topts = opts || {};\n\t\t\tvar promise = Promise.create();\n\t\t\tvar args = [];\n\t\t\tif (Types.is_string(files))\n\t\t\t\tfiles = [files];\n\t\t\tfiles.forEach(function(file) {\n\t\t\t\targs.push(\"-i\");\n\t\t\t\targs.push(file);\n\t\t\t});\n\t\t\targs = args.concat(options);\n\t\t\tif (output) { //when running the playlist script the output won't be used\n\t\t\t\targs.push(\"-y\");\n\t\t\t\targs.push(output);\n\t\t\t\t// Touch file so docker keeps the right owner\n\t\t\t\tFS.writeFileSync(output, \"\");\n\t\t\t\t//\tconsole.log(args.join(\" \"));\n\t\t\t}\n\t\t\tvar file = DockerPolyfill.polyfillRun({\n\t\t\t\tcommand: opts.ffmpeg_binary || \"ffmpeg\",\n\t\t\t\targv: args.join(\" \").split(\" \"),\n\t\t\t\tdocker: opts.docker,\n\t\t\t\ttimeout: opts.timeout\n\t\t\t});\n\t\t\tvar lines = \"\";\n\t\t\tfile.stderr.on(\"data\", function(data) {\n\t\t\t\tvar line = data.toString();\n\t\t\t\tlines += line;\n\t\t\t\tif (line.indexOf(\"frame=\") === 0) {\n\t\t\t\t\tvar progress = line.trim();\n\t\t\t\t\tvar result = {};\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tvar m = progress_regex.exec(progress);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tresult[m[1]] = m[2];\n\t\t\t\t\t}\n\t\t\t\t\tif (eventCallback)\n\t\t\t\t\t\teventCallback.call(eventContext || this, result);\n\t\t\t\t}\n\t\t\t});\n\t\t\tfile.stderr.on(\"end\", function(data) {\n\t\t\t\tlines += data;\n\t\t\t});\n\t\t\tvar timeouted = false;\n\t\t\tfile.on(\"timeout\", function() {\n\t\t\t\ttimeouted = true;\n\t\t\t\tpromise.asyncError({\n\t\t\t\t\tmessage: \"Timeout reached\",\n\t\t\t\t\tcommand: args.join(\" \")\n\t\t\t\t});\n\t\t\t});\n\t\t\tfile.on(\"close\", function(status) {\n\t\t\t\tif (timeouted)\n\t\t\t\t\treturn;\n\t\t\t\tif (status === 0) {\n\t\t\t\t\tpromise.asyncSuccess();\n\t\t\t\t} else {\n\t\t\t\t\tvar errlines = lines.split(\"\\n\");\n\t\t\t\t\tpromise.asyncError({\n\t\t\t\t\t\tmessage: errlines[errlines.length - 2],\n\t\t\t\t\t\tlogs: lines,\n\t\t\t\t\t\tcommand: args.join(\" \")\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn promise;\n\t\t}\n\n\t};\n\n});\n\n","Scoped.require([\n    \"betajs:Promise\",\n    \"betajs:Strings\"\n], function (Promise, Strings) {\n\t\n\tmodule.exports = {\n\t\t\t\n\t\tffprobe_simple: function (file, options) {\n\t\t\tvar parseIntUndefined = function (source, key) {\n\t\t\t\treturn key in source ? parseInt(source[key], 10) : undefined;\n\t\t\t};\n\t\t\t\n\t\t\tif (!Strings.STRICT_URL_REGEX.test(file) && !require('fs').existsSync(file))\n\t\t\t\treturn Promise.error(\"File does not exist\");\n\t\t\treturn require(__dirname + \"/ffprobe.js\").ffprobe(file, options).mapSuccess(function (json) {\n\t\t\t\tif (!json.format || !json.streams)\n\t\t\t\t\treturn Promise.error(\"Cannot read file\");\n\t\t\t\tvar result = {\n\t\t\t\t\tfilename: json.format.filename,\n\t\t\t\t\tstream_count: json.format.nb_streams,\n\t\t\t\t\tsize: parseInt(json.format.size, 10),\n\t\t\t\t\tbit_rate: parseInt(json.format.bit_rate, 10),\n\t\t\t\t\tstart_time: parseFloat(json.format.start_time),\n\t\t\t\t\tduration: parseFloat(json.format.duration),\n\t\t\t\t\tformat_name: json.format.format_long_name,\n\t\t\t\t\tformat_extensions: json.format.format_name.split(\",\"),\n\t\t\t\t\tformat_default_extension: Strings.splitFirst(json.format.format_name, \",\").head\t\t\t\t\n\t\t\t\t};\n\t\t\t\tjson.streams.forEach(function (stream) {\n\t\t\t\t\tif (stream.codec_type === 'video') {\n\t\t\t\t\t\tvar rotation = stream.tags && stream.tags.rotate ? parseInt(stream.tags.rotate, 10) : 0; \n\t\t\t\t\t\tvar video = {\n\t\t\t\t\t\t\tindex: stream.index,\n\t\t\t\t\t\t\trotation: rotation,\n\t\t\t\t\t\t\twidth: stream.width,\n\t\t\t\t\t\t\theight: stream.height,\n\t\t\t\t\t\t\trotated_width: rotation % 180 === 0 ? stream.width : stream.height,\n\t\t\t\t\t\t\trotated_height: rotation % 180 === 0 ? stream.height : stream.width,\n\t\t\t\t\t\t\tcodec_name: stream.codec_tag_string,\n\t\t\t\t\t\t\tcodec_long_name: stream.codec_long_name,\n\t\t\t\t\t\t\tcodec_profile: stream.profile,\n\t\t\t\t\t\t\tbit_rate: parseIntUndefined(stream, \"bit_rate\"),\n\t\t\t\t\t\t\tframes: parseIntUndefined(stream, \"nb_frames\")\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (json.format.format_name === \"image\" || json.format.format_name === \"image2\" || stream.codec_name === 'png')\n\t\t\t\t\t\t\tresult.image = video;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tresult.video = video;\n\t\t\t\t\t} else if (stream.codec_type === 'audio') {\n\t\t\t\t\t\tresult.audio = {\n\t\t\t\t\t\t\tindex: stream.index,\n\t\t\t\t\t\t\tcodec_name: stream.codec_name,\n\t\t\t\t\t\t\tcodec_long_name: stream.codec_long_name,\n\t\t\t\t\t\t\tcodec_profile: stream.profile,\n\t\t\t\t\t\t\taudio_channels: stream.channels,\n\t\t\t\t\t\t\tsample_rate: parseIntUndefined(stream, \"sample_rate\"),\n\t\t\t\t\t\t\tbit_rate: parseIntUndefined(stream, \"bit_rate\")\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn result;\n\t\t\t});\n\t\t}\n\t\t\t\n\t};\n\n});\n","Scoped.require([\n    \"betajs:Promise\"\n], function (Promise) {\n\n\tvar DockerPolyfill = require(\"docker-polyfill\");\n\t\n\tmodule.exports = {\n\t\t\t\n\t\tffprobe: function (fileName, options) {\n\t\t\toptions = options || {};\n\t\t\tvar promise = Promise.create();\n\t\t\tvar file = DockerPolyfill.polyfillRun({\n\t\t\t\tcommand: options.ffprobe_binary || \"ffprobe\",\n\t\t\t\targv: ['-v', 'quiet', '-print_format', 'json', '-show_format', '-show_streams', fileName],\n\t\t\t\tdocker: options.docker,\n                timeout: options.timeout\n\t\t\t});\n\t\t\t/*\n            var stderr = \"\";\n            file.stderr.on(\"data\", function (data) {\n                stderr += data;\n            });\n            */\n            var stdout = \"\";\n            file.stdout.on(\"data\", function (data) {\n                stdout += data;\n            });\n            var timeouted = false;\n            file.on(\"timeout\", function () {\n                timeouted = true;\n                promise.asyncError(\"Timeout reached\");\n            });\n            file.on(\"close\", function (status) {\n                if (timeouted)\n                    return;\n                if (status !== 0) {\n                    promise.asyncError(\"Cannot read file\");\n                    return;\n                }\n                try {\n                    var success = JSON.parse(stdout);\n                    promise.asyncSuccess(success);\n                } catch (e) {\n                    promise.asyncError(\"FFProbe Parse error: \" + stdout);\n                }\n\t\t\t});\n\t\t\treturn promise;\n\t\t}\n\t\t\t\n\t};\t\n\t\n});\n\n","'use strict';\nvar isWindows = process.platform === 'win32';\nvar trailingSlashRe = isWindows ? /[^:]\\\\$/ : /.\\/$/;\n\n// https://github.com/nodejs/node/blob/3e7a14381497a3b73dda68d05b5130563cdab420/lib/os.js#L25-L43\nmodule.exports = function () {\n\tvar path;\n\n\tif (isWindows) {\n\t\tpath = process.env.TEMP ||\n\t\t\tprocess.env.TMP ||\n\t\t\t(process.env.SystemRoot || process.env.windir) + '\\\\temp';\n\t} else {\n\t\tpath = process.env.TMPDIR ||\n\t\t\tprocess.env.TMP ||\n\t\t\tprocess.env.TEMP ||\n\t\t\t'/tmp';\n\t}\n\n\tif (trailingSlashRe.test(path)) {\n\t\tpath = path.slice(0, -1);\n\t}\n\n\treturn path;\n};\n","/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\nconst osTmpDir = require('os-tmpdir');\nconst _c = process.binding('constants');\n\n/*\n * The working inner variables.\n */\nconst\n  /**\n   * The temporary directory.\n   * @type {string}\n   */\n  tmpDir = osTmpDir(),\n\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\n  TEMPLATE_PATTERN = /XXXXXX/,\n\n  DEFAULT_TRIES = 3,\n\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n\n  DIR_MODE = 448 /* 0o700 */,\n  FILE_MODE = 384 /* 0o600 */,\n\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [];\n\nvar\n  _gracefulCleanup = false,\n  _uncaughtException = false;\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  var\n    value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|Function)} options\n * @param {Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  if (typeof options == 'function') {\n    return [callback || {}, options];\n  }\n\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  return [options, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n  if (opts.name) {\n    return path.join(opts.dir || tmpDir, opts.name);\n  }\n\n  // mkstemps like template\n  if (opts.template) {\n    return opts.template.replace(TEMPLATE_PATTERN, _randomChars(6));\n  }\n\n  // prefix and postfix\n  const name = [\n    opts.prefix || 'tmp-',\n    process.pid,\n    _randomChars(12),\n    opts.postfix || ''\n  ].join('');\n\n  return path.join(opts.dir || tmpDir, name);\n}\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1],\n    tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;\n\n  if (isNaN(tries) || tries < 0)\n    return cb(new Error('Invalid tries'));\n\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))\n    return cb(new Error('Invalid template provided'));\n\n  (function _getUniqueName() {\n    const name = _generateTmpName(opts);\n\n    // check whether the path exists then retry if needed\n    fs.stat(name, function (err) {\n      if (!err) {\n        if (tries-- > 0) return _getUniqueName();\n\n        return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n      }\n\n      cb(null, name);\n    });\n  }());\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0],\n    tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;\n\n  if (isNaN(tries) || tries < 0)\n    throw new Error('Invalid tries');\n\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))\n    throw new Error('Invalid template provided');\n\n  do {\n    const name = _generateTmpName(opts);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|fileCallback)} options the config options or the callback function\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  opts.postfix = (_isUndefined(opts.postfix)) ? '.tmp' : opts.postfix;\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(err) {\n          if (err) {\n            // Low probability, and the file exists, so this could be\n            // ignored.  If it isn't we certainly need to unlink the\n            // file, and if that fails too its error is more\n            // important.\n            try {\n              fs.unlinkSync(name);\n            } catch (e) {\n              if (!isENOENT(e)) {\n                err = e;\n              }\n            }\n            return cb(err);\n          }\n          cb(null, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts));\n        });\n      }\n      if (opts.detachDescriptor) {\n        return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));\n      }\n      cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0];\n\n  opts.postfix = opts.postfix || '.tmp';\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd); \n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)\n  };\n}\n\n/**\n * Removes files and folders in a directory recursively.\n *\n * @param {string} root\n * @private\n */\nfunction _rmdirRecursiveSync(root) {\n  const dirs = [root];\n\n  do {\n    var\n      dir = dirs.pop(),\n      deferred = false,\n      files = fs.readdirSync(dir);\n\n    for (var i = 0, length = files.length; i < length; i++) {\n      var\n        file = path.join(dir, files[i]),\n        stat = fs.lstatSync(file); // lstat so we don't recurse into symlinked directories\n\n      if (stat.isDirectory()) {\n        if (!deferred) {\n          deferred = true;\n          dirs.push(dir);\n        }\n        dirs.push(file);\n      } else {\n        fs.unlinkSync(file);\n      }\n    }\n\n    if (!deferred) {\n      fs.rmdirSync(dir);\n    }\n  } while (dirs.length !== 0);\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts)\n  };\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @returns {fileCallback}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts) {\n  const removeCallback = _prepareRemoveCallback(function _removeCallback(fdPath) {\n    try {\n      if (0 <= fdPath[0]) {\n        fs.closeSync(fdPath[0]);\n      }\n    }\n    catch (e) {\n      // under some node/windows related circumstances, a temporary file\n      // may have not be created as expected or the file was already closed\n      // by the user, in which case we will simply ignore the error\n      if (!isEBADF(e) && !isENOENT(e)) {\n        // reraise any unanticipated error\n        throw e;\n      }\n    }\n    try {\n      fs.unlinkSync(fdPath[1]);\n    }\n    catch (e) {\n      if (!isENOENT(e)) {\n        // reraise any unanticipated error\n        throw e;\n      }\n    }\n  }, [fd, name]);\n\n  if (!opts.keep) {\n    _removeObjects.unshift(removeCallback);\n  }\n\n  return removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * @param {string} name\n * @param {Object} opts\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts) {\n  const removeFunction = opts.unsafeCleanup ? _rmdirRecursiveSync : fs.rmdirSync.bind(fs);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name);\n\n  if (!opts.keep) {\n    _removeObjects.unshift(removeCallback);\n  }\n\n  return removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * @param {Function} removeFunction\n * @param {Object} arg\n * @returns {Function}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, arg) {\n  var called = false;\n\n  return function _cleanupCallback(next) {\n    if (!called) {\n      const index = _removeObjects.indexOf(_cleanupCallback);\n      if (index >= 0) {\n        _removeObjects.splice(index, 1);\n      }\n\n      called = true;\n      removeFunction(arg);\n    }\n\n    if (next) next(null);\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  if (_uncaughtException && !_gracefulCleanup) {\n    return;\n  }\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0].call(null);\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n */\nfunction isEBADF(error) {\n  return isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n */\nfunction isENOENT(error) {\n  return isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {String}\n *   error.errno {String|Number} any numerical value will be negated\n *\n * - Node >= 6.0 < 7.0:\n *   error.code {String}\n *   error.errno {Number} negated\n *\n * - Node >= 4.0 < 6.0: introduces SystemError\n *   error.code {String}\n *   error.errno {Number} negated\n *\n * - Node >= 0.10 < 4.0:\n *   error.code {Number} negated\n *   error.errno n/a\n */\nfunction isExpectedError(error, code, errno) {\n  return error.code == code || error.code == errno;\n}\n\n/**\n * Sets the graceful cleanup.\n *\n * Also removes the created files and directories when an uncaught exception occurs.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\nconst version = process.versions.node.split('.').map(function (value) {\n  return parseInt(value, 10);\n});\n\nif (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {\n  process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {\n    _uncaughtException = true;\n    _garbageCollector();\n\n    throw err;\n  });\n}\n\nprocess.addListener('exit', function _exit(code) {\n  if (code) _uncaughtException = true;\n  _garbageCollector();\n});\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?number} tries the number of tries before give up the name generation\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fix name\n * @property {?string} dir the tmp directory to use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call after entry was removed\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\nmodule.exports.tmpdir = tmpDir;\n\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\n\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\n\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\n\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n","import './sw-omnibox.js';\nimport './sw-tips.js';\n","console.log('sw-omnibox.js');\r\n\r\n    ///////\r\nchrome.webRequest.onBeforeSendHeaders.addListener((req) => {\r\n  if(req.url?.includes('videomanifest')){\r\n    var url = req.url;\r\n    if(url.lastIndexOf('&alt')>0){\r\n      url = url.substring(0,url.lastIndexOf('&alt'));\r\n    }\r\n    chrome.storage.local.set({ videomanifest: url })\r\n  }\r\n  return {requestHeaders: req.requestHeaders};\r\n},{\r\n  urls: [\"http://*/*\", \"https://*/*\"],\r\n  types: [\"xmlhttprequest\"]\r\n},[\r\n  'requestHeaders']);\r\n////////\r\n\r\n\r\n// Initialize default API suggestions\r\nchrome.runtime.onInstalled.addListener(({ reason }) => {\r\n  if (reason === 'install') {\r\n    chrome.storage.local.set({\r\n      apiSuggestions: ['tabs', 'storage', 'scripting']\r\n    });\r\n  }\r\n});\r\n","const ffmpeg = require('js-ffmpeg');\r\nconsole.log('sw-tips.js');\r\n\r\nchrome.runtime.onMessage.addListener(async (message, sender, sendResponse) => {\r\n  if (message.greeting === 'downloadAudio') {\r\n    const videoManifestUrl = await chrome.storage.local.get('videomanifest');\r\n    await sendResponse({ downloadAudio: videoManifestUrl });\r\n    // TODO: Implement download audio\r\n    //\r\n    return true;\r\n  }\r\n});\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","","// startup\n// Load entry module and return exports\n__webpack_require__(\"./src/index.js\");\n// This entry module is referenced by other modules so it can't be inlined\n__webpack_require__(\"./src/sw-omnibox.js\");\nvar __webpack_exports__ = __webpack_require__(\"./src/sw-tips.js\");\n",""],"names":[],"sourceRoot":""}